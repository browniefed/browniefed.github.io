<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: animation | JavaScript Without Grammar]]></title>
  <link href="http://browniefed.com/blog/categories/animation/atom.xml" rel="self"/>
  <link href="http://browniefed.com/"/>
  <updated>2016-01-13T09:30:07-08:00</updated>
  <id>http://browniefed.com/</id>
  <author>
    <name><![CDATA[Jason Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[React Native Animated Book]]></title>
    <link href="http://browniefed.com/blog/2015/12/23/react-native-animated-book/"/>
    <updated>2015-12-23T15:31:00-08:00</updated>
    <id>http://browniefed.com/blog/2015/12/23/react-native-animated-book</id>
    <content type="html"><![CDATA[<p>So I wrote a book of sorts on React Native animations. Mostly covering the animated API, and soon much much more. Check it out here <a href="http://browniefed.com/react-native-animation-book/">http://browniefed.com/react-native-animation-book/</a>.</p>

<p>I cover the API, and walk through basic animation examples, and soon advanced topics. Learn to create a fun dragging, spinning square.</p>

<p><img class="<a" src="href="http://browniefed.com/react-native-animation-book/images/SimpleDragAnimation.gif">http://browniefed.com/react-native-animation-book/images/SimpleDragAnimation.gif</a>" title="DragNSpin" ></p>

<p>This is just a quick update :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native - Morphing SVG Paths with React Art]]></title>
    <link href="http://browniefed.com/blog/2015/10/14/react-native-morphing-svg-paths-with-react-art/"/>
    <updated>2015-10-14T20:37:00-07:00</updated>
    <id>http://browniefed.com/blog/2015/10/14/react-native-morphing-svg-paths-with-react-art</id>
    <content type="html"><![CDATA[<p>More paths, more React Art, and more animations. What else have you come to expect of me. A question was posed on Reactiflux about morphing one path to another with React Art. Of course I took this as a &ldquo;challenge&rdquo;.</p>

<p>I say &ldquo;challenge&rdquo; because it took all of a few moments to check out the ART repo and see the <a href="https://github.com/sebmarkbage/art/blob/master/demos/morph/morph.js">Morph Demo</a> which links to <code>art/morph/path</code>. That&rsquo;s of course what this all about, morphing a path. Sebastian Markb√•ge has thought of everything.</p>

<p>On Reactiflux the demo of morphing batman logos was proposed and linked to. You can read the orignal source with the linked SVG at <a href="http://tavmjong.free.fr/blog/?p=741">http://tavmjong.free.fr/blog/?p=741</a>.</p>

<h2>What are we building</h2>

<p><img class="<a" src="href="http://i.imgur.com/KxNBQsb.gif">http://i.imgur.com/KxNBQsb.gif</a>" title="POW BAM KAPOW" ></p>

<!-- more -->


<h2>Concept</h2>

<p>We&rsquo;re going to take a path. In our case all of the Batman logos, and transform each SVG path into the next until we&rsquo;re all out. Then we&rsquo;re going to transform it into a square.</p>

<h2>Setup</h2>

<p>If you&rsquo;re unsure how to get React Art running on React Native checkout my previous blog post here <a href="http://browniefed.com/blog/2015/05/03/getting-react-art-running-on-react-native/">Getting react-art running on react-native</a>.</p>

<p>```
var React = require(&lsquo;react-native&rsquo;);
var ReactART = require(&lsquo;ReactNativeART&rsquo;);
var Dimensions = require(&lsquo;Dimensions&rsquo;);</p>

<p>var {
  width,
  height
} = Dimensions.get(&lsquo;window&rsquo;);</p>

<p>var {
  AppRegistry,
  StyleSheet,
  Text,
  View,
} = React;</p>

<p>var {
  Surface,
  Shape
} = ReactART;</p>

<p>var Morph = require(&lsquo;art/morph/path&rsquo;);
<code>``
We bring in the usuals, but also require</code>art/morph/path` which will do our magic morphing.</p>

<h2>The SVG Paths</h2>

<p>Thanks to the blog post I just parsed out the SVG paths, and tossed them into an array. For the sake of parsing, I map over each and convert them into native React Art paths.</p>

<p>```
var BatmanLogoSVGs = [
  &rsquo;M 256,213 C 245,181 206,187 234,262 147,181 169,71.2 233,18   220,56   235,81   283,88   285,78.7 286,69.3 288,60   289,61.3 290,62.7 291,64   291,64   297,63   300,63   303,63   309,64   309,64   310,62.7 311,61.3 312,60   314,69.3 315,78.7 317,88   365,82   380,56   367,18   431,71   453,181 366,262 394,187 356,181 344,213 328,185 309,184 300,284 291,184 272,185 256,213 Z',       <br/>
  &rsquo;M 212,220 C 197,171 156,153 123,221 109,157 120,109  159,63.6 190,114  234,115  254,89.8 260,82.3 268,69.6 270,60.3 273,66.5 275,71.6 280,75.6 286,79.5 294,79.8 300,79.8 306,79.8 314,79.5 320,75.6 325,71.6 327,66.5 330,60.3 332,69.6 340,82.3 346,89.8 366,115  410,114  441,63.6 480,109  491,157 477,221 444,153 403,171 388,220 366,188 316,200 300,248 284,200 234,188 212,220 Z',      <br/>
  &rsquo;M 213,222 C 219,150 165,139 130,183 125,123 171,73.8 247,51.6 205,78   236,108  280,102  281,90.3 282,79   286,68.2 287,72   288,75.8 289,79.7 293,79.7 296,79.7 300,79.7 304,79.7 307,79.7 311,79.7 312,75.8 313,72   314,68.2 318,79   319,90.3 320,102  364,108  395,78   353,51.6 429,73.8 475,123 470,183 435,139 381,150 387,222 364,176 315,172 300,248 285,172 236,176 213,222 Z',</p>

<pre><code>// There are many more, truncated for blog reading purposes
</code></pre>

<p>];</p>

<p>var BatmanLogoPaths = BatmanLogoSVGs.map((svg) => Morph.Path(svg));</p>

<p>var square = Morph.Path()
  .move(100,0)
  .line(100,0)
  .line(0,100)
  .line(-100,0)
  .close();</p>

<p>BatmanLogoPaths.push(square);</p>

<p>```</p>

<p>Then we throw a square on the end.</p>

<h2>Render</h2>

<p>There is nothing special here. We just add a <code>Surface</code> the full width/height of the phone and instead of a string SVG path we give it the transition which just happens to be a <code>MorphPath</code>, which extends from <code>Path</code> which React Art knows what to do with. Fancy.</p>

<p>```
  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
    &lt;Surface width={width} height={height}&gt;
      &lt;Shape x={-100} y={100} d={this.state.transition} fill="#000" /&gt;
    &lt;/Surface&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
```
The person that created the SVGs made the central point the start of the SVG so we just set it back -100 to center it-ish. I don&rsquo;t know. We fill it with black. Batman likes black.</p>

<h2>Initial Setup</h2>

<p>```
  getInitialState: function() {</p>

<pre><code>return {
  transition: Morph.Tween(BatmanLogoPaths[0], BatmanLogoPaths[1])
};
</code></pre>

<p>  },
  componentWillMount: function() {</p>

<pre><code>this._current = 1;
</code></pre>

<p>  },
  componentDidMount: function() {</p>

<pre><code>this.animate(null, this.nextAnimation)
</code></pre>

<p>  },
<code>``
We start the intial render with a</code>Morph.Tween<code>of the first and second Batman logos. We do a little setup in</code>componentWillMount` to say we&rsquo;re currently animating to the second logo (it&rsquo;s a 1 since we have 0 based array indexes).</p>

<p>Then once the component is mounted we kick off the animation with our <code>this.animate</code> call.</p>

<h2>Animate it</h2>

<p>```
  animate: function(start, cb) {</p>

<pre><code>requestAnimationFrame((timestamp) =&gt; {
  if (!start) start = timestamp;
  var delta = (timestamp - start) / 1000;

  if (delta &gt; 1) return cb();

  this.state.transition.tween(delta);
  this.setState(this.state);
  this.animate(start, cb);
})
</code></pre>

<p>  },
```</p>

<p>Our animate call takes a start, and a callback for when the animation is complete. Thanks to React Native with get a polyfilled <code>requestAnimationFrame</code>. If we don&rsquo;t have a start, then we set it to the timestamp that <code>requestAnimationFrame</code> provides us. The start allows us to compute how far along in the animation we are.</p>

<p>The <code>delta</code> is the current <code>timestamp</code> which is some amount of time in the future, minus the <code>start</code>. The <code>/1000</code> is the amount of time each animation will take. So each morph will take <code>1000ms</code> to complete.</p>

<p>If our change is greater than 1 then we know our animation is complete and trigger are callback, and also return so we don&rsquo;t keep animating a complete animation.</p>

<p>We tween our transition with the new <code>delta</code> progress, we trigger a <code>setState</code> to cause our UI to re-render, then we call ourself (aka <code>this.animate</code>), with our <code>start</code> and our <code>callback</code> so we can trigger the next animation frame.</p>

<p>A lot of this is just boilerplate logic you can see here <a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame">https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame</a>.</p>

<h2>Animate it Again</h2>

<p>```
  nextAnimation: function() {</p>

<pre><code>this._current += 1;
if (this._current &gt;= BatmanLogoPaths.length) return;

this.setState({
  transition: Morph.Tween(BatmanLogoPaths[this._current - 1], BatmanLogoPaths[this._current])
}, () =&gt; this.animate(null, this.nextAnimation))
</code></pre>

<p>  },
```
Okay so we need a little logic around keeping track of which logo is transitioning to which other shape. If this function is called it means an animation has completed and we need to trigger the next one.</p>

<p>We add one to the current to setup that we&rsquo;re about to animate to the next logo path.</p>

<p>First we check if it&rsquo;s equal to or somehow greater than the amount of logos we have. If it is we stop animating and just leave the current render as the last shape in the array.</p>

<p>If not we trigger a setState to adjust the <code>this.state.transition</code> (which we pass into the <code>Shape</code>). This just gets set to the <code>this._current - 1</code> logo and then the <code>this._current</code> which is going to be the next logo. Because currently on screen is <code>this._current - 1</code> and we do a <code>setState</code>, nothing will flash/jump since you&rsquo;re rendering the same exact shape again.</p>

<p><code>setState</code> also takes a success callback, meaning the UI has updated, we then kick off the animation. TahDah. Batman Animating.</p>

<h2>More than Batman Logos?</h2>

<p>Of course. You can animate from anything to anything with <code>Morph.Tween</code>. See I animated Batman into a square at the end. But really you can do any sort of path to another path. If you&rsquo;re animating a complex path to another compelx path they not animate elegantly but they&rsquo;ll animate.</p>

<h2>Clean it up</h2>

<p><code>setState</code> is hacky for animations, you could wrap this up just like Animated to make it all nice and performant with <code>setNativeProps</code> but you can take care of that yourself. Vjeux shows how to do that in his React Rally talk, seriously watch it <a href="https://www.youtube.com/watch?v=xtqUJVqpKNo">https://www.youtube.com/watch?v=xtqUJVqpKNo</a>. Also slides here <a href="https://speakerdeck.com/vjeux/react-rally-animated-react-performance-toolbox">https://speakerdeck.com/vjeux/react-rally-animated-react-performance-toolbox</a></p>

<h2>Done</h2>

<p>Okay, so now you know how to morph paths. Go make cool animated transitions on React Native now!</p>

<h4>Live Demo: <a href="https://rnplay.org/apps/9txbFQ">https://rnplay.org/apps/9txbFQ</a></h4>

<h2>Final Code</h2>

<p>```
var React = require(&lsquo;react-native&rsquo;);
var ReactART = require(&lsquo;ReactNativeART&rsquo;);
var Dimensions = require(&lsquo;Dimensions&rsquo;);</p>

<p>var {
  width,
  height
} = Dimensions.get(&lsquo;window&rsquo;);</p>

<p>var {
  AppRegistry,
  StyleSheet,
  Text,
  View,
} = React;</p>

<p>var {
  Surface,
  Shape
} = ReactART;</p>

<p>var Morph = require(&lsquo;art/morph/path&rsquo;);</p>

<p>var BatmanLogoSVGs = [
  &rsquo;M 256,213 C 245,181 206,187 234,262 147,181 169,71.2 233,18   220,56   235,81   283,88   285,78.7 286,69.3 288,60   289,61.3 290,62.7 291,64   291,64   297,63   300,63   303,63   309,64   309,64   310,62.7 311,61.3 312,60   314,69.3 315,78.7 317,88   365,82   380,56   367,18   431,71   453,181 366,262 394,187 356,181 344,213 328,185 309,184 300,284 291,184 272,185 256,213 Z',       <br/>
  &rsquo;M 212,220 C 197,171 156,153 123,221 109,157 120,109  159,63.6 190,114  234,115  254,89.8 260,82.3 268,69.6 270,60.3 273,66.5 275,71.6 280,75.6 286,79.5 294,79.8 300,79.8 306,79.8 314,79.5 320,75.6 325,71.6 327,66.5 330,60.3 332,69.6 340,82.3 346,89.8 366,115  410,114  441,63.6 480,109  491,157 477,221 444,153 403,171 388,220 366,188 316,200 300,248 284,200 234,188 212,220 Z',      <br/>
  &rsquo;M 213,222 C 219,150 165,139 130,183 125,123 171,73.8 247,51.6 205,78   236,108  280,102  281,90.3 282,79   286,68.2 287,72   288,75.8 289,79.7 293,79.7 296,79.7 300,79.7 304,79.7 307,79.7 311,79.7 312,75.8 313,72   314,68.2 318,79   319,90.3 320,102  364,108  395,78   353,51.6 429,73.8 475,123 470,183 435,139 381,150 387,222 364,176 315,172 300,248 285,172 236,176 213,222 Z',      <br/>
  &rsquo;M 218,231 C 191,238 165,252 140,266 144,209 156,153  193,93.7 218,106  249,105  280,102  282,90.3 284,78.6 289,67.8 290,71.6 291,75.8 292,79.7 292,79.7 297,79.7 300,79.7 303,79.7 308,79.7 308,79.7 309,75.8 310,71.6 311,67.8 316,78.6 318,90.3 320,102  351,105  382,106  407,93.7 444,153  456,209 460,266 435,252 409,238 382,231 355,224 328,223 300,223 272,223 245,224 218,231 Z',       <br/>
  &rsquo;M 258,243 C 220,201 221,220 253,281 154,243 150,108  229,61.9 242,83   257,98.1 275,110  278,88   282,65.8 285,43.6 287,49.9 288,56.2 290,62.5 293,62.7 297,62.9 300,62.9 303,62.9 307,62.7 310,62.5 312,56.2 313,49.9 315,43.6 318,65.8 322,88   325,110  343,98.1 358,83   371,61.9 450,108  446,243 347,281 379,220 380,201 342,243 330,187 329,202 300,271 271,202 270,187 258,243 Z',       <br/>
  &rsquo;M 235,210 C 214,139 143,145 183,229 108,175 135,70.1 242,48.3 190,85.6 245,142  278,95.5 281,80.2 281,62.7 284,48.7 287,53.9 287,59.1 289,64.5 292,64.7 297,64.2 300,64.2 303,64.2 308,64.7 311,64.5 313,59.1 313,53.9 316,48.7 319,62.7 319,80.2 322,95.5 355,142  410,85.6 358,48.3 465,70.1 492,175 417,229 457,145 386,139 365,210 357,147 309,190 300,271 291,190 243,147 235,210 Z',       <br/>
  &rsquo;M 249,157 C 214,157 201,203 273,255 157,221 157,69   274,32.8 188,87.2 211,140  256,140  291,140  289,128  291,98.1 293,107  293,116  295,125  297,125  298,125  300,125  302,125  305,125  305,125  307,116  307,107  309,98.1 311,128  309,140  344,140  389,140  412,87.2 326,32.8 443,69   443,221 327,255 399,203 386,157 351,157 317,157 300,195 300,238 300,195 283,157 249,157 Z',      <br/>
  &rsquo;M 264,212 C 213,138 150,171 232,244 101,217 112,55.1 257,36.9 182,86.6 222,106  266,106  285,106  284,66.7 286,36.8 288,42.6 289,48.4 291,54.2 291,54.2 297,54.2 300,54.2 303,54.2 309,54.2 309,54.2 311,48.4 312,42.6 314,36.8 316,66.7 315,106  334,106  378,106  418,86.6 343,36.9 488,55.1 499,217 368,244 450,171 387,138 336,212 354,161 300,163 300,249 300,163 246,161 264,212 Z',       <br/>
  &rsquo;M 223,217 C 194,153 165,168 133,219 143,158 161,99.2 189,38.4 214,69.8 241,84.7 272,86.2 272,70.2 273,53.5 273,37.5 275,47.9 278,58.4 280,68.8 287,64.9 292,62.4 300,62.4 308,62.4 313,64.9 320,68.8 322,58.4 325,47.9 327,37.5 327,53.5 328,70.2 328,86.2 359,84.7 386,69.8 411,38.4 439,99.2 457,158 467,219 435,168 406,153 377,217 350,162 319,176 300,245 281,176 250,162 223,217 Z',       <br/>
  &rsquo;M 231,185 C 186,159 161,180 190,215 86.2,180 92.6,99.6 211,68.9 195,112 254,141 279,96.7 279,83.2 279,69.8 279,56.3 283,63.6 288,70.8 292,78.1 295,78.1 297,78.1 300,78.1 303,78.1 305,78.1 308,78.1 312,70.8 317,63.6 321,56.3 321,69.8 321,83.2 321,96.7 346,141 405,112 389,68.9 507,99.6 514,180 410,215 439,180 414,159 369,185 351,165 324,167 300,216 276,167 249,165 231,185 Z',   <br/>
  &rsquo;M 194,146 C 192,107 164,76.4 136,45.6 166,55.7 196,65.7 226,75.8 238,107 265,163 279,136 282,130 281,108 281,94.8 285,103 288,111 293,115 295,116 298,117 300,117 302,117 305,116 307,115 312,111 315,103 319,94.8 319,108 318,130 321,136 335,163 362,107 374,75.8 404,65.7 434,55.7 464,45.6 436,76.4 408,107 406,146 355,158 323,189 300,231 277,189 245,158 194,146 Z',      <br/>
  &rsquo;M 209,182 C 184,132 176,138 113,161 140,136 168,111 196,86.5 221,104 247,115 278,115 281,99.9 285,85.5 287,70.2 289,78.5 292,88.4 294,96.7 296,96.7 298,96.7 300,96.7 302,96.7 304,96.7 306,96.7 308,88.4 311,78.5 313,70.2 315,85.5 319,99.9 322,115 353,115 379,104 404,86.5 432,111 460,136 487,161 424,138 416,132 391,182 332,150 341,161 300,214 259,161 268,150 209,182 Z',       <br/>
  &rsquo;M 198,171 C 189,131 150,120 113,140 142,104 182,74.4 249,70.2 208,89 248,125 278,106 285,101 286,93.5 286,74.2 288,78.1 291,81.5 294,83.2 296,84.2 298,84.7 300,84.7 302,84.7 304,84.2 306,83.2 309,81.5 312,78.1 314,74.2 314,93.5 315,101 322,106 352,125 392,89 351,70.2 418,74.4 458,104 487,140 450,120 411,131 402,171 357,147 322,171 300,214 278,171 243,147 198,171 Z',       <br/>
  &rsquo;M 202,170 C 188,115 157,108 124,105 146,84.3 171,71.5 199,70.2 211,98.6 243,103 277,106 279,99.3 281,92.6 283,86 285,91.9 287,97.9 290,104 293,104 297,104 300,104 303,104 307,104 310,104 313,97.9 315,91.9 317,86 319,92.6 321,99.3 323,106 357,103 389,98.6 401,70.2 429,71.5 454,84.3 476,105 443,108 412,115 398,170 349,157 318,175 300,214 282,175 251,157 202,170 Z',       <br/>
  &rsquo;M 220,179 C 200,127 150,130 123,175 122,110 160,85.1 201,64 208,99.2 243,111 268,92.9 278,86.1 284,68.2 287,40.7 289,49.6 292,58.4 294,67.3 296,67.3 298,67.3 300,67.3 302,67.3 304,67.3 306,67.3 308,58.4 311,49.6 313,40.7 316,68.2 322,86.1 332,92.9 357,111 392,99.3 399,64 440,85.1 478,110 477,175 450,130 400,127 380,179 355,155 305,208 300,247 295,208 245,155 220,179 Z',       <br/>
  &rsquo;M 166,154 C 179,119 154,95.4 114,79.3 155,79.1 197,78.9 239,78.7 242,103 250,109 283,109 289,109 290,93.9 291,83.7 292,88.3 292,92.9 293,97.5 295,97.5 298,97.5 300,97.5 302,97.5 305,97.5 307,97.5 308,92.9 308,88.3 309,83.7 310,93.9 311,109 317,109 350,109 358,103 361,78.7 403,78.9 445,79.1 486,79.3 446,95.4 421,119 434,154 377,151 320,151 300,207 280,151 223,151 166,154 Z'
];</p>

<p>var BatmanLogoPaths = BatmanLogoSVGs.map((svg) => Morph.Path(svg));</p>

<p>var square = Morph.Path()
  .move(100,0)
  .line(100,0)
  .line(0,100)
  .line(-100,0)
  .close();</p>

<p>BatmanLogoPaths.push(square);</p>

<p>var rn_morph = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
  transition: Morph.Tween(BatmanLogoPaths[0], BatmanLogoPaths[1])
};
</code></pre>

<p>  },
  componentWillMount: function() {</p>

<pre><code>this._current = 1;
</code></pre>

<p>  },
  componentDidMount: function() {</p>

<pre><code>this.animate(null, this.nextAnimation)
</code></pre>

<p>  },
  nextAnimation: function() {</p>

<pre><code>this._current += 1;
if (this._current &gt;= BatmanLogoPaths.length) return;

this.setState({
  transition: Morph.Tween(BatmanLogoPaths[this._current - 1], BatmanLogoPaths[this._current])
}, () =&gt; this.animate(null, this.nextAnimation))
</code></pre>

<p>  },
  animate: function(start, cb) {</p>

<pre><code>requestAnimationFrame((timestamp) =&gt; {
  if (!start) start = timestamp;
  var delta = (timestamp - start) / 1000;

  if (delta &gt; 1) return cb();

  this.state.transition.tween(delta);
  this.setState(this.state);
  this.animate(start, cb);
})
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
    &lt;Surface width={width} height={height}&gt;
      &lt;Shape x={-100} y={100} d={this.state.transition} fill="#000" /&gt;
    &lt;/Surface&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
});</p>

<p>var styles = StyleSheet.create({
  container: {</p>

<pre><code>flex: 1
</code></pre>

<p>  },</p>

<p>});</p>

<p>AppRegistry.registerComponent(&lsquo;rn_morph&rsquo;, () => rn_morph);</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native Periscope Hearts Animation]]></title>
    <link href="http://browniefed.com/blog/2015/09/07/react-native-periscope-hearts-animation/"/>
    <updated>2015-09-07T11:02:00-07:00</updated>
    <id>http://browniefed.com/blog/2015/09/07/react-native-periscope-hearts-animation</id>
    <content type="html"><![CDATA[<h1>Introduction</h1>

<p>I was contacted asking if it was possible to recreate the periscope heart animations in react-native. I was also linked to someone rebuilding the same effect in Framer.js, you can check out the linked video here <a href="https://www.youtube.com/watch?v=qFUXxqzZytU">https://www.youtube.com/watch?v=qFUXxqzZytU</a>.</p>

<p>Periscope not only has an iPhone/Android app but it also has a web app with the same heart effect. I could take a look at the animations being done on it but we&rsquo;ll just eye ball it.</p>

<h1>What we are building</h1>

<p><img class="<a" src="href="http://i.imgur.com/5JhgzQV.gif">http://i.imgur.com/5JhgzQV.gif</a>" title="Purple floating fading swaying rotating hearts" ></p>

<h3>Live code: <a href="https://rnplay.org/apps/8VhSjw">https://rnplay.org/apps/8VhSjw</a></h3>

<!-- more -->


<h1>What it looks like on Periscope</h1>

<p>If you don&rsquo;t know what I&rsquo;m talking about, the heart animation looks like this.</p>

<p><img class="<a" src="href="http://i.imgur.com/sEJf9Md.gif">http://i.imgur.com/sEJf9Md.gif</a>" title="Periscope hearts" ></p>

<h1>Break Down</h1>

<p>In order to replicate the animation we have to break it down into it&rsquo;s parts.</p>

<ul>
<li>Heart appears and scales up then quickly scales back down. Animation <code>Scale 0 =&gt; Scale 1.2 =&gt; Scale 1</code></li>
<li>Heart moves upwards with a slight sway to the left then back to the right. <code>X/Y from 0 =&gt; deviceHeight/2</code></li>
<li>Slight rotation of the heart through out each sway <code>rotate -15deg =&gt; 0 =&gt; 15deg</code></li>
<li>Heart opacity fades out over entire animation <code>opacity 1 =&gt; 0</code></li>
</ul>


<p>We likely won&rsquo;t need <code>Animated</code> values for all of these, the goal of Animating is to attempt to interpolate other values from one <code>Animated.Value</code>. In our case that one constant is the <code>X/Y</code> values. All of the other animations are dependent on where the heart is currently located.</p>

<p>The opacity is derived from the <code>X/Y</code> that it can be an interpolated value. The scale could be interpolated too, with 3 small input ranges, and output ranges of <code>[0, 1.2, 1]</code>. The rotation can also be interpolated based upon the <code>X</code> value. Even the X can be interpolated based upon the Y if we determine that we want 2 sways to happen before the animation is complete.</p>

<h1>Make the Heart</h1>

<p>Now we have to decide how to make the heart. One option is to use an <code>&lt;Image /&gt;</code> however this means I have to open up an image editor and I&rsquo;m a developer, not a designer! If you haven&rsquo;t seen <a href="https://css-tricks.com/examples/ShapesOfCSS/">The Shapes of CSS</a> I recommend checking it out. For basics shapes CSS will work great, and in our case a heart is a simple shape.</p>

<p>It&rsquo;s composed of 2 objects overlayed on top of each other. Two squares, with top left / top right border radiuses and then drop them on top of each other.</p>

<p>Apart they look like this</p>

<p><img class="<a" src="href="http://i.imgur.com/mUu1Yt8.png">http://i.imgur.com/mUu1Yt8.png</a>" title="Two squares not slammed together" ></p>

<p>Then together we get a heart!</p>

<p><img class="<a" src="href="http://i.imgur.com/o8WOlDU.png">http://i.imgur.com/o8WOlDU.png</a>" title="Now it&rsquo;s a heart" ></p>

<p>This also gives us control over the color more easily, the sizing, and anything else you can do with a simple view.</p>

<h1>Setup</h1>

<p>```
var React = require(&lsquo;react-native&rsquo;);
var Dimensions = require(&lsquo;Dimensions&rsquo;);</p>

<p>var {
  width: deviceWidth,
  height: deviceHeight
} = Dimensions.get(&lsquo;window&rsquo;);</p>

<p>var {
  AppRegistry,
  StyleSheet,
  View,
  Animated,
  TouchableWithoutFeedback
} = React;</p>

<p>var ANIMATION_END_Y = Math.ceil(deviceHeight * .5);
var NEGATIVE_END_Y = ANIMATION_END_Y * -1;
var startCount = 1;
<code>``
We'll bring in the necessary includes. The</code>ANIMATION_END_Y<code>and the reverse</code>NEGATIVE_END_Y` will become apparent as what they are later. Due to some interpolation we&rsquo;ll need to do some trickery to make our animation interpolations make more sense.</p>

<h1>Create The Heart</h1>

<p>As we showed before the heart is 2 pieces. These pieces will have to be absolutely positioned so lets creating a wrapping view, and 2 pieces. We&rsquo;ll style each piece <code>leftHeart</code> and <code>rightHeat</code>. Then setup some styles.</p>

<p>```
var Heart = React.createClass({</p>

<pre><code>render: function() {
    return (
        &lt;View {...this.props} style={[styles.heart, this.props.style]}&gt;
            &lt;View style={styles.leftHeart} /&gt;
            &lt;View style={styles.rightHeart} /&gt;
        &lt;/View&gt;
    )
}
</code></pre>

<p>})</p>

<p>//Styles</p>

<p>  heart: {</p>

<pre><code>width: 50,
height: 50
</code></pre>

<p>  },
  heartShape: {</p>

<pre><code>width: 30,
height: 45,
position: 'absolute',
top: 0,
borderTopLeftRadius: 15,
borderTopRightRadius: 15,
backgroundColor: '#6427d1',
</code></pre>

<p>  },
  leftHeart: {</p>

<pre><code>transform: [
    {rotate: '-45deg'}
],
left: 5
</code></pre>

<p>  },
  rightHeart: {</p>

<pre><code>transform: [
    {rotate: '45deg'}
],
right: 5
</code></pre>

<p>  }</p>

<p><code>``
We set a width and height on the wrapping heart so it takes up space. We move all default styling into</code>heartShape<code>style and give it a nice purple color. Then we just adjust each left and right heart. The</code>leftHeart<code>piece will be on the left side, and rotated</code>-45deg<code>aka</code>45deg` towards the left, and the right will be the reverse.</p>

<h1>Setup Base Rendering</h1>

<p>```
var HeartFloater = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {};
</code></pre>

<p>  },</p>

<p>  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
    &lt;Animated.View style={styles.heartWrap}&gt;
      &lt;Heart /&gt;
    &lt;/Animated.View&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
});</p>

<p>var styles = StyleSheet.create({
  container: {</p>

<pre><code>flex: 1
</code></pre>

<p>  },
  heartWrap: {</p>

<pre><code>  position: 'absolute',
  bottom: 50,
  right: (deviceWidth/2) - 25
</code></pre>

<p>  },
  heart: {</p>

<pre><code>width: 50,
height: 50
</code></pre>

<p>  },
  heartShape: {</p>

<pre><code>width: 30,
height: 45,
position: 'absolute',
top: 0,
borderTopLeftRadius: 15,
borderTopRightRadius: 15,
backgroundColor: '#6427d1',
</code></pre>

<p>  },
  leftHeart: {</p>

<pre><code>transform: [
    {rotate: '-45deg'}
],
left: 5
</code></pre>

<p>  },
  rightHeart: {</p>

<pre><code>transform: [
    {rotate: '45deg'}
],
right: 5
</code></pre>

<p>  }
});
```</p>

<p>Nothing much to call out here, except we add a new <code>heartWrap</code> class. We&rsquo;ll leave the heart be a static heart and then just animate a wrapper. The <code>heartWrap</code> is positioned absolutely and centered.</p>

<h1>Move the Heart</h1>

<p>```
var HeartFloater = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
  position: new Animated.Value(0)
};
</code></pre>

<p>  },
  componentDidMount: function() {</p>

<pre><code>Animated.timing(this.state.position, {
  duration: 2000,
  toValue: NEGATIVE_END_Y
}).start();
</code></pre>

<p>  },
  getHeartAnimationStyle: function() {</p>

<pre><code>return {
  transform: [
    {translateY: this.state.position},
  ]
}
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
    &lt;Animated.View style={[styles.heartWrap, this.getHeartAnimationStyle()]}&gt;
      &lt;Heart /&gt;
    &lt;/Animated.View&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
});
```</p>

<p>We only setup a basic <code>Animated.Value</code> instead of an <code>Animated.ValueXY</code> because we will interpolate all the necessary effects and even the <code>X</code> position from the <code>Y</code> value.</p>

<p>We kick off an animation when the component mounts to animate the heart from <code>0</code> to negative half <code>deviceHeight</code>. We do this since translateY moves up when it is negative, and moves down when it is positive. We do this animation for 2 seconds.</p>

<h1>Fade the Heart</h1>

<p>Now this is where we are going to get a little tricky with interpolation.</p>

<p>```
  componentWillMount: function() {</p>

<pre><code>this._yAnimation = this.state.position.interpolate({
  inputRange: [NEGATIVE_END_Y, 0],
  outputRange: [ANIMATION_END_Y, 0]
});

this._opacityAnimation = this._yAnimation.interpolate({
  inputRange: [0, ANIMATION_END_Y],
  outputRange: [1, 0]
})
</code></pre>

<p>  },</p>

<p>  getHeartAnimationStyle: function() {</p>

<pre><code>return {
  transform: [
    {translateY: this.state.position},
  ],
  opacity: this._opacityAnimation
}
</code></pre>

<p>  },
```
You can interpolate on an interpolated value. So we&rsquo;ll map our negative values, directly to positive values and also flip the step scale.</p>

<p>Our animation would typically go from <code>0</code> to <code>-300</code> but our new <code>_yAnimation</code> will flip that and stay we are animation goes from <code>0</code> to <code>300</code>.</p>

<p>This allows our animations like <code>opacity</code> to make more sense. We can interpolate on our <code>this._yAnimation</code> and specify <code>[0, ANIMATION_END_Y]</code> is tied to the opacity values <code>[1,0]</code>. So <code>0</code> aka the start is at <code>opacity</code> of <code>1</code> and moves to <code>0</code> which is tied to the <code>ANIMATION_END_Y</code> (roughly 300 depending on your device).</p>

<p>Then we pass the interpolated opacity value in <code>opacity</code>.</p>

<h1>Scale the Heart</h1>

<p>```</p>

<pre><code>this._scaleAnimation = this._yAnimation.interpolate({
  inputRange: [0, 15, 30],
  outputRange: [0, 1.2, 1],
  extrapolate: 'clamp'
})

getHeartAnimationStyle: function() {
return {
  transform: [
    {translateY: this.state.position},
    {scale: this._scaleAnimation}
  ],
  opacity: this._opacityAnimation
}
</code></pre>

<p>  },
```</p>

<p>Now we&rsquo;ll add another animation below the other that will handle the scale. Because our now interpolated value runs positively we can just define pixel scale steps. So <code>0</code> maps to <code>0</code> so on creation the heart doesn&rsquo;t exist. The heart will quickly scale from <code>0</code> to <code>1.2x</code> it&rsquo;s size over the first <code>15</code> pixels it travels, then from <code>15</code> to <code>30</code> pixels it&rsquo;ll scale back down from <code>1.2</code> to <code>1</code>.</p>

<p>This gives us a quick little pulse of the heart. We must add the <code>extrapolate: clamp</code> otherwise the heart will start scaling down and eventually go negative causing the heart to flip.</p>

<h1>Rotate/Sway the Heart</h1>

<p>Almost done! Now lets make it sway a little bit. This one is a little difficult to fine tune, but I errored on the less dramtic side of things.</p>

<p>```
this.<em>xAnimation = this.</em>yAnimation.interpolate({
  inputRange: [0, ANIMATION_END_Y/2, ANIMATION_END_Y],
  outputRange: [0, 15, 0]
})</p>

<p>this.<em>rotateAnimation = this.</em>yAnimation.interpolate({
  inputRange: [0, ANIMATION_END_Y/4, ANIMATION_END_Y/3, ANIMATION_END_Y/2, ANIMATION_END_Y],
  outputRange: [&lsquo;0deg&rsquo;, &lsquo;-2deg&rsquo;, &lsquo;0deg&rsquo;, &lsquo;2deg&rsquo;, &lsquo;0deg&rsquo;]
});</p>

<p>getHeartAnimationStyle: function() {
  return {</p>

<pre><code>transform: [
  {translateY: this.state.position},
  {translateX: this._xAnimation},
  {scale: this._scaleAnimation},
  {rotate: this._rotateAnimation}
],
opacity: this._opacityAnimation
</code></pre>

<p>  }
},
```</p>

<p>This causes one sway to happen for <code>15</code> pixels then come back to the center. There are three rotations that happen that will make it look like it&rsquo;s wobbling a bit more.</p>

<p>The <code>_xAnimation</code> input range is from <code>0</code> to half the animation, to the end. Since our value of the <code>_xAnimation</code> interpolation is the end value of the animation we don&rsquo;t need to <code>extrapolate: clamp</code> here.</p>

<p>The <code>_rotateAnimation</code> takes <code>5</code> different steps. We just divide by each step. We start at <code>0</code>, then divide by 4 for quarter of the height animation, then a third of animation, half of the animation, then finally rotate back to 0 to finish the animation off. I pulled these out of thin air, and it looks okay but could use some fine tuning.</p>

<h1>Make AnimatedHeart component</h1>

<p>Now lets make it show a bunch of hearts when we press down. Each press should put another heart onto an array, and when the heart is done animating we should remove it.</p>

<p>First move all the code to an <code>AnimatedHeart</code> like so.</p>

<p>```
var AnimatedHeart = React.createClass({
  getDefaultProps: function() {</p>

<pre><code>return {
  onComplete: function() {}
};
</code></pre>

<p>  },
  getInitialState: function() {</p>

<pre><code>return {
  position: new Animated.Value(0)
};
</code></pre>

<p>  },
  componentWillMount: function() {</p>

<pre><code>this._yAnimation = this.state.position.interpolate({
  inputRange: [NEGATIVE_END_Y, 0],
  outputRange: [ANIMATION_END_Y, 0]
});

this._opacityAnimation = this._yAnimation.interpolate({
  inputRange: [0, ANIMATION_END_Y],
  outputRange: [1, 0]
});

this._scaleAnimation = this._yAnimation.interpolate({
  inputRange: [0, 15, 30],
  outputRange: [0, 1.2, 1],
  extrapolate: 'clamp'
});

this._xAnimation = this._yAnimation.interpolate({
  inputRange: [0, ANIMATION_END_Y/2, ANIMATION_END_Y],
  outputRange: [0, 15, 0]
})

this._rotateAnimation = this._yAnimation.interpolate({
  inputRange: [0, ANIMATION_END_Y/4, ANIMATION_END_Y/3, ANIMATION_END_Y/2, ANIMATION_END_Y],
  outputRange: ['0deg', '-2deg', '0deg', '2deg', '0deg']
});
</code></pre>

<p>  },
  componentDidMount: function() {</p>

<pre><code>Animated.timing(this.state.position, {
  duration: 2000,
  toValue: NEGATIVE_END_Y
}).start(this.props.onComplete);
</code></pre>

<p>  },
  getHeartAnimationStyle: function() {</p>

<pre><code>return {
  transform: [
    {translateY: this.state.position},
    {translateX: this._xAnimation},
    {scale: this._scaleAnimation},
    {rotate: this._rotateAnimation}
  ],
  opacity: this._opacityAnimation
}
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
    &lt;Animated.View style={[styles.heartWrap, this.getHeartAnimationStyle(), this.props.style]}&gt;
      &lt;Heart /&gt;
    &lt;/Animated.View&gt;
)
</code></pre>

<p>  }
})
```</p>

<p>We modified a few things. We adjusted our <code>style</code> to include <code>this.props.style</code>.
Also we added a callback when the animation is finished.</p>

<p>```
  componentDidMount: function() {</p>

<pre><code>Animated.timing(this.state.position, {
  duration: 2000,
  toValue: NEGATIVE_END_Y
}).start(this.props.onComplete);
</code></pre>

<p>  },
```</p>

<h1>Add AnimatedHeart on press</h1>

<p>```
//<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random</a>
function getRandomNumber(min, max) {
  return Math.random() * (max &ndash; min) + min;
}</p>

<p>var HeartFloater = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
  hearts: [] 
};
</code></pre>

<p>  },
  addHeart: function() {</p>

<pre><code>startCount += 1;
this.state.hearts.push({
  id: startCount,
  right: getRandomNumber(50, 150)
});
this.setState(this.state);
</code></pre>

<p>  },
  removeHeart: function(v) {</p>

<pre><code>var index = this.state.hearts.findIndex(function(heart) { return heart.id === v});
this.state.hearts.splice(index, 1);
this.setState(this.state);
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
    &lt;TouchableWithoutFeedback style={styles.container} onPress={this.addHeart}&gt;
      &lt;View style={styles.container}&gt;
        {
          this.state.hearts.map(function(v, i) {
            return (
                &lt;AnimatedHeart 
                  key={v.id}
                  onComplete={this.removeHeart.bind(this, v.id)}
                  style=
                /&gt;
            ) 
          }, this)
        }
      &lt;/View&gt;
    &lt;/TouchableWithoutFeedback&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
});
```</p>

<p>Our HeartFloater, now has a hearts array to hold our hearts for state. We&rsquo;ve adjusted our <code>render</code> to use <code>TouchableWithoutFeedback</code> to call <code>addHeart</code> on press.</p>

<p>Each press will increase our <code>startCount</code> which we use as an id generator. Also we add a random <code>right</code> style. a</p>

<p>Our render just loops over each heart, and renders the <code>AnimatedHeart</code> with a <code>key</code> which is essential for performance, an <code>onComplete</code> which is called when our animation is finished, and the right style we randomly generated.</p>

<p>On complete we call remove. Which finds the index of the heart, splices it, and sets state.</p>

<h1>Fix Background Colors and Styles</h1>

<p>```
  heartWrap: {</p>

<pre><code>  position: 'absolute',
  bottom: 30,
  backgroundColor: 'transparent'
</code></pre>

<p>  },
  heart: {</p>

<pre><code>width: 50,
height: 50,
backgroundColor: 'transparent'
</code></pre>

<p>  },
```</p>

<p>Without setting the background to transparent the background will be white causing one heart to clip another. This will prevent that.</p>

<p>We also removed the <code>right</code> position since we generate random positions between <code>50</code> and <code>150</code>.</p>

<h1>Final</h1>

<p>Thank you to Anthony Webb for the submission. As always check out the live code on RNPlay.</p>

<h3>Live code: <a href="https://rnplay.org/apps/8VhSjw">https://rnplay.org/apps/8VhSjw</a></h3>

<p>If you any other inquiries do let me know and I&rsquo;ll show you how to build them.</p>

<p><img class="<a" src="href="http://i.imgur.com/5JhgzQV.gif">http://i.imgur.com/5JhgzQV.gif</a>" title="Purple floating fading swaying rotating hearts" ></p>

<h1>Final Code</h1>

<p>```
var React = require(&lsquo;react-native&rsquo;);
var Dimensions = require(&lsquo;Dimensions&rsquo;);</p>

<p>var {
  width: deviceWidth,
  height: deviceHeight
} = Dimensions.get(&lsquo;window&rsquo;);</p>

<p>var {
  AppRegistry,
  StyleSheet,
  View,
  Animated,
  TouchableWithoutFeedback
} = React;</p>

<p>var ANIMATION_END_Y = Math.ceil(deviceHeight * .5);
var NEGATIVE_END_Y = ANIMATION_END_Y * -1;
var startCount = 1;</p>

<p>function getRandomNumber(min, max) {
  return Math.random() * (max &ndash; min) + min;
}</p>

<p>var Heart = React.createClass({</p>

<pre><code>render: function() {
    return (
        &lt;View {...this.props} style={[styles.heart, this.props.style]}&gt;
            &lt;View style={[styles.leftHeart, styles.heartShape]} /&gt;
            &lt;View style={[styles.rightHeart, styles.heartShape]} /&gt;
        &lt;/View&gt;
    )
}
</code></pre>

<p>});</p>

<p>var AnimatedHeart = React.createClass({
  getDefaultProps: function() {</p>

<pre><code>return {
  onComplete: function() {}
};
</code></pre>

<p>  },
  getInitialState: function() {</p>

<pre><code>return {
  position: new Animated.Value(0)
};
</code></pre>

<p>  },
  componentWillMount: function() {</p>

<pre><code>this._yAnimation = this.state.position.interpolate({
  inputRange: [NEGATIVE_END_Y, 0],
  outputRange: [ANIMATION_END_Y, 0]
});

this._opacityAnimation = this._yAnimation.interpolate({
  inputRange: [0, ANIMATION_END_Y],
  outputRange: [1, 0]
});

this._scaleAnimation = this._yAnimation.interpolate({
  inputRange: [0, 15, 30],
  outputRange: [0, 1.2, 1],
  extrapolate: 'clamp'
});

this._xAnimation = this._yAnimation.interpolate({
  inputRange: [0, ANIMATION_END_Y/2, ANIMATION_END_Y],
  outputRange: [0, 15, 0]
})

this._rotateAnimation = this._yAnimation.interpolate({
  inputRange: [0, ANIMATION_END_Y/4, ANIMATION_END_Y/3, ANIMATION_END_Y/2, ANIMATION_END_Y],
  outputRange: ['0deg', '-2deg', '0deg', '2deg', '0deg']
});
</code></pre>

<p>  },
  componentDidMount: function() {</p>

<pre><code>Animated.timing(this.state.position, {
  duration: 2000,
  toValue: NEGATIVE_END_Y
}).start(this.props.onComplete);
</code></pre>

<p>  },
  getHeartAnimationStyle: function() {</p>

<pre><code>return {
  transform: [
    {translateY: this.state.position},
    {translateX: this._xAnimation},
    {scale: this._scaleAnimation},
    {rotate: this._rotateAnimation}
  ],
  opacity: this._opacityAnimation
}
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
    &lt;Animated.View style={[styles.heartWrap, this.getHeartAnimationStyle(), this.props.style]}&gt;
      &lt;Heart /&gt;
    &lt;/Animated.View&gt;
)
</code></pre>

<p>  }
})</p>

<p>var HeartFloater = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
  hearts: [] 
};
</code></pre>

<p>  },
  addHeart: function() {</p>

<pre><code>startCount += 1;
this.state.hearts.push({
  id: startCount,
  right: getRandomNumber(50, 150)
});
this.setState(this.state);
</code></pre>

<p>  },
  removeHeart: function(v) {</p>

<pre><code>var index = this.state.hearts.findIndex(function(heart) { return heart.id === v});
this.state.hearts.splice(index, 1);
this.setState(this.state);
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
    &lt;TouchableWithoutFeedback style={styles.container} onPress={this.addHeart}&gt;
      &lt;View style={styles.container}&gt;
        {
          this.state.hearts.map(function(v, i) {
            return (
                &lt;AnimatedHeart 
                  key={v.id}
                  onComplete={this.removeHeart.bind(this, v.id)}
                  style=
                /&gt;
            ) 
          }, this)
        }
      &lt;/View&gt;
    &lt;/TouchableWithoutFeedback&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
});</p>

<p>var styles = StyleSheet.create({
  container: {</p>

<pre><code>flex: 1
</code></pre>

<p>  },
  heartWrap: {</p>

<pre><code>  position: 'absolute',
  bottom: 30,
  backgroundColor: 'transparent'
</code></pre>

<p>  },
  heart: {</p>

<pre><code>width: 50,
height: 50,
backgroundColor: 'transparent'
</code></pre>

<p>  },
  heartShape: {</p>

<pre><code>width: 30,
height: 45,
position: 'absolute',
top: 0,
borderTopLeftRadius: 15,
borderTopRightRadius: 15,
backgroundColor: '#6427d1',
</code></pre>

<p>  },
  leftHeart: {</p>

<pre><code>transform: [
    {rotate: '-45deg'}
],
left: 5
</code></pre>

<p>  },
  rightHeart: {</p>

<pre><code>transform: [
    {rotate: '45deg'}
],
right: 5
</code></pre>

<p>  }
});</p>

<p>AppRegistry.registerComponent(&lsquo;animate_slide&rsquo;, () => HeartFloater);</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native Youtube Animated Video Slide]]></title>
    <link href="http://browniefed.com/blog/2015/08/31/react-native-youtube-animated-video-slide/"/>
    <updated>2015-08-31T08:58:00-07:00</updated>
    <id>http://browniefed.com/blog/2015/08/31/react-native-youtube-animated-video-slide</id>
    <content type="html"><![CDATA[<h1>Introduciton</h1>

<p>I was going to spend some time digging into <a href="https://github.com/ProjectSeptemberInc/gl-react-native">gl-react-native</a> when someone asked in the slack channel how to achieve youtube like video sliding navigation. Now I won&rsquo;t get into the navigation portion, just the animation part. The navigation portion can be solved by basically treating video routes as a modal. Thus they are always over the top of whatever the previous route was.</p>

<h1>What are we building?</h1>

<p>If you haven&rsquo;t seen it, YouTube allows you to drag the current playing video down to the bottom right corner and have it continue to play while you browse the rest of the app.</p>

<p>Something like this.</p>

<p><img class="<a" src="href="http://i.imgur.com/gwbkw5f.gif">http://i.imgur.com/gwbkw5f.gif</a>" title="YouTube demo clone" ></p>

<!-- more -->


<h1>Setup</h1>

<p>React native doesn&rsquo;t have a <code>Video</code> component but Brent Vatne created a fantastic video component called <a href="https://github.com/brentvatne/react-native-video">react-native-video</a>. This allows you to use videos added to your app bundle, or external video urls.</p>

<p>So unlike a normal project you will need to run <code>npm install react-native-video --save</code>. Then follow the instructions on the <code>README</code> in <code>react-native-video</code> on how to add the library in XCode.</p>

<p>```
var React = require(&lsquo;react-native&rsquo;);
var Video = require(&lsquo;react-native-video&rsquo;);</p>

<p>var Dimensions = require(&lsquo;Dimensions&rsquo;);
var {width: deviceWidth, height: deviceHeight} = Dimensions.get(&lsquo;window&rsquo;);</p>

<p>var videoWidth = deviceWidth,</p>

<pre><code>videoHeight = Math.round((deviceWidth/16)*9);
</code></pre>

<p>var {
  AppRegistry,
  StyleSheet,
  View,
  Text,
  Animated,
  PanResponder,
  ScrollView
} = React;</p>

<p>var AnimatedVideo = Animated.createAnimatedComponent(Video);
var AnimatedScrollView = Animated.createAnimatedComponent(ScrollView);</p>

<p>```</p>

<p>So a few things to call out here.</p>

<p>We pull in dimensions of the screen and name them <code>deviceHeight</code> and <code>deviceWidth</code>. This is so we can calculate <code>videoWidth</code> and <code>videoHeight</code>. We use a simple calculation to create a video that is in the <code>16:9</code> aspect ratio.</p>

<p>Then we use <code>createAnimatedComponent</code> to create an animated <code>ScrollView</code> and <code>AnimatedVideo</code> element.</p>

<h1>Basic Component</h1>

<p></p>

<p>```
var YoutubeVideoSlide = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
  scale: new Animated.Value(1),
  position: new Animated.ValueXY(),
};
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
          &lt;AnimatedVideo 
              source={{uri: "http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4"}}
              style={styles.videoSizing}
              rate={1}
              paused={false}
              volume={1}
              resizeMode={'stretch'}
              repeat={true} 
          /&gt;
        &lt;AnimatedScrollView style={styles.container}&gt;
          &lt;View style={styles.comment}&gt;
            &lt;Text&gt;Video Comment&lt;/Text&gt;
          &lt;/View&gt;
        &lt;/AnimatedScrollView&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
});</p>

<p>var styles = StyleSheet.create({
  container: {</p>

<pre><code>flex: 1
</code></pre>

<p>  },
  videoSizing: {</p>

<pre><code>width: videoWidth,
height: videoHeight
</code></pre>

<p>  },
  comment: {</p>

<pre><code>height: 100
</code></pre>

<p>  }
});</p>

<p>```</p>

<p></p>

<p>We setup <code>flex:1</code> on the <code>View</code> so that the <code>ScrollView</code> will size correctly. We set the <code>width</code> and <code>height</code> on the <code>AnimatedVideo</code> to our <code>16:9</code> ratio. In the state we setup the initial scale to <code>1</code>, and an <code>X,Y</code> position for the moving video.</p>

<h1>Setup the PanResponder</h1>

<p>```</p>

<pre><code>this._panResponder = PanResponder.create({
  onStartShouldSetPanResponder: (evt, gestureState) =&gt; true,
  onStartShouldSetPanResponderCapture: (evt, gestureState) =&gt; true,
  onMoveShouldSetPanResponder: (evt, gestureState) =&gt; true,
  onMoveShouldSetPanResponderCapture: (evt, gestureState) =&gt; true,
  onPanResponderMove: Animated.event([
      null, 
      {
          dy: this.state.position.y
      }
  ])
});
</code></pre>

<p>```</p>

<p>We&rsquo;ll do the normal &ldquo;say yes to allowing us to touch things&rdquo;, and then we&rsquo;ll setup an <code>Animated.event</code>. This is a helper function to traverse the arguments from <code>onPanResponderMove</code> and update an Animated value.</p>

<p><code>onPanResponderMove</code> gets called with an <code>event</code> as the first argument, and <code>gestureState</code> as the second. The <code>null</code> tells <code>Animated.event</code> to ignore the first argument, but to grab the <code>dy</code> from the <code>gestureState</code> and update the <code>y</code> value on our <code>Animated.ValueXY</code> we created.</p>

<h1>Interpolate and Animate</h1>

<p>```</p>

<pre><code>this._scale = this.state.position.y.interpolate({
  inputRange: [0, deviceHeight ],
  outputRange: [1, .71],
  extrapolate: 'clamp'
});

this._translateY = this.state.position.y.interpolate({
  inputRange: [0, deviceHeight],
  outputRange: [0, deviceHeight],
  extrapolate: 'clamp'
});

this.state.position.y.addListener((value) =&gt; {
  this._y = value.value;
  var scaleValue = this._scale.__getAnimatedValue();
  var currentVideoWidth = scaleValue * videoWidth;
  var buffer = ((videoWidth - currentVideoWidth)/2);
  this.state.position.x.setValue(buffer);
}.bind(this));

this._opacity = this.state.position.y.interpolate({
  inputRange: [0, deviceHeight ],
  outputRange: [1, .1]
});
</code></pre>

<p>```</p>

<p>Now we need to setup a few more things in the <code>componentWillMount</code>. The <code>this._scale</code> will be set on a scale transform. This is directly tied to the <code>y</code> position of us dragging. So we setup an interpolate, which goes from <code>0</code> to the <code>deviceHeight</code> and map that to an output range of <code>1</code> to <code>.71</code>. The <code>.71</code> was a trial and error number, I&rsquo;m sure there is math to calculate this but I guessed till I got it right.</p>

<p>The <code>clamp</code> is to say that this value cannot go above or below these values.</p>

<p>You may be wondering why we setup <code>translateY</code> when the <code>inputRange</code> and <code>outputRange</code> are exactly the same. The <code>clamp</code> is the key part. This means that if a user tries to slide the video up it will not grow in scale, or slide the video upwards. It can only go down.</p>

<p>We setup the listener so we can keep track of our <code>y</code> value, we&rsquo;ll get into that later. We&rsquo;ll use <code>__getAnimatedValue</code> to get the current scale. <strong>THIS WILL NOT WORK IN .11-rc</strong> and above. You cannot currently listen on interpolated values, and we need the interpolated value for our math.</p>

<p>We get the original <code>videoWidth</code> and multiply it times the scale value so we can get the current <code>videoWidth</code>. We subtract the <code>currentVideoWidth</code> from the <code>videoWidth</code> and divide it by <code>2</code> to get the current buffer. That buffer is the space between the right side of the video and the current scaled video. If we don&rsquo;t do this then the X/Y scaling on the video will just squish it to the middle of the screen. What we want to do is have it slide down the right side of the screen.</p>

<p>Finally we setup the opacity, this is for the <code>scrollView</code> to slowly fade as we swipe down.</p>

<h1>Setup the styling</h1>

<p>```
  getScalePosition: function() {</p>

<pre><code>return {
  transform: [
    {scale: this._scale},
    {translateX: this.state.position.x},
    {translateY: this._translateY}
  ]
}
</code></pre>

<p>  },
  getScrollOffset: function() {</p>

<pre><code>return {
  transform: [
    {translateY: this._translateY},
  ],
  opacity: this._opacity
}
</code></pre>

<p>  },</p>

<pre><code>&lt;AnimatedVideo 
  {...this._panResponder.panHandlers}
  source=
  style={[styles.videoSizing, this.getScalePosition()]}
  rate={this.state.rate}
  paused={this.state.paused}
  volume={this.state.volume}
  muted={this.state.muted}
  resizeMode={this.state.resizeMode}
  repeat={true}
/&gt;
&lt;AnimatedScrollView style={[styles.container, this.getScrollOffset()]}&gt;
&lt;/AnimatedScrollView&gt;
</code></pre>

<p>```</p>

<p>Here we set default styling, and then make our calls to get the style objects with our animated values. For our video scale position we pass our <code>this._scale</code> to <code>scale</code> to transform both <code>scaleX</code>, and <code>scaleY</code>. We pass in our position x, and our <code>this._translateY</code> that is clamped.</p>

<p>For our <code>ScrollView</code> , we setup <code>translateY</code>, and pass in the opacity we created.</p>

<h1>Set Offset and Animate the Release</h1>

<p>```</p>

<pre><code>this._panResponder = PanResponder.create({
  onStartShouldSetPanResponder: (evt, gestureState) =&gt; true,
  onStartShouldSetPanResponderCapture: (evt, gestureState) =&gt; true,
  onMoveShouldSetPanResponder: (evt, gestureState) =&gt; true,
  onMoveShouldSetPanResponderCapture: (evt, gestureState) =&gt; true,
  onPanResponderGrant: function() {
    this.state.position.y.setOffset(this._y)
  }.bind(this),
  onPanResponderMove: Animated.event([
      null, 
      {
          dy: this.state.position.y
      }
  ]),
  onPanResponderRelease: (e, gestureState) =&gt; {
    this.state.position.flattenOffset();

    if (gestureState.dy &gt;= 40) {
      Animated.timing(this.state.position.y, {
        duration: 200,
        toValue: deviceHeight
      }).start();
    } else {
      Animated.timing(this.state.position.y, {
        duration: 200,
        toValue: 0
      }).start();
    }

  }.bind(this)
});
</code></pre>

<p>```</p>

<p>When I said we&rsquo;d get to why we kept track of the <code>y</code> this is why. This is so we can set the offset of the initial press and prevent the video from jumping. It will work for sliding down, but with <code>dy</code> it is always the delta. So on the slide up from the bottom it would immediately jump to the top, and we don&rsquo;t want that.</p>

<p>```</p>

<pre><code>  onPanResponderGrant: function() {
    this.state.position.y.setOffset(this._y)
  }.bind(this),
</code></pre>

<p>```
This code sets the initial offset when you first touch to whatever the current y value is.</p>

<p>```</p>

<pre><code>  onPanResponderRelease: (e, gestureState) =&gt; {
    this.state.position.flattenOffset();

    if (gestureState.dy &gt;= 100) {
      Animated.timing(this.state.position.y, {
        duration: 200,
        toValue: deviceHeight
      }).start();
    } else {
      Animated.timing(this.state.position.y, {
        duration: 200,
        toValue: 0
      }).start();
    }

  }.bind(this)
</code></pre>

<p>```</p>

<p>On release we flatten the offset. Which just squashes the current value and offset together.
If the user has moved greater than <code>100</code> pixels then we&rsquo;ll animate the video to the bottom of the screen. If not we&rsquo;ll animate it back to the top.</p>

<h1>Final</h1>

<p>As always check it out on RNPlay at <a href="https://rnplay.org/apps/Cp_SSA">https://rnplay.org/apps/Cp_SSA</a>.
The video source comes from <a href="http://camendesign.com/code/video_for_everybody/test.html">http://camendesign.com/code/video_for_everybody/test.html</a>. It&rsquo;s a wonderfully open sourced mp4 video that we can link to test out.</p>

<h1>Full Code</h1>

<p></p>

<p>```
var React = require(&lsquo;react-native&rsquo;);
var Dimensions = require(&lsquo;Dimensions&rsquo;);
var {width: deviceWidth, height: deviceHeight} = Dimensions.get(&lsquo;window&rsquo;);
var Video = require(&lsquo;react-native-video&rsquo;);</p>

<p>var videoWidth = deviceWidth,</p>

<pre><code>videoHeight = Math.round((deviceWidth/16)*9);
</code></pre>

<p>var {
  AppRegistry,
  StyleSheet,
  View,
  Text,
  Animated,
  PanResponder,
  ScrollView
} = React;</p>

<p>var AnimatedVideo = Animated.createAnimatedComponent(Video);
var AnimatedScrollView = Animated.createAnimatedComponent(ScrollView);</p>

<p>var YoutubeVideoSlide = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
  rate: 1,
  volume: 1,
  muted: true,
  resizeMode: 'stretch',
  duration: 0.0,
  currentTime: 0.0,
  scale: new Animated.Value(1),
  position: new Animated.ValueXY(),

};
</code></pre>

<p>  },
  _y: 0,
  componentWillMount: function() {</p>

<pre><code>this._panResponder = PanResponder.create({
  onStartShouldSetPanResponder: (evt, gestureState) =&gt; true,
  onStartShouldSetPanResponderCapture: (evt, gestureState) =&gt; true,
  onMoveShouldSetPanResponder: (evt, gestureState) =&gt; true,
  onMoveShouldSetPanResponderCapture: (evt, gestureState) =&gt; true,
  onPanResponderGrant: function() {
    this.state.position.y.setOffset(this._y)
  }.bind(this),
  onPanResponderMove: Animated.event([
      null, 
      {
          dy: this.state.position.y
      }
  ]),
  onPanResponderRelease: (e, gestureState) =&gt; {
    this.state.position.flattenOffset();

    if (gestureState.dy &gt;= 100) {
      Animated.timing(this.state.position.y, {
        duration: 200,
        toValue: deviceHeight
      }).start();
    } else {
      Animated.timing(this.state.position.y, {
        duration: 200,
        toValue: 0
      }).start();
    }

  }.bind(this)
});

this._scale = this.state.position.y.interpolate({
  inputRange: [0, deviceHeight ],
  outputRange: [1, .71],
  extrapolate: 'clamp'
});

this._translateY = this.state.position.y.interpolate({
  inputRange: [0, deviceHeight],
  outputRange: [0, deviceHeight],
  extrapolate: 'clamp'
});

this.state.position.y.addListener((value) =&gt; {
  this._y = value.value;
  var scaleValue = this._scale.__getAnimatedValue();
  var currentVideoWidth = scaleValue * videoWidth;
  var buffer = ((videoWidth - currentVideoWidth)/2);
  this.state.position.x.setValue(buffer);
}.bind(this));

this._opacity = this.state.position.y.interpolate({
  inputRange: [0, deviceHeight ],
  outputRange: [1, .1]
});
</code></pre>

<p>  },
  getScalePosition: function() {</p>

<pre><code>return {
  transform: [
    {scale: this._scale},
    {translateX: this.state.position.x},
    {translateY: this._translateY}
  ]
}
</code></pre>

<p>  },
  getScrollOffset: function() {</p>

<pre><code>return {
  transform: [
    {translateY: this._translateY},
  ],
  opacity: this._opacity
}
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
          &lt;AnimatedVideo 
              {...this._panResponder.panHandlers}
              source={{uri: "http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4"}}
              style={[styles.videoSizing, this.getScalePosition()]}
              rate={this.state.rate}
              paused={this.state.paused}
              volume={this.state.volume}
              muted={this.state.muted}
              resizeMode={this.state.resizeMode}
              repeat={true} 
          /&gt;
        &lt;AnimatedScrollView style={[styles.container, this.getScrollOffset()]}&gt;
          &lt;View style={styles.comment}&gt;
            &lt;Text&gt;Video Comment&lt;/Text&gt;
          &lt;/View&gt;
          &lt;View style={styles.comment}&gt;
            &lt;Text&gt;Video Comment&lt;/Text&gt;
          &lt;/View&gt;
          &lt;View style={styles.comment}&gt;
            &lt;Text&gt;Video Comment&lt;/Text&gt;
          &lt;/View&gt;
          &lt;View style={styles.comment}&gt;
            &lt;Text&gt;Video Comment&lt;/Text&gt;
          &lt;/View&gt;
          &lt;View style={styles.comment}&gt;
            &lt;Text&gt;Video Comment&lt;/Text&gt;
          &lt;/View&gt;
          &lt;View style={styles.comment}&gt;
            &lt;Text&gt;Video Comment&lt;/Text&gt;
          &lt;/View&gt;
          &lt;View style={styles.comment}&gt;
            &lt;Text&gt;Video Comment&lt;/Text&gt;
          &lt;/View&gt;
        &lt;/AnimatedScrollView&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
});</p>

<p>var styles = StyleSheet.create({
  container: {</p>

<pre><code>flex: 1
</code></pre>

<p>  },
  videoSizing: {</p>

<pre><code>width: videoWidth,
height: videoHeight
</code></pre>

<p>  },
  comment: {</p>

<pre><code>height: 100
</code></pre>

<p>  }
});</p>

<p>```
</p>
]]></content>
  </entry>
  
</feed>
