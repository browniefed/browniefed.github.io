<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: animations | JavaScript Without Grammar]]></title>
  <link href="http://browniefed.com/blog/categories/animations/atom.xml" rel="self"/>
  <link href="http://browniefed.com/"/>
  <updated>2016-01-13T09:25:20-08:00</updated>
  <id>http://browniefed.com/</id>
  <author>
    <name><![CDATA[Jason Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[React Native - How to create Twitter exploding hearts]]></title>
    <link href="http://browniefed.com/blog/2015/11/07/react-native-how-to-create-twitter-exploding-hearts/"/>
    <updated>2015-11-07T08:55:00-08:00</updated>
    <id>http://browniefed.com/blog/2015/11/07/react-native-how-to-create-twitter-exploding-hearts</id>
    <content type="html"><![CDATA[<p>So we&rsquo;re going to build this exploding heart, except just know Twitter kind of cheated. Not really but they used an image and played each frame adjusting <code>background-position</code> so it looked animated. Okay not cheated they used a really smart technique but what&rsquo;s the fun in doing that when we can build it for real!</p>

<p>I&rsquo;ve already built a Firework concept here <a href="http://browniefed.com/blog/2015/08/29/react-native-animated-with-react-art-firework-show/">http://browniefed.com/blog/2015/08/29/react-native-animated-with-react-art-firework-show/</a> and about Hearts here <a href="http://browniefed.com/blog/2015/09/07/react-native-periscope-hearts-animation/">http://browniefed.com/blog/2015/09/07/react-native-periscope-hearts-animation/</a> now we just need to bring them together.</p>

<p>For the record this is what theirs looks like here <a href="http://i.imgur.com/3a8PiSY.png">http://i.imgur.com/3a8PiSY.png</a></p>

<h2>What are we building</h2>

<p><img class="<a" src="href="http://i.imgur.com/lMOxqIL.gif">http://i.imgur.com/lMOxqIL.gif</a>" title="So not lazy like Twitter" ></p>

<!-- more -->


<h2>Concept</h2>

<p>Rather than iterating over 28 separate image frames what we&rsquo;re going to do instead is make some pseudo-keyframe-animations. We&rsquo;ll use <code>Animated</code> of course. We&rsquo;ll define our range from <code>0</code> to <code>28</code>. Meaning we&rsquo;ll have 28 frames to deal with.</p>

<p>This makes the math easy, because we can walk through each frame, and describe what the animation should look like for each frame.</p>

<p>We could create separate animated values for each property and coordinate the animation with <code>Animated.sequence</code> and <code>Animated.parallel</code> but I prefer interpolation. YMMV</p>

<h2>Setup</h2>

<p>```
var React = require(&lsquo;react-native&rsquo;);</p>

<p>var {
  AppRegistry,
  StyleSheet,
  View,
  Dimensions,
  TouchableWithoutFeedback,
  Animated
} = React;</p>

<p>var Art = require(&lsquo;ReactNativeART&rsquo;);</p>

<p>var {
  Surface,
  Group,
  Shape,
  Path
} = Art;</p>

<p>var AnimatedShape = Animated.createAnimatedComponent(Shape);</p>

<p>var {
  width: deviceWidth,
  height: deviceHeight
} = Dimensions.get(&lsquo;window&rsquo;);</p>

<p><code>``
We'll need to setup</code>ReactNativeArt` in XCode, you can check out how to do that <a href="http://browniefed.com/blog/2015/05/03/getting-react-art-running-on-react-native/">here</a>.</p>

<p>Things to call out here is we are creating a custom animated view, called <code>AnimatedShape</code>. We pass in the <code>art</code> <code>Shape</code> component into <code>Animated.createAnimatedComponent</code>. This allows us to use <code>Animated</code> values in any component.</p>

<h2>More Setup</h2>

<p>```
var HEART_SVG = &ldquo;M130.4-0.8c25.4 0 46 20.6 46 46.1 0 13.1-5.5 24.9-14.2 33.3L88 153.6 12.5 77.3c-7.9-8.3-12.8-19.6-12.8-31.9 0-25.5 20.6-46.1 46-46.2 19.1 0 35.5 11.7 42.4 28.4C94.9 11 111.3-0.8 130.4-0.8&rdquo;
var HEART_COLOR = &lsquo;rgb(226,38,77,1)&rsquo;;
var GRAY_HEART_COLOR = &ldquo;rgb(204,204,204,1)&rdquo;;</p>

<p>var FILL_COLORS = [
  &lsquo;rgba(221,70,136,1)&rsquo;,
  &lsquo;rgba(212,106,191,1)&rsquo;,
  &lsquo;rgba(204,142,245,1)&rsquo;,
  &lsquo;rgba(204,142,245,1)&rsquo;,
  &lsquo;rgba(204,142,245,1)&rsquo;,
  &lsquo;rgba(0,0,0,0)&rsquo;
];</p>

<p>var PARTICLE_COLORS = [
  &lsquo;rgb(158, 202, 250)&rsquo;,
  &lsquo;rgb(161, 235, 206)&rsquo;,
  &lsquo;rgb(208, 148, 246)&rsquo;,
  &lsquo;rgb(244, 141, 166)&rsquo;,
  &lsquo;rgb(234, 171, 104)&rsquo;,
  &lsquo;rgb(170, 163, 186)&rsquo;
]
```</p>

<p>More setup here. We create our heart SVG path to render, and setup a bunch of colors that we will use in our animations later. We need to set stuff up as <code>rgb</code> or <code>rgba</code> so that <code>Animated</code> can interpolate it correctly as at the moment it cannot do hex values.</p>

<p>```</p>

<p>function getXYParticle(total, i, radius) {
  var angle = ( (2*Math.PI) / total ) * i;</p>

<p>  var x = Math.round((radius<em>2) * Math.cos(angle &ndash; (Math.PI/2)));
  var y = Math.round((radius</em>2) * Math.sin(angle &ndash; (Math.PI/2)));
  return {</p>

<pre><code>x: x,
y: y
</code></pre>

<p>  }
}</p>

<p>function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max &ndash; min)) + min;
}</p>

<p>function shuffleArray(array) {</p>

<pre><code>for (var i = array.length - 1; i &gt; 0; i--) {
    var j = Math.floor(Math.random() * (i + 1));
    var temp = array[i];
    array[i] = array[j];
    array[j] = temp;
}
return array;
</code></pre>

<p>}</p>

<p><code>``
Yes more setup.</code>getXYParticle` is a function I&rsquo;ve modified from the fireworks particle blog post I wrote. This essentially distributes a random number of particles around a circle. This is what we will use for the little particles that blow up.</p>

<p>The <code>getRandomInt</code> is pretty self explanatory, but it just returns a random number and we&rsquo;ll use it to create some variance.</p>

<p><code>shuffleArray</code> also just shuffles things in an array, we&rsquo;ll use this to achieve random color effects later.</p>

<h2>Blank Canvas</h2>

<p>```
var ExplodingHearts = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
  animation: new Animated.Value(0) 
};
</code></pre>

<p>  },
  explode: function() {</p>

<pre><code>Animated.timing(this.state.animation, {
  duration: 1500,
  toValue: 28
}).start(() =&gt; {
  this.state.animation.setValue(0);
  this.forceUpdate();
}.bind(this));
</code></pre>

<p>  },</p>

<p>  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
    &lt;TouchableWithoutFeedback onPress={this.explode} style={styles.container}&gt; 
      &lt;View&gt;
        &lt;Surface width={deviceWidth} height={deviceHeight}&gt;
        &lt;/Surface&gt;
      &lt;/View&gt;
    &lt;/TouchableWithoutFeedback&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
});</p>

<p>```</p>

<p>We setup a blank canvas. We need to create our initial <code>animation</code> value so we just do a <code>new Animated.Value(0)</code> in our <code>getInitialState</code>.</p>

<p>We setup a <code>TouchableWithoutFeedback</code> for the ability to use <code>onPress</code> to trigger our animation. We then setup our <code>ART</code> <code>Surface</code> to fill the screen.</p>

<p>Why are we using ART for this? Well it&rsquo;ll make our rendering and animations very efficient, we could use a bunch of <code>Views</code> for this demo but on a large scale with lots of graphics work you should use <code>ART</code></p>

<p>Our <code>explode</code> function kicks off our animation and we do it over 1.5 seconds. We will animate to 28 because that is how many &ldquo;frames&rdquo; we have.</p>

<p>Don&rsquo;t worry about the callback, that&rsquo;s just to reset the animation when it is done, and also the <code>forceUpdate</code> re-renders so we get new random values on each subsequent trigger.</p>

<h2>Render A Heart</h2>

<p>```
<Surface width={deviceWidth} height={deviceHeight}></p>

<pre><code>&lt;AnimatedShape
  d={HEART_SVG}
  x={0}
  y={0}
  scale={1}
  fill={GRAY_HEART_COLOR}
/&gt;
</code></pre>

<p></Surface>
```</p>

<p>We just render a heart, pass in our SVG path, put it at the top left <code>0,0</code> coordinates. Scale is set to 1 and we fill it with our <code>GRAY_HEART_COLOR</code> we setup above.</p>

<h2>Talking Keyframes and Animations</h2>

<p>Before we dive in I want to explain what is about to happen. The original Twitter exploding has 28 frames. Our animation will start at <code>0</code>, and that is our default state. So we&rsquo;ll need to set everything up to default when we start <code>0</code> (initial render).</p>

<p>Then anytime from <code>1</code> to <code>28</code> we will need to design our values so that they produce the correct frame animation.</p>

<p><code>Animated</code> provides a way to interpolate. What that means is given a value, we want it to go through a formula and spit out another value. <code>Animated</code> does this via ranges, which can at times be a little inflexible and we have to hack around it&rsquo;s shortcomings to get desired effects.</p>

<p>All (well almost all) our animations will be interpolating from the single <code>this.state.animation</code> that we created earlier. This just makes it easy to comprehend and layout your animation frames. Because you can then specify that something happens at frame <code>10</code> instead of dividing <code>1/28</code> and say start at <code>0.03571428571</code>.</p>

<h2>Scale it up</h2>

<p>```
render: function() {</p>

<pre><code>var heart_scale = this.state.animation.interpolate({
  inputRange: [0, .01, 6, 10, 12, 18, 28],
  outputRange: [1, 0, .1, 1, 1.2, 1, 1],
  extrapolate: 'clamp'
});

var heart_fill = this.state.animation.interpolate({
  inputRange: [0, 2],
  outputRange: [GRAY_HEART_COLOR, HEART_COLOR],
  extrapolate: 'clamp'
})

var heart_x = heart_scale.interpolate({
  inputRange: [0, 1],
  outputRange: [90, 0],
})

var heart_y = heart_scale.interpolate({
  inputRange: [0, 1],
  outputRange: [75, 0],
})
</code></pre>

<p>}
```</p>

<p>Alright there is a lot going on. Lets break it down.</p>

<p>```</p>

<pre><code>var heart_scale = this.state.animation.interpolate({
  inputRange: [0, .01, 6, 10, 12, 18],
  outputRange: [1, 0, .1, 1, 1.2, 1],
  extrapolate: 'clamp'
});
</code></pre>

<p><code>``
We</code>interpolate<code>on the</code>this.state.animation<code>and give it an</code>inputRange<code>and</code>outputRange` array. These must have the same amount of array values.</p>

<p>I talked about some weird things with <code>Animated</code> and setting up defaults. Well <code>inputRange: [0, .01], outputRange: [1, 0]</code> is the first example.</p>

<p>At 0 we want it to be fully scaled, so output at 1. However as soon as the animation is triggered we want it to be at 0. If we only specified <code>0, 1</code> as the inputRange, it would have the heart scale down from 1 to 0. So specifying the scale inputRange at <code>0 =&gt; .01</code> means it&rsquo;ll basically disappear.</p>

<p>It&rsquo;s essentially a way to make an animation not a whole frame, and or happen virtually immediately.</p>

<p>There is a slight spring in the heart. So from frame <code>10</code> to <code>12</code> it will spring up fast to <code>1.2</code> scale, and then slowly fall back from <code>1.2</code> to <code>1</code> from frames <code>12</code> to <code>18</code>.</p>

<p><code>extrapolate: 'clamp'</code> IS EXTREMELY IMPORTANT HERE. If we want it to just stay the same once it hits frame 18 and not do anything else until the end we must add the clamp. Otherwise it will continue to animate at the current stepping value, so it would scale down below 1 and we don&rsquo;t want that.</p>

<p>```</p>

<pre><code>var heart_fill = this.state.animation.interpolate({
  inputRange: [0, 2],
  outputRange: [GRAY_HEART_COLOR, HEART_COLOR],
  extrapolate: 'clamp'
})
</code></pre>

<p><code>``
We have the heart hidden after frame</code>1<code>, so what this animation says is at</code>0` , inital render, be gray. Anytime from frame 2 and out be red, and always be read.</p>

<p>```</p>

<pre><code>var heart_x = heart_scale.interpolate({
  inputRange: [0, 1],
  outputRange: [90, 0],
})

var heart_y = heart_scale.interpolate({
  inputRange: [0, 1],
  outputRange: [75, 0],
})
</code></pre>

<p>```</p>

<p>This is the one part where we don&rsquo;t want to base things on the key frame. Because there is no <code>transform-origin</code> like there is in CSS, the default scale will scale out to the top left.
That isn&rsquo;t what we want.</p>

<p>So to scale out to the center we need to animate the x/y while scaling, so we interpolate off the interpolate for scale. Remember we default our scale up above to 1, so we are reversing stuff here saying when the scale is scaling down from 0 to 1 adjust to 90 for x and 75 for y.</p>

<p>The 90/75 just has to deal with the current surface center.</p>

<p>```</p>

<pre><code>return (
    &lt;Surface width={deviceWidth} height={deviceHeight}&gt;
        &lt;AnimatedShape
          d={HEART_SVG}
          x={heart_x}
          y={heart_y}
          scale={heart_scale}
          fill={heart_fill}
        /&gt;
    &lt;/Surface&gt;

)
</code></pre>

<p>```</p>

<p>We use our <code>AnimatedShape</code> and pass in the animated values we created. A lot of things I explain up above are the basic concepts through out this tutorial so I wont' explain them again.</p>

<h2>Add a Circle</h2>

<p>```
var AnimatedCircle = React.createClass({displayName: &ldquo;Circle&rdquo;,
  render: function() {</p>

<pre><code>var radius = this.props.radius;
var path = Path().moveTo(0, -radius)
    .arc(0, radius * 2, radius)
    .arc(0, radius * -2, radius)
    .close();
return React.createElement(AnimatedShape, React.__spread({},  this.props, {d: path}));
</code></pre>

<p>  }
});
```</p>

<p>This is taken from previous firework demos and default ReactART, but I&rsquo;ve converted it to use our <code>AnimatedShape</code> we created up above.</p>

<p>```
<Surface width={deviceWidth} height={deviceHeight}>
  <Group x={100} y={200}></p>

<pre><code>&lt;AnimatedShape
  d={HEART_SVG}
  x={heart_x}
  y={heart_y}
  scale={heart_scale}
  fill={heart_fill}
/&gt;
&lt;AnimatedCircle
  x={90}
  y={75}
  radius={150}
  scale={1}
  strokeWidth={3}
  fill="#000"
  opacity={1}
/&gt;
</code></pre>

<p>  </Group>
</Surface>
```</p>

<p>We render an arbitrary circle, at <code>90</code> and <code>75</code> which is the center of our current surface.</p>

<h2>Blow that Circle Up</h2>

<p>```</p>

<pre><code>var circle_scale = this.state.animation.interpolate({
  inputRange: [0, 1, 4],
  outputRange: [0, .3, 1],
  extrapolate: 'clamp'
});

var circle_stroke_width = this.state.animation.interpolate({
  inputRange: [0, 5.99, 6, 7, 10],
  outputRange: [0, 0, 15, 8, 0],
  extrapolate: 'clamp'
});

var circle_fill_colors = this.state.animation.interpolate({
  inputRange: [1, 2, 3, 4, 4.99, 5],
  outputRange: FILL_COLORS,
  extrapolate: 'clamp'
})

var circle_opacity = this.state.animation.interpolate({
  inputRange: [1,9.99, 10],
  outputRange: [1, 1, 0],
  extrapolate: 'clamp'
})
</code></pre>

<p>```</p>

<p>Alright so we scale up, based on the image we scale up to <code>.3</code> in a single frame, then over the course of 3 frames we scale up our circle to a scale of 1.</p>

<p>Our stroke width also changes however we won&rsquo;t always render it. We only need it for a few frames starting at frame 6. So we will specify that the stroke width stays at <code>0</code> from <code>0</code> to frame <code>5.99</code>.</p>

<p>Then over the course of 1 frame it goes to 15 which I chose at random, down to 8, and eventually 0 by frame 10.</p>

<p>We specify a range of colors in the array I talked about in setup. The weird part is that we have to specify the final color a few times before setting the fill to transparent. The reason is that if we specify just the transparent color the purple color will fade out to transparent but we want it to completely disappear and just show the stroke.</p>

<p>So we have to coordinate stroke frames appearing with the fill color disappearing.</p>

<p>Finally our opacity stays 1 until frame 9.99 (the end of our circle stroke) then we kill it on frame 10.</p>

<p>```</p>

<pre><code>&lt;AnimatedCircle
  x={89}
  y={75}
  radius={150}
  scale={circle_scale}
  strokeWidth={circle_stroke_width}
  stroke={FILL_COLORS[2]}
  fill={circle_fill_colors}
  opacity={circle_opacity}
/&gt;
</code></pre>

<p>```
We put those in and because our stroke color is always the same we just reference our fill colors.</p>

<h2>Bunch of Circles Blowing Up</h2>

<p>```
<Surface width={deviceWidth} height={deviceHeight}>
  <Group x={100} y={200}></p>

<pre><code>&lt;AnimatedShape
  d={HEART_SVG}
  x={heart_x}
  y={heart_y}
  scale={heart_scale}
  fill={heart_fill}
/&gt;
&lt;AnimatedCircle
  x={90}
  y={75}
  radius={150}
  scale={circle_scale}
  strokeWidth={circle_stroke_width}
  stroke={FILL_COLORS[2]}
  fill={circle_fill_colors}
  opacity={circle_opacity}
/&gt;

{this.getSmallExplosions(150, {x:90, y:75})}
</code></pre>

<p>  </Group>
</Surface>
```</p>

<p>Alright now we setup our final piece. Calling <code>getSmallExplosions</code> with some data. In our case the radius of our circle and the central coordinates.</p>

<p>```
  getSmallExplosions: function(radius, offset) {</p>

<pre><code>return [0,1,2,3,4,5,6].map((v, i, t) =&gt; {

  var scaleOut = this.state.animation.interpolate({
    inputRange: [0, 5.99, 6, 13.99, 14, 21],
    outputRange: [0, 0, 1, 1, 1, 0],
    extrapolate: 'clamp'
  });

  var moveUp = this.state.animation.interpolate({
    inputRange: [0, 5.99, 14],
    outputRange: [0, 0, -15],
    extrapolate: 'clamp'
  });

  var moveDown = this.state.animation.interpolate({
    inputRange: [0, 5.99, 14],
    outputRange: [0, 0, 15],
    extrapolate: 'clamp'
  });

  var color_top_particle = this.state.animation.interpolate({
    inputRange: [6, 8, 10, 12, 17, 21],
    outputRange: shuffleArray(PARTICLE_COLORS)
  })

  var color_bottom_particle = this.state.animation.interpolate({
    inputRange: [6, 8, 10, 12, 17, 21],
    outputRange: shuffleArray(PARTICLE_COLORS)
  })

  var position = getXYParticle(7, i, radius)

  return (
    &lt;Group 
      x={position.x + offset.x } 
      y={position.y + offset.y} 
      rotation={getRandomInt(0, 40) * i}
    &gt;
      &lt;AnimatedCircle 
        x={moveUp}
        y={moveUp}
        radius={15} 
        scale={scaleOut} 
        fill={color_top_particle} 
      /&gt;
      &lt;AnimatedCircle 
        x={moveDown}
        y={moveDown}
        radius={8} 
        scale={scaleOut} 
        fill={color_bottom_particle} 
      /&gt;
    &lt;/Group&gt;
  )
}, this)
</code></pre>

<p>  },
```</p>

<p>Not going to explain this one too indepth or I&rsquo;ll keep repeating myself. We create a bunch of animations for each particle but add some randomness into the mix. We call <code>shuffleArray</code> on our <code>PARTICLE_COLORS</code> so over the course of the frames it is active it&rsquo;ll animate to random colors for each particle.</p>

<p>Also we add a bit of <code>rotation</code> to the group, so when we animate the particles up/down they&rsquo;ll go in all different directions.</p>

<h2>Done</h2>

<p>Now you too can add a new interaction that all of your users will despise! No this isn&rsquo;t a perfect replica of the the Twiter animation because I added color variance and some random rotation to the small exploding/shrinking circles.</p>

<p><img class="<a" src="href="http://i.imgur.com/lMOxqIL.gif">http://i.imgur.com/lMOxqIL.gif</a>" title="That is hot" ></p>

<h3>Interactive Demo at <a href="https://rnplay.org/apps/nJjHdw">https://rnplay.org/apps/nJjHdw</a></h3>

<p>I&rsquo;m not posting the full code, this is a long one. Just check it out on RNPlay.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React-Native Animated with React-Art - Firework Tap To Shoot]]></title>
    <link href="http://browniefed.com/blog/2015/08/29/react-native-animated-with-react-art-firework-show/"/>
    <updated>2015-08-29T22:12:00-07:00</updated>
    <id>http://browniefed.com/blog/2015/08/29/react-native-animated-with-react-art-firework-show</id>
    <content type="html"><![CDATA[<h1>Introduction</h1>

<p>This actually could be built with out react-art, but we&rsquo;ll use react-art just for good measure.
What are we building? A firework show. Nothing fancy. Just tap on the screen and a firework will be shot to that point and explode.</p>

<h1>What?</h1>

<p>This is what we&rsquo;re building</p>

<p><img class="<a" src="href="http://i.imgur.com/Dj60a6e.gif">http://i.imgur.com/Dj60a6e.gif</a>" title="Firework Shooter" ></p>

<!-- more -->


<h1>Setup</h1>

<p>Just like normal, lets set the scene. A blank app with everything imported, etc.</p>

<p>```
var React = require(&lsquo;react-native&rsquo;);
var Dimensions = require(&lsquo;Dimensions&rsquo;);
var ReactNativeART = require(&lsquo;ReactNativeART&rsquo;);</p>

<p>var {
  width,
  height
} = Dimensions.get(&lsquo;window&rsquo;);</p>

<p>var {
  AppRegistry,
  StyleSheet,
  Animated,
  View,
  TouchableWithoutFeedback
} = React;</p>

<p>var {</p>

<pre><code>Surface,
Shape,
Path,
Group,
Transform
</code></pre>

<p>} = ReactNativeART;</p>

<p>var AnimatedShape = Animated.createAnimatedComponent(Shape);
var AnimatedGroup = Animated.createAnimatedComponent(Group);
```</p>

<p>We bring in the <code>Animated</code> API, <code>ReactNativeART</code>, some components from <code>ART</code>.
The thing that we have done before is creating <code>AnimatedShape</code>, and <code>AnimatedGroup</code>. What these do is allow us to set props like <code>fill</code>, <code>opacity</code>, <code>x</code>, <code>y</code>, that are Animated values. This will cause updates in our native world correctly and efficiently.</p>

<p>Now our styles</p>

<p>```
var styles = StyleSheet.create({
  container: {</p>

<pre><code>flex: 1,
flexDirection: 'column'
</code></pre>

<p>  }
});
<code>``
Yep that is it. Most of our stuff will take place in the</code>react-art` world.</p>

<p>Now our basic class</p>

<p>```
var FireworkShooter = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
  fireworks: []
};
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
    &lt;TouchableWithoutFeedback&gt;
      &lt;View&gt;
        &lt;Surface width={width} height={height}&gt;
        &lt;/Surface&gt;
      &lt;/View&gt;
    &lt;/TouchableWithoutFeedback&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
});
```</p>

<p>So we have a simple setup. A full container view, with a <code>TouchableWithoutFeedback</code> so we can get the press coordinates. Then a wrapping <code>View</code> since <code>Touchable</code> stuff needs a native view below it. Then finally our <code>react-art</code> <code>Surface</code>. This takes a <code>width</code> and <code>height</code> prop. In our case we want the full screen, so we get the dimensions of the phone that we extracted up above and set it.</p>

<h1>Shoot a mortar</h1>

<p>Lets think about this.
We want a mortar (a small glowing ball) to shoot from the bottom center of the screen to where we&rsquo;ve tapped.</p>

<p>That means with <code>react-art</code> we&rsquo;ll have to create a closed <code>Path</code> that is a circle. It just so happens that <code>react-art</code> ships with a <code>Circle</code> shape for us to use.</p>

<p>Okay so our list of needs</p>

<ul>
<li>A press handler to get where we tapped</li>
<li>A <code>Circle</code> that can take Animated API props</li>
<li>A way to animate that <code>Circle</code> aka mortar to the tap</li>
<li>Render a mortar on the <code>Surface</code></li>
</ul>


<p><code>
&lt;TouchableWithoutFeedback onPress={this._handleAddFirework}&gt;
</code>
We&rsquo;ll use the <code>TouchableWithoutFeedback</code> to call out to a function to queue up adding a firework.
Check that off the list.</p>

<p>```
//React-Art ships with this component however not react-native-art implementation we&rsquo;ll just grab it and
//modify this to use the AnimatedShape we create up above. Thanks Facebook :)</p>

<p>/<em>*
 * Copyright 2013-2014 Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Circle.art
 * @typechecks
 *
 * Example usage:
 * <Circle
 *   radius={10}
 *   stroke="green"
 *   strokeWidth={3}
 *   fill="blue"
 * />
 *
 </em>/
var AnimatedCircle = React.createClass({displayName: &ldquo;Circle&rdquo;,
  render: function() {</p>

<pre><code>var radius = this.props.radius;

var path = Path().moveTo(0, -radius)
    .arc(0, radius * 2, radius)
    .arc(0, radius * -2, radius)
    .close();
return React.createElement(AnimatedShape, React.__spread({},  this.props, {d: path}));
</code></pre>

<p>  }
});
```</p>

<p>Hey look we just grabbed it and changed <code>Shape</code> to <code>AnimatedShape</code>. Yaye for React and reusable code.</p>

<p>```
var MORTAR_RADIUS = 5;
///&hellip;
_handleAddFirework: function(e) {</p>

<pre><code>var _shootingPosition = new Animated.ValueXY({x: width/2, y: height - MORTAR_RADIUS});

this.state.fireworks.push({
  shootingPosition: _shootingPosition,
});

Animated.timing(_shootingPosition, {
    duration: 300,
    toValue: {
      y: e.nativeEvent.locationY,
      x: e.nativeEvent.locationX
    }
}).start()

this.setState(this.state);
</code></pre>

<p>}
```
Alright. Pause and lets analyze this code.</p>

<p>First line <code>_shootingPosition</code>, we create a new <code>Animated.ValueXY</code> and set our defaults. These defaults are the starting position of the animation. Usually these would default to <code>x: 0, y:0</code> but we have other plans.</p>

<p>We set our <code>x</code> to <code>width/2</code> which is the middle of the phone. Then our <code>y</code> is going to the <code>height</code> of the device minus a <code>MORTAR_RADIUS</code>. We put a constant at the top of the code to say our mortar radius is going to be 5.</p>

<p>Next we add it to an array of fireworks we&rsquo;ll shoot later.</p>

<p>Then we create the animation.
We want the mortar to take <code>300</code> milliseconds to reach the spot the user pressed. We set the <code>toValue</code> to where our users pressed.
Then we start the animation. Yeah we haven&rsquo;t even rendered anything yet but it&rsquo;ll all be okay trust me.</p>

<p>Finally we set our state and thus it&rsquo;ll cause a re-render and we can render our firework.</p>

<p>```
<Surface width={width} height={height}>
{</p>

<pre><code>this.state.fireworks.map((firework) =&gt; {
    return &lt;AnimatedCircle 
                radius={MORTAR_RADIUS} 
                x={firework.shootingPosition.x} 
                y={firework.shootingPosition.y}
                fill="#000"
            /&gt;
})
</code></pre>

<p>}
</Surface>
<code>``
So we map over each firework, return the</code>AnimatedCircle<code>and set the appropriate properties, which 2 of those</code>x<code>, and</code>y` are animated properties. In our case we&rsquo;re going to fill the cirlcle with black to start.</p>

<p>So what does that all look like? Something like this</p>

<p><img class="<a" src="href="http://i.imgur.com/arIjyoz.gif">http://i.imgur.com/arIjyoz.gif</a>" title="Black Shooting Circles" ></p>

<h1>Shoot multiple mortars that disappear</h1>

<p>Well mortars don&rsquo;t stick like that. So lets make them disappear.
The <code>start()</code> function takes a callback that is called when the animation completes.</p>

<p>To identify the firework in the array we&rsquo;ll just use the <code>shootingPosition</code> animation to identify it and filter it out.</p>

<p>Something like this.</p>

<p>```
  removeSelf: function(_shootingPosition) {</p>

<pre><code>this.state.fireworks = this.state.fireworks.filter((firework) =&gt; firework.shootingPosition !== _shootingPosition);
this.setState(this.state);
</code></pre>

<p>  },</p>

<p>  ///</p>

<pre><code>Animated.timing(_shootingPosition, {
    duration: 300,
    toValue: {
      y: e.nativeEvent.locationY,
      x: e.nativeEvent.locationX
    }
]).start(this.removeSelf.bind(this, _shootingPosition));
</code></pre>

<p>```</p>

<p>Not the most elegant of solutions but hey it works. It runs through each firework, removes our _shootingPosition, and then refreshes the UI.</p>

<h1>Animate the color</h1>

<p>Lets make the mortar more than just a black dot. Lets pretend it&rsquo;s a fire ball, and we want it to alternate between yellow and orange.</p>

<p>We&rsquo;ll use these 2 colors and pop them at the top</p>

<p><code>
var SHOOTING_COLORS = [
  'rgb(234,238,112)', //Yellow
  'rgb(245,137,12)' //Orange
];
</code></p>

<p>The <code>interpolate</code> function we&rsquo;re going to call only works with <code>rgb</code> hence the use of <code>rgb</code> instead of hex.</p>

<p>Next we&rsquo;ll need to create another Animated value.</p>

<p>Our code will look like so</p>

<p>```</p>

<pre><code>var _shootingPosition = new Animated.ValueXY({x: width/2, y: height - MORTAR_RADIUS});
var _shootingColor = new Animated.Value(0);

this.state.fireworks.push({
  shootingPosition: _shootingPosition,
  shootingColor: _shootingColor,
});

//

_shootingPosition.addListener(this.adjustShootingFill.bind(null, _shootingColor));

adjustShootingFill: function(_shootingColor, value) {
    Animated.timing(_shootingColor, {
      duration: 16,
      toValue: _shootingColor.__getAnimatedValue() == 0 ? 1 : 0
    }).start()
},
</code></pre>

<p><code>``
We start off by adding a new</code>Animated.Value`, and set it to 0. We add it to our firework object.</p>

<p>Then we add a listener to it. What <code>addListener</code> does is provides a callback that will be called each time the mortar position is updated.
The bind is just so it&rsquo;ll pass in our <code>_shootingColor</code> Animated value as the first argument.</p>

<p>We&rsquo;ll use the <code>Animated.timing</code> function again to transition it between colors over 16ms. We call <code>__getAnimatedValue()</code> and do the inverse of it.</p>

<p>So every <code>16ms</code> the mortar will transition from yellow => orange => yellow => orange, etc.</p>

<p>Now what does that look like in our render?</p>

<p>```
<Surface width={width} height={height}>
{</p>

<pre><code>this.state.fireworks.map((firework) =&gt; {

    var _shootingFill = firework.shootingColor.interpolate({
      inputRange: [0,1],
      outputRange: SHOOTING_COLORS
    });


    return &lt;AnimatedCircle 
                radius={MORTAR_RADIUS} 
                x={firework.shootingPosition.x} 
                y={firework.shootingPosition.y}
                fill={_shootingFill}
            /&gt;
})
</code></pre>

<p>}
</Surface>
<code>``
We need to create an interpolator. This interpolate will encapsulate the logic that picks the color when we change the value of</code>shootingColor<code>up above in our</code>adjustShootingFill` function.</p>

<p>It maps to</p>

<p><code>
0 =&gt; yellow
1 =&gt; orange
</code>
Then we pass that into our fill property and we&rsquo;re done.</p>

<p><img class="<a" src="href="http://i.imgur.com/r69Ba6r.gif">http://i.imgur.com/r69Ba6r.gif</a>" title="Orange Yellow Moratrs" ></p>

<h1>Make those mortars explode</h1>

<p>Now for the fun part. Lets make our mortars explode.</p>

<p>Our mortar concept will be pretty simplistic, we&rsquo;ll create 20 circles that explode outwards and expand.
We could create all sorts of tails that fly around and do cool things but that is a tutorial for another time.</p>

<p>First lets setup some variables</p>

<p>```
var PARTICLE_RADIUS = 30; // How big should the explosions be
var PARTICLE_COUNT = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]; // How many particles per explosion, this is the lazy persons range call</p>

<p>var PARTICLE_COLORS = [</p>

<pre><code>'rgba(54, 17, 52, 100)',
'rgba(176, 34, 140, 100)',
'rgba(234, 55, 136, 100)',
'rgba(229, 107, 112, 100)',
'rgba(243, 145, 160, 100)'
</code></pre>

<p>]
```</p>

<p>We the <code>PARTICLE_RADIUS</code> which will determine how large each explosion is. We setup <code>PARTICLE_COUNT</code> which is the amount of particles we&rsquo;ll use.
Finally we want our firework show to be 5 different colors. So each explosion will change between each of these colors.</p>

<p>For the sake of simplicity we&rsquo;ll make each particle the same exact color meaning we only need 1 <code>Animated.Value</code> for it.</p>

<p>```</p>

<pre><code>var _particleColor = new Animated.Value(0);
var _particleRadius = new Animated.Value(0);
var _coreOpacity = new Animated.Value(1);
</code></pre>

<p><code>``
We also need an</code>Animated.Value<code>for our radius, we put it at 0 so it starts hidden. The other</code>Animated.Value` is our core opacity animation.
That is the value for hiding our core mortar once it explodes.</p>

<p>```</p>

<pre><code>var _particlePositions = PARTICLE_COUNT.map(() =&gt; new Animated.ValueXY({x: 0, y: 0}));
</code></pre>

<p><code>``
Each particle will have to go to a different position so in this case we'll need 20</code>Animated.ValueXY`.</p>

<p>```
this.state.fireworks.push({</p>

<pre><code>  shootingPosition: _shootingPosition,
  shootingColor: _shootingColor,
  particleColor: _particleColor,
  particleRadius: _particleRadius,
  coreOpacity: _coreOpacity,
  particlePositions: _particlePositions
});
</code></pre>

<p>```</p>

<p>Add them to our firework so we can access them later in our render.</p>

<p>```</p>

<pre><code>var _animatedParticles = [
    Animated.timing(_particleRadius, {
      duration: 700,
      toValue: 1
    }),
    Animated.timing(_coreOpacity, {
      duration: 200,
      toValue: 0
    })
]

_movingParticles = _particlePositions.map((particle, i) =&gt; {
  var _xy = getXYParticle(PARTICLE_COUNT.length, i, PARTICLE_RADIUS);
  return Animated.timing(particle, {
    duration: 250,
    toValue: _xy
  })
})

//At the bottom of the file
function getXYParticle(total, i, radius) {
  var angle = 360/total*i;

  var x = Math.round((radius*2) * Math.cos(angle - (Math.PI/2)));
  var y = Math.round((radius*2) * Math.sin(angle - (Math.PI/2)));

  return {
    x: x,
    y: y
  }
}

_animatedParticles = _animatedParticles.concat(_movingParticles);
</code></pre>

<p>```</p>

<p>This whole animation mapping is setting us up for what we are going to do next. Which is queue up our animations.</p>

<p>We create an array of animations that need to happen. The first is expanding each <code>_particleRadius</code>. We have determine that it will take 700 milliseconds to fully expand the explosion. The <code>_particleRadius</code> will actually be the particle scale. We&rsquo;ll just scale up the circle so it looks like it&rsquo;s exploding outwards, but that will be shown off in our render function.</p>

<p>We set our <code>_coreOpacity</code> aka our mortar ball to fade out and disappear over 200 milliseconds.</p>

<p>We need to create the animations for each particle. It needs to shoot out from our current mortar location to different points on the circle.
After googling around I found a function below, and deleted a bunch of stuff to basically get down to a rough position algorithim to return <code>x,y</code> positions.</p>

<p>We once again use <code>Animated.timing</code> to say that the particle should take 250 milliseconds to get into it&rsquo;s position.</p>

<p>```</p>

<pre><code>Animated.sequence([
  Animated.timing(_shootingPosition, {
    duration: 300,
    toValue: {
      y: e.nativeEvent.locationY,
      x: e.nativeEvent.locationX
    }
  }),
  Animated.parallel(_animatedParticles)
]).start(this.removeSelf.bind(this, _shootingPosition));
</code></pre>

<p>```</p>

<p>Now to queue up our animations. We want our mortar shooting to happen first, then the explosion.
We do that using <code>Animated.sequence</code>.</p>

<p>We first have our mortar go up to the location of the users touch.
The next piece is wrapping all of our explosion animations in an <code>Animated.parallel</code>. This is the opposite of sequence, which it says execute all of these animations at the same time.</p>

<p>So our mortar fading out and disappearing, our particles expanding, changing color, and exploding outward will all happen at the same time.</p>

<p>```</p>

<pre><code>_shootingPosition.addListener(this.adjustShootingFill.bind(null, _shootingColor));
_particleRadius.addListener(this.adjustParticleFill.bind(null, _particleColor));

///
  adjustParticleFill: function(_particleColor, value) {
    var _currentFill = _particleColor.__getAnimatedValue(),
        _particleFill = _currentFill === 5 ? 0 : _currentFill + 1;

    Animated.timing(_particleColor, {
      duration: 16,
      toValue: _particleFill
    }).start()
  },
</code></pre>

<p>```</p>

<p>Finally we need to change our color of our particle. So like before we&rsquo;ll attach to the expanding of our particle and make it call a function to change the fill color.
In our new case we have five colors to choose from so the logic is a little different but mostly the same.</p>

<p>Now for our rendering of this all. We&rsquo;ll move it out to a different function to deal with.</p>

<p>```
  <Surface width={width} height={height}></p>

<pre><code>{this.getFireworks()}
</code></pre>

<p>  </Surface>
```</p>

<p>```
getFireworks: function() {</p>

<pre><code>return this.state.fireworks.map((firework, i) =&gt; {

  var _shootingFill = firework.shootingColor.interpolate({
    inputRange: [0,1],
    outputRange: SHOOTING_COLORS
  });

  var _particleFill = firework.particleColor.interpolate({
    inputRange: [0,1,2,3,4],
    outputRange: PARTICLE_COLORS
  });

  return (
      &lt;AnimatedGroup 
        x={firework.shootingPosition.x}
        y={firework.shootingPosition.y}
      &gt;
            &lt;AnimatedCircle
              opacity={firework.coreOpacity}
              radius={MORTAR_RADIUS}
              fill={_shootingFill}
            /&gt;
            &lt;Group&gt;
            {
              PARTICLE_COUNT.map((v, j) =&gt; {
                return &lt;AnimatedCircle
                  x={firework.particlePositions[j].x}
                  y={firework.particlePositions[j].y}
                  scaleX={firework.particleRadius}
                  scaleY={firework.particleRadius}
                  radius={PARTICLE_RADIUS}
                  fill={_particleFill}
                /&gt;
              })
            }
            &lt;/Group&gt;
      &lt;/AnimatedGroup&gt;
  );
})
</code></pre>

<p>  },
<code>``
There is a lot going on here. We have our same</code><em>shootingFill<code>like we did before, that causes the yellow =&gt; orange interpolation.
We add another interpolation for the particleFill. Same concept as the</code></em>shootingFill` just with 5 colors now.</p>

<p>What is much different here is the <code>AnimatedGroup</code>. We have moved our <code>x,y</code> from the <code>AnimatedCircle</code> to the <code>AnimatedGroup</code>.</p>

<p>This will bundle our mortar, and our particles all in the same coordinate area. That way we can have our particles start at <code>0,0</code> and move outwards and the <code>AnimatedGroup</code> will make sure all the coordinates are handled correctly.</p>

<p><code>
&lt;AnimatedCircle
  opacity={firework.coreOpacity}
  radius={MORTAR_RADIUS}
  fill={_shootingFill}
/&gt;
</code>
You can see here we put out <code>coreOpacity</code> animation in there. So it&rsquo;ll fade from <code>1</code> opacity down to <code>0</code> over that 200 milliseconds we setup.</p>

<p>```
  <Group></p>

<pre><code>{
  PARTICLE_COUNT.map((v, j) =&gt; {
    return &lt;AnimatedCircle
      x={firework.particlePositions[j].x}
      y={firework.particlePositions[j].y}
      scaleX={firework.particleRadius}
      scaleY={firework.particleRadius}
      radius={PARTICLE_RADIUS}
      fill={_particleFill}
    /&gt;
  })
}
</code></pre>

<p>  </Group>
<code>``
We group the Particles with a</code>Group` component but that&rsquo;s just arbitrary.</p>

<p>We map over our 20 particles, and set the <code>x</code> and <code>y</code> to the points we had determined with our <code>getXYParticle</code> function.</p>

<p>You&rsquo;ll notice we are passing in <code>particleRadius</code> to the <code>scaleX</code> and <code>scaleY</code> properties.
This is because while writing this I realized that the <code>AnimatedCircle</code> takes the radius property and creates a path out of it. That is not animateable in this particular way, so the solution I came up was to scale each particle to 0. Basically making it completely hidden.</p>

<p>That then allows us to expand it out to it&rsquo;s full scale and make it look like an explosion. It actually works better.</p>

<p>Finally we add in our <code>PARTICLE_RADIUS</code> we defined at the top, aka size of each explosion, and put in our <code>_particleFill</code> which is the color interpolation between those 5 colors.</p>

<h1>Play with it</h1>

<p>That is all! We have a firework shooter!</p>

<p>Check it out on RNPlay as per usual <a href="https://rnplay.org/apps/ysm12A">https://rnplay.org/apps/ysm12A</a>.</p>

<p>Tap to your hearts content and watch all the explosive animation goodness appear on screen.</p>

<p><img class="<a" src="href="http://i.imgur.com/Dj60a6e.gif">http://i.imgur.com/Dj60a6e.gif</a>" title="Firework Shooter" ></p>

<h1>Final Code</h1>

<p>```
var React = require(&lsquo;react-native&rsquo;);
var Dimensions = require(&lsquo;Dimensions&rsquo;);
var ReactNativeART = require(&lsquo;ReactNativeART&rsquo;);</p>

<p>var {
  width,
  height
} = Dimensions.get(&lsquo;window&rsquo;);</p>

<p>var MORTAR_RADIUS = 5;
var PARTICLE_RADIUS = 30;
var PARTICLE_COUNT = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20];</p>

<p>var {
  AppRegistry,
  StyleSheet,
  Animated,
  View,
  TouchableWithoutFeedback
} = React;</p>

<p>var {</p>

<pre><code>Surface,
Shape,
Path,
Group,
Transform
</code></pre>

<p>} = ReactNativeART;</p>

<p>var SHOOTING_COLORS = [
  &lsquo;rgb(234,238,112)&rsquo;,
  &lsquo;rgb(245,137,12)&rsquo;
];</p>

<p>var PARTICLE_COLORS = [</p>

<pre><code>'rgba(54, 17, 52, 100)',
'rgba(176, 34, 140, 100)',
'rgba(234, 55, 136, 100)',
'rgba(229, 107, 112, 100)',
'rgba(243, 145, 160, 100)'
</code></pre>

<p>]</p>

<p>var AnimatedShape = Animated.createAnimatedComponent(Shape);
var AnimatedGroup = Animated.createAnimatedComponent(Group);</p>

<p>var FireworkShooter = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
  fireworks: []
};
</code></pre>

<p>  },
  adjustShootingFill: function(_shootingColor, value) {</p>

<pre><code>Animated.timing(_shootingColor, {
  duration: 16,
  toValue: _shootingColor.__getAnimatedValue() == 0 ? 1 : 0
}).start()
</code></pre>

<p>  },
  adjustParticleFill: function(_particleColor, value) {</p>

<pre><code>var _currentFill = _particleColor.__getAnimatedValue(),
    _particleFill = _currentFill === 5 ? 0 : _currentFill + 1;

Animated.timing(_particleColor, {
  duration: 16,
  toValue: _particleFill
}).start()
</code></pre>

<p>  },
  removeSelf: function(_shootingPosition) {</p>

<pre><code>this.state.fireworks = this.state.fireworks.filter((firework) =&gt; firework.shootingPosition !== _shootingPosition);
this.setState(this.state);
</code></pre>

<p>  },
  _handleAddFirework: function(e) {</p>

<pre><code>var _shootingPosition = new Animated.ValueXY({x: width/2, y: height - MORTAR_RADIUS});
var _shootingColor = new Animated.Value(0);

var _particleColor = new Animated.Value(0);
var _particleRadius = new Animated.Value(0);
var _coreOpacity = new Animated.Value(1);

var _particlePositions = PARTICLE_COUNT.map(() =&gt; new Animated.ValueXY({x: 0, y: 0}));

this.state.fireworks.push({
  shootingPosition: _shootingPosition,
  shootingColor: _shootingColor,
  particleColor: _particleColor,
  particleRadius: _particleRadius,
  coreOpacity: _coreOpacity,
  particlePositions: _particlePositions
});

var _animatedParticles = [
    Animated.timing(_particleRadius, {
      duration: 700,
      toValue: 1
    }),
    Animated.timing(_coreOpacity, {
      duration: 200,
      toValue: 0
    })
]

_movingParticles = _particlePositions.map((particle, i) =&gt; {
  var _xy = getXYParticle(PARTICLE_COUNT.length, i, PARTICLE_RADIUS);
  return Animated.timing(particle, {
    duration: 250,
    toValue: _xy
  })
})

_animatedParticles = _animatedParticles.concat(_movingParticles);

Animated.sequence([
  Animated.timing(_shootingPosition, {
    duration: 300,
    toValue: {
      y: e.nativeEvent.locationY,
      x: e.nativeEvent.locationX
    }
  }),
  Animated.parallel(_animatedParticles)
]).start(this.removeSelf.bind(this, _shootingPosition));

_shootingPosition.addListener(this.adjustShootingFill.bind(null, _shootingColor));
_particleRadius.addListener(this.adjustParticleFill.bind(null, _particleColor));

this.setState(this.state);
</code></pre>

<p>  },</p>

<p>  getFireworks: function() {</p>

<pre><code>return this.state.fireworks.map((firework, i) =&gt; {

  var _shootingFill = firework.shootingColor.interpolate({
    inputRange: [0,1],
    outputRange: SHOOTING_COLORS
  });

  var _particleFill = firework.particleColor.interpolate({
    inputRange: [0,1,2,3,4],
    outputRange: PARTICLE_COLORS
  });

  return (
      &lt;AnimatedGroup 
        x={firework.shootingPosition.x}
        y={firework.shootingPosition.y}
      &gt;
            &lt;AnimatedCircle
              key={i}
              opacity={firework.coreOpacity}
              radius={MORTAR_RADIUS}
              fill={_shootingFill}
            /&gt;
            &lt;Group&gt;
            {
              PARTICLE_COUNT.map((v, j) =&gt; {
                return &lt;AnimatedCircle
                  x={firework.particlePositions[j].x}
                  y={firework.particlePositions[j].y}
                  scaleX={firework.particleRadius}
                  scaleY={firework.particleRadius}
                  radius={PARTICLE_RADIUS}
                  fill={_particleFill}
                /&gt;
              })
            }
            &lt;/Group&gt;
      &lt;/AnimatedGroup&gt;
  );
})
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
    &lt;TouchableWithoutFeedback onPress={this._handleAddFirework}&gt;
      &lt;View&gt;
        &lt;Surface width={width} height={height}&gt;
          {this.getFireworks()}
        &lt;/Surface&gt;
      &lt;/View&gt;
    &lt;/TouchableWithoutFeedback&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
});</p>

<p>var styles = StyleSheet.create({
  container: {</p>

<pre><code>flex: 1,
flexDirection: 'column'
</code></pre>

<p>  }
});</p>

<p>function getXYParticle(total, i, radius) {
  var angle = 360/total*i;</p>

<p>  var x = Math.round((radius<em>2) * Math.cos(angle &ndash; (Math.PI/2)));
  var y = Math.round((radius</em>2) * Math.sin(angle &ndash; (Math.PI/2)));</p>

<p>  return {</p>

<pre><code>x: x,
y: y
</code></pre>

<p>  }
}</p>

<p>//Modified this to use the AnimatedShape we create up above. Thanks Facebook :)</p>

<p>/<em>*
 * Copyright 2013-2014 Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Circle.art
 * @typechecks
 *
 * Example usage:
 * <Circle
 *   radius={10}
 *   stroke="green"
 *   strokeWidth={3}
 *   fill="blue"
 * />
 *
 </em>/
var AnimatedCircle = React.createClass({displayName: &ldquo;Circle&rdquo;,
  render: function() {</p>

<pre><code>var radius = this.props.radius;

var path = Path().moveTo(0, -radius)
    .arc(0, radius * 2, radius)
    .arc(0, radius * -2, radius)
    .close();
return React.createElement(AnimatedShape, React.__spread({},  this.props, {d: path}));
</code></pre>

<p>  }
});</p>

<p>AppRegistry.registerComponent(&lsquo;FireworkShooter&rsquo;, () => FireworkShooter);
```</p>
]]></content>
  </entry>
  
</feed>
