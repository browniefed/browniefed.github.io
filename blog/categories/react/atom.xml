<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: react | JavaScript Without Grammar]]></title>
  <link href="http://browniefed.com/blog/categories/react/atom.xml" rel="self"/>
  <link href="http://browniefed.com/"/>
  <updated>2015-07-28T15:42:51-07:00</updated>
  <id>http://browniefed.com/</id>
  <author>
    <name><![CDATA[Jason Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[React-native Animated API Basic Example]]></title>
    <link href="http://browniefed.com/blog/2015/07/26/react-native-animated-api-basic-example/"/>
    <updated>2015-07-26T11:51:00-07:00</updated>
    <id>http://browniefed.com/blog/2015/07/26/react-native-animated-api-basic-example</id>
    <content type="html"><![CDATA[<h1>Introduction</h1>

<p>Animations are finally solved in React? That&rsquo;s a bold claim, but lets explore the new Animated API in <code>react-native</code>. This won&rsquo;t apply to React for the web, however there is also <a href="https://github.com/chenglou/react-motion">react-motion</a> also released at <code>react-europe</code>.</p>

<p><img class="<a" src="href="http://i.imgur.com/JlX4nV0.gif">http://i.imgur.com/JlX4nV0.gif</a>" title="Final Animation Result" ></p>

<h1>Resources</h1>

<ul>
<li><a href="https://www.youtube.com/watch?v=1tavDv5hXpo">Cheng Lou &ndash; The State of Animation in React at react-europe 2015</a></li>
<li><a href="https://github.com/chenglou/react-motion">react-motion &ndash; Github</a></li>
<li><a href="https://facebook.github.io/react-native/docs/animations.html#content">React Native Animation API</a></li>
<li><a href="https://www.youtube.com/watch?v=xDlfrcM6YBk">Spencer Ahrens &ndash; React Native: Building Fluid User Experiences at react-europe 2015</a></li>
</ul>


<h1>How It Works</h1>

<p>The Animated API does not depend on calling <code>setState</code>, it is accomplished by calling <code>setNativeProps</code>. The Animated API exports a few components <code>Animated.View</code>, <code>Animated.Text</code>, and <code>Animated.Image</code>. The Animated API will adjust the components in the native Objective-C world. This will bypass the diff and reconciliation in the JS world so you get fluent, and performance animatons. Ultimately all you need to know is that it will interpolate numbers and update the native view components.</p>

<h1>Cool Examples</h1>

<ul>
<li><a href="https://github.com/brentvatne/react-native-animated-demo-tinder">https://github.com/brentvatne/react-native-animated-demo-tinder</a></li>
<li><a href="https://github.com/facebook/react-native/tree/master/Examples/UIExplorer/AnimationExample">UIExplorer Animated example</a></li>
</ul>


<h1>Simple Move Around the Screen Example</h1>

<p>We are just going to move a square around the edges of the screen.</p>

<p><code>
&lt;--&lt;           
|  |          
V--^         
</code></p>

<h1>Setup</h1>

<p>Dependencies</p>

<p>```
var React = require(&lsquo;react-native&rsquo;);
var Dimensions = require(&lsquo;Dimensions&rsquo;);</p>

<p>var {
  width,
  height
} = Dimensions.get(&lsquo;window&rsquo;);</p>

<p>var {
  AppRegistry,
  StyleSheet,
  View,
  Animated
} = React;</p>

<p>var SQUARE_DIMENSIONS = 30;</p>

<p>```</p>

<p>Styles</p>

<p>```
var styles = StyleSheet.create({
  container: {</p>

<pre><code>flex: 1
</code></pre>

<p>  },
  square: {</p>

<pre><code>width: SQUARE_DIMENSIONS,
height: SQUARE_DIMENSIONS,
backgroundColor: 'blue'
</code></pre>

<p>  }
});
```</p>

<p>Basic Code</p>

<p>```</p>

<p>var AnimatedSquare = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
    pan: new Animated.ValueXY()
};
</code></pre>

<p>  },
  getStyle: function() {</p>

<pre><code>return [
          styles.square, 
          {
            transform: this.state.pan.getTranslateTransform()
          }
        ];
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
    &lt;Animated.View style={this.getStyle()} /&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
});
```</p>

<p>Few things to call out here.</p>

<p>Notice our state that is created is an instantiation of <code>Animated.ValueXY</code>. This will save us some code, and let the <code>Animated</code> API take care of interpolating both our X, and Y values.</p>

<p>Our <code>getStyle</code> will return an array, our base <code>square</code> class and a <code>transform</code>. Once again we&rsquo;ll use a the <code>getTranslateTransform</code> helper from the <code>Animated</code> API to return the appropriate structure for the transform style.</p>

<p>It returns <code>[{ translateX: xValue}, {translateY: yValue}]</code>, where <code>xValue</code> and <code>yValue</code> are the interpolated values from the <code>Animated.ValueXY</code> we set on our <code>pan</code> state variable.</p>

<p>Finally we will use the <code>Animated.View</code> which is a convenience element to say &ldquo;Hey React this is going to be an animated thing&rdquo;.</p>

<h1>Move It</h1>

<p>We&rsquo;re now going to move it from the top corner. <code>x = 0, y = 0</code> to the bottom left corner <code>x = 0, y = (phoneHeight - square Height)</code>.</p>

<p>```
var SPRING_CONFIG = {tension: 2, friction: 3}; //Soft spring</p>

<p>//&hellip;
  componentDidMount: function() {</p>

<pre><code>Animated.spring(this.state.pan, {
      ...SPRING_CONFIG,
      toValue: {x: 0, y: height - SQUARE_DIMENSIONS}                        // return to start
}).start();
</code></pre>

<p>  },
```</p>

<p>So on mount we&rsquo;ll start a spring. This will animate the <code>this.state.pan</code> to the bottom left corner like we want it to.</p>

<p>We&rsquo;ll also setup the <code>SPRING_CONFIG</code> with a soft spring, not much tension or friction. So it&rsquo;ll get to the corner and just bounce a little bit and stay there.</p>

<h1>Move It, Move It, and Move It again</h1>

<p>We can queue up sequences of animations. These will happen one after the other.
The <code>sequence</code> call is one of the means of composing animations. There is also <code>parallel</code> which allows for declaration of animations to happen at the same time.</p>

<p>```
  componentDidMount: function() {</p>

<pre><code>Animated.sequence([
  Animated.spring(this.state.pan, {
        ...SPRING_CONFIG,
        toValue: {x: 0, y: height - SQUARE_DIMENSIONS} //animate to bottom left
  }),
  Animated.spring(this.state.pan, {
      ...SPRING_CONFIG,
      toValue: {x: width - SQUARE_DIMENSIONS, y: height - SQUARE_DIMENSIONS} // animated to bottom right
  }),
  Animated.spring(this.state.pan, {
        ...SPRING_CONFIG,
        toValue: {x: width - SQUARE_DIMENSIONS, y: 0} //animate to top right
  }),
  Animated.spring(this.state.pan, {
      ...SPRING_CONFIG,
      toValue: {x: 0, y: 0} // return to start
  })
]).start();
</code></pre>

<p>  }
```</p>

<p>We define 4 spring configrations like discussed before. The comments in the code explain each movement.</p>

<h1>Move and Repeat</h1>

<p>The call to <code>start</code> takes a callback. This callback will be invoked once the animation is completed. In our case the animation is complete once we get back to the start. We can then restart the animation.</p>

<p>```
  componentDidMount: function() {</p>

<pre><code>this.startAndRepeat();
</code></pre>

<p>  },
  startAndRepeat: function() {</p>

<pre><code>this.triggerAnimation(this.startAndRepeat);
</code></pre>

<p>  },
  triggerAnimation: function(cb) {</p>

<pre><code>Animated.sequence([
  Animated.spring(this.state.pan, {
        ...SPRING_CONFIG,
        toValue: {x: 0, y: height - SQUARE_DIMENSIONS} //animate to bottom left
  }),
  Animated.spring(this.state.pan, {
      ...SPRING_CONFIG,
      toValue: {x: width - SQUARE_DIMENSIONS, y: height - SQUARE_DIMENSIONS} // animated to bottom right
  }),
  Animated.spring(this.state.pan, {
        ...SPRING_CONFIG,
        toValue: {x: width - SQUARE_DIMENSIONS, y: 0} //animate to top right
  }),
  Animated.spring(this.state.pan, {
      ...SPRING_CONFIG,
      toValue: {x: 0, y: 0} // return to start
  })
]).start(cb);
</code></pre>

<p>  }
```</p>

<p>We just make a call that triggers the animation and calls itself on complete.</p>

<h1>Full/Live Code</h1>

<h2><a href="https://rnplay.org/apps/QlPJ2Q">https://rnplay.org/apps/QlPJ2Q</a></h2>

<p>```
var React = require(&lsquo;react-native&rsquo;);
var Dimensions = require(&lsquo;Dimensions&rsquo;);</p>

<p>var {
  width,
  height
} = Dimensions.get(&lsquo;window&rsquo;);</p>

<p>var {
  AppRegistry,
  StyleSheet,
  View,
  Animated
} = React;</p>

<p>var SQUARE_DIMENSIONS = 30;
var SPRING_CONFIG = {tension: 2, friction: 3}; //Soft spring</p>

<p>var AnimatedSquare = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
    pan: new Animated.ValueXY()
};
</code></pre>

<p>  },
  componentDidMount: function() {</p>

<pre><code>this.startAndRepeat();
</code></pre>

<p>  },
  startAndRepeat: function() {</p>

<pre><code>this.triggerAnimation(this.startAndRepeat);
</code></pre>

<p>  },
  triggerAnimation: function(cb) {</p>

<pre><code>Animated.sequence([
  Animated.spring(this.state.pan, {
        ...SPRING_CONFIG,
        toValue: {x: 0, y: height - SQUARE_DIMENSIONS} //animate to bottom left
  }),
  Animated.spring(this.state.pan, {
      ...SPRING_CONFIG,
      toValue: {x: width - SQUARE_DIMENSIONS, y: height - SQUARE_DIMENSIONS} // animated to bottom right
  }),
  Animated.spring(this.state.pan, {
        ...SPRING_CONFIG,
        toValue: {x: width - SQUARE_DIMENSIONS, y: 0} //animate to top right
  }),
  Animated.spring(this.state.pan, {
      ...SPRING_CONFIG,
      toValue: {x: 0, y: 0} // return to start
  })
]).start(cb);
</code></pre>

<p>  },
  getStyle: function() {</p>

<pre><code>return [
          styles.square, 
          {
            transform: this.state.pan.getTranslateTransform()
          }
        ];
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
    &lt;Animated.View style={this.getStyle()} /&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
});</p>

<p>var styles = StyleSheet.create({
  container: {</p>

<pre><code>flex: 1
</code></pre>

<p>  },
  square: {</p>

<pre><code>width: SQUARE_DIMENSIONS,
height: SQUARE_DIMENSIONS,
backgroundColor: 'blue'
</code></pre>

<p>  }
});</p>

<p>AppRegistry.registerComponent(&lsquo;AnimatedSquare&rsquo;, () => AnimatedSquare);</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React-Native Tinder like cards]]></title>
    <link href="http://browniefed.com/blog/2015/06/06/react-native-tinder-like-cards/"/>
    <updated>2015-06-06T19:33:00-07:00</updated>
    <id>http://browniefed.com/blog/2015/06/06/react-native-tinder-like-cards</id>
    <content type="html"><![CDATA[<h1>CHECK OUT ====> <a href="https://github.com/brentvatne/react-native-animated-demo-tinder">https://github.com/brentvatne/react-native-animated-demo-tinder</a> for a better demo with the new Animated API!!!</h1>

<h2>Intro</h2>

<p>The test of all good frameworks is how easy it is to implement Tinder right? Well with <code>react-native</code> we do get the benefits of flex box as well as some transforms which we&rsquo;ll take advantage of.</p>

<p>We don&rsquo;t have access to an easy physics, even though they were added in IOS7. If you&rsquo;d like physics you can use some JavaScript libraries like <code>rebound</code> <a href="https://github.com/facebook/rebound-js">https://github.com/facebook/rebound-js</a> from Facebook, or any others that don&rsquo;t require a DOM.</p>

<p>What we&rsquo;ll make</p>

<p><img class="<a" src="href="http://i.imgur.com/tTcT7xJ.png">http://i.imgur.com/tTcT7xJ.png</a>" title="End Result" ></p>

<h2>Concept</h2>

<p>We&rsquo;ll create a card. On touch press/grant we&rsquo;ll figure out the offset of the card to the touch and start generating the transform to move/rotate the card.</p>

<p>Well use the <code>style</code> <code>transform</code> property which we can find documentation here <a href="https://facebook.github.io/react-native/docs/transforms.html#proptypes">https://facebook.github.io/react-native/docs/transforms.html#proptypes</a>. However documentation is a little skimpy.</p>

<p>It&rsquo;s mostly straight forward once you dive in though.</p>

<h2>What we won&rsquo;t do.</h2>

<p>Physics. You can implement a bouncy spring system, but we&rsquo;ll keep it simple with a drag concept.</p>

<h2>Create a basic card</h2>

<p>We&rsquo;ll create a basic wrapper container and then create a card View.
We&rsquo;ll center everyting inside of our container using <code>alignItems</code> and <code>justifyContent</code> both <code>center</code>
Our card will just be <code>300</code> by <code>300</code>, with a little padding, and border.</p>

<p>```
render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
      &lt;View
        style={styles.card}
      &gt;
      &lt;/View&gt;
  &lt;/View&gt;
);
</code></pre>

<p>}</p>

<p>var styles = StyleSheet.create({
  container: {</p>

<pre><code>flex: 1,
alignItems: 'center',
justifyContent: 'center'
</code></pre>

<p>  },
  card: {</p>

<pre><code>borderWidth: 3,
borderRadius: 3,
borderColor: '#000',
width: 300,
height: 300,
padding: 10
</code></pre>

<p>  }
  });</p>

<p>```</p>

<p>Now that we have a generic card we can make it look a little nicer with an image, and some text.</p>

<h2>Add an Image/Text to card</h2>

<p>We&rsquo;ll add an image and set to a particular height. There is a current issue in <code>react-native</code> that doesn&rsquo;t maintain aspect ratio but that will be taken care of eventually.</p>

<p>We wrap our <code>Text</code> elements in <code>View</code> and position each <code>Text</code> item on the left and right.
There is a way to do this with flexbox but positioning like this is a little more explicit.</p>

<p>```
render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
      &lt;View
        style={styles.card}
      &gt;
        &lt;Image source= style={styles.cardImage} /&gt;
        &lt;View&gt;
          &lt;Text style={styles.textLeft}&gt;Rabbit, 10&lt;/Text&gt;
          &lt;Text style={styles.textRight}&gt;1 Connection&lt;/Text&gt;
        &lt;/View&gt;
      &lt;/View&gt;
  &lt;/View&gt;
);
</code></pre>

<p>}</p>

<p>var styles = StyleSheet.create({
  container: {</p>

<pre><code>flex: 1,
alignItems: 'center',
justifyContent: 'center'
</code></pre>

<p>  },
  card: {</p>

<pre><code>borderWidth: 3,
borderRadius: 3,
borderColor: '#000',
width: 300,
height: 300,
padding: 10
</code></pre>

<p>  },
  cardImage: {</p>

<pre><code>height: 260,
</code></pre>

<p>  },
  textLeft: {</p>

<pre><code>position: 'absolute',
left:0,
top:0
</code></pre>

<p>  },
  textRight: {</p>

<pre><code>position: 'absolute',
right: 0,
top: 0
</code></pre>

<p>  }
});</p>

<p>```</p>

<h2>Things to know about style</h2>

<p>Alright so there seems to be a lack of documentation around style in general. But <code>style</code> actually can receive an array.</p>

<p>You are capable of specifying a default layout, however doing overrides. For example take our card layout.</p>

<p>```
  card: {</p>

<pre><code>borderWidth: 3,
borderRadius: 3,
borderColor: '#000',
width: 300,
height: 300,
padding: 10
</code></pre>

<p>  }</p>

<p>```</p>

<p>This gets applied, but what if at some point in time we wanted to change the <code>borderColor</code> based on <code>state</code>.
Well we just override it on the style attribute like so</p>

<p>```</p>

<pre><code>&lt;View style={[styles.card, {borderColor: '#CCC'}]} /&gt;
</code></pre>

<p>```
So now the borderColor has a default but can be changed by just passing in an object.</p>

<p>This goes for <code>transform</code> as well which will set us up for the next challenge, actually dragging.</p>

<h2>Add in Drag</h2>

<p>We&rsquo;ll use the gesture responder system. The robustness is great, however I was expecting a little more information like deltas over the course of each drag update. We aren&rsquo;t given that to my knowledge so we&rsquo;ll computer it ourselves.</p>

<p>How the gesture system works is it must ask each element that has a gesture responder if it should be allowed to drag or not. In our case we have one element and minimal logic so we&rsquo;ll just return true. However at any point you can cancel a gesture by returning false.</p>

<p>In our case you need to respond <code>true</code> to <code>onStartShouldSetResponder</code> and then each subsequent move <code>onMoveShouldSetResponder</code>. If those return true then it will call <code>onResponderMove</code> each time with the new event.</p>

<p>We&rsquo;ll use <code>_onStartShouldSetResponder</code> function to setup our initial drag. Each subsequent move we subtract and get the delta of the move.</p>

<p>```
  getInitialState: function() {</p>

<pre><code>return {
  x: 0,
  y: 0
}
</code></pre>

<p>  },
  setPosition: function(e) {</p>

<pre><code>//Update our state with the deltaX/deltaY of the movement
this.setState({
  x: this.state.x + (e.nativeEvent.pageX - this.drag.x),
  y: this.state.y + (e.nativeEvent.pageY - this.drag.y)
});
//Set our drag to be the new position so our delta can be calculated next time correctly
this.drag.x = e.nativeEvent.pageX;
this.drag.y = e.nativeEvent.pageY;
</code></pre>

<p>  },
  resetPosition: function(e) {</p>

<pre><code>this.dragging = false;
//Reset on release
this.setState({
  x: 0,
  y: 0,
})
</code></pre>

<p>  },
  _onStartShouldSetResponder: function(e) {</p>

<pre><code>this.dragging = true;
//Setup initial drag coordinates
this.drag = {
  x: e.nativeEvent.pageX,
  y: e.nativeEvent.pageY
}
return true;
</code></pre>

<p>  },
  _onMoveShouldSetResponder: function(e) {</p>

<pre><code>return true;
</code></pre>

<p>  },
  getCardStyle: function() {</p>

<pre><code>var transform = [{translateX: this.state.x}, {translateY: this.state.y}];
return {transform: transform};
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
      &lt;View
        onResponderMove={this.setPosition}
        onResponderRelease={this.resetPosition}
        onStartShouldSetResponder={this._onStartShouldSetResponder}
        onMoveShouldSetResponder={this._onMoveShouldSetResponder}
        style={[styles.card, this.getCardStyle()]}
      &gt;
        &lt;Image source= style={styles.cardImage} /&gt;
        &lt;View style={styles.cardTextContainer}&gt;
          &lt;Text style={styles.textLeft}&gt;Rabbit, 10&lt;/Text&gt;
          &lt;Text style={styles.textRight}&gt;1 Connection&lt;/Text&gt;
        &lt;/View&gt;
      &lt;/View&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
});
```</p>

<p>So now when a user press down on our card and starts dragging it&rsquo;ll move around. On release it&rsquo;ll snap back to position <code>0,0</code>.</p>

<p>You can see we use the <code>translateX</code> and <code>translateY</code> transform properties. These will cause the ability for the card to be dragged around but not have to make it position absolute.</p>

<h2>Add in Rotate</h2>

<p>With Tinder and other card style systems as you drag the card left or right it will slightly rotate. It also rotates differently depending on the position you grab the card from (generally top or bottom).</p>

<p>The <code>transform</code> property on style also has a <code>rotate</code> option. This seems weird but it takes a string. That string can be something like <code>30deg</code> or <code>.05rad</code>. So it offers some flexibility. We&rsquo;ll use <code>degrees</code> since it&rsquo;s the easiest to comprehend.</p>

<p>We don&rsquo;t need to add anything to the view, just determine if we grabbed the card on the <code>top</code> or the <code>bottom</code>. Then depending on the offset drag make it rotate more as we move.</p>

<p>```
//Top of file
var Dimensions = require(&lsquo;Dimensions&rsquo;);
var windowSize = Dimensions.get(&lsquo;window&rsquo;);</p>

<p>//&hellip;
  _onStartShouldSetResponder: function(e) {</p>

<pre><code>this.dragging = true;

this.rotateTop = e.nativeEvent.locationY &lt;= 150;

this.drag = {
  x: e.nativeEvent.pageX,
  y: e.nativeEvent.pageY
}

return true;
</code></pre>

<p>  },
  getRotationDegree: function(rotateTop, x) {</p>

<pre><code>var rotation = ( (x/windowSize.width) * 100)/3;

var rotate = rotateTop ? 1 : -1,
    rotateString = (rotation * rotate) + 'deg';

return rotateString;
</code></pre>

<p>  },
  getCardStyle: function() {</p>

<pre><code>var transform = [{translateX: this.state.x}, {translateY: this.state.y}];

if (this.dragging) {
    transform.push({rotate: this.getRotationDegree(this.rotateTop, this.state.x)})
}

return {transform: transform};
</code></pre>

<p>  }
```</p>

<p>So we modify <code>_onStartShouldSetResponder</code> to determine wheter we grabbed top or bottom. We use the <code>locationY</code> property which is the point on the card that was touched. Since the card dimensions are <code>300x300</code> that means if the card was touched anywhere between <code>0 to 150</code> then it was touched on top.</p>

<p>Our <code>getCardStyle</code> will push a <code>rotate</code> object on if we are dragging.</p>

<p>We need to know how far around the screen you have dragged it from the center point.
So we get the screen dimensions, divide the width by the <code>pageX</code> coordinate which is just position of the element relative to the entire screen. To convert to degrees we multiply by <code>100</code> and divide by <code>3</code> to reduce the rotation.</p>

<p>If we touched on the bottom then we want to do a reverse rotation so we multiply by <code>-1</code>  and return a string that would return a value like <code>20.123deg</code> or <code>-20.123deg</code>.</p>

<h2>Add in Release Text</h2>

<p>Great we have dragging, we have rotating. Now how do we know which way they let go?
Well we can use those window dimensions and the <code>pageX</code> movement to determine if the card was released on the left or right.</p>

<p>```
  resetPosition: function(e) {</p>

<pre><code>this.dragging = false;
var left = e.nativeEvent.pageX &lt; (windowSize.width/2),
    displayText = left ? 'Released left' : 'Released right';

this.setState({
  x: 0,
  y: 0,
  lastDragDirectio: displayText
})
</code></pre>

<p>  },
```</p>

<h2>Final Code</h2>

<p>```
&lsquo;use strict&rsquo;;</p>

<p>var React = require(&lsquo;react-native&rsquo;);
var Dimensions = require(&lsquo;Dimensions&rsquo;);
var windowSize = Dimensions.get(&lsquo;window&rsquo;);</p>

<p>var {
  StyleSheet,
  AppRegistry,
  Text,
  View,
  ActivityIndicatorIOS,
  Image,
  Navigator,
  TouchableOpacity,
  Animation
} = React;</p>

<p>var Application = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
  x: 0,
  y: 0,
  lastDragDirectio: 'Drag and Release'
}
</code></pre>

<p>  },
  setPosition: function(e) {</p>

<pre><code>this.setState({
  x: this.state.x + (e.nativeEvent.pageX - this.drag.x),
  y: this.state.y + (e.nativeEvent.pageY - this.drag.y)
});
this.drag.x = e.nativeEvent.pageX;
this.drag.y = e.nativeEvent.pageY;
</code></pre>

<p>  },
  resetPosition: function(e) {</p>

<pre><code>this.dragging = false;
var left = e.nativeEvent.pageX &lt; (windowSize.width/2),
    displayText = left ? 'Released left' : 'Released right';

this.setState({
  x: 0,
  y: 0,
  lastDragDirectio: displayText
})
</code></pre>

<p>  },
  getRotationDegree: function(rotateTop, x) {</p>

<pre><code>var rotation = ( (x/windowSize.width) * 100)/3;

var rotate = rotateTop ? 1 : -1,
    rotateString = (rotation * rotate) + 'deg';

return rotateString;
</code></pre>

<p>  },
  getCardStyle: function() {</p>

<pre><code>var transform = [{translateX: this.state.x}, {translateY: this.state.y}];

if (this.dragging) {
    transform.push({rotate: this.getRotationDegree(this.rotateTop, this.state.x)})
}

return {transform: transform};
</code></pre>

<p>  },
  _onStartShouldSetResponder: function(e) {</p>

<pre><code>this.dragging = true;

this.rotateTop = e.nativeEvent.locationY &lt;= 150;

this.drag = {
  x: e.nativeEvent.pageX,
  y: e.nativeEvent.pageY
}

return true;
</code></pre>

<p>  },
  _onMoveShouldSetResponder: function(e) {</p>

<pre><code>return true;
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
      &lt;View
        onResponderMove={this.setPosition}
        onResponderRelease={this.resetPosition}
        onStartShouldSetResponder={this._onStartShouldSetResponder}
        onMoveShouldSetResponder={this._onMoveShouldSetResponder}
        style={[styles.card, this.getCardStyle()]}
      &gt;
        &lt;Image source= style={styles.cardImage} /&gt;
        &lt;View style={styles.cardTextContainer}&gt;
          &lt;Text style={styles.textLeft}&gt;Rabbit, 10&lt;/Text&gt;
          &lt;Text style={styles.textRight}&gt;1 Connection&lt;/Text&gt;
        &lt;/View&gt;
      &lt;/View&gt;
      &lt;View style={styles.dragText}&gt;
        &lt;Text&gt;{this.state.lastDragDirectio}&lt;/Text&gt;
      &lt;/View&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
});</p>

<p>var styles = StyleSheet.create({
  container: {</p>

<pre><code>flex: 1,
alignItems: 'center',
justifyContent: 'center'
</code></pre>

<p>  },
  dragText: {</p>

<pre><code>position: 'absolute',
bottom: 0,
left: 0
</code></pre>

<p>  },
  card: {</p>

<pre><code>borderWidth: 3,
borderRadius: 3,
borderColor: '#000',
width: 300,
height: 300,
padding: 10
</code></pre>

<p>  },
  cardImage: {</p>

<pre><code>height: 260,
</code></pre>

<p>  },
  textLeft: {</p>

<pre><code>position: 'absolute',
left:0,
top:0
</code></pre>

<p>  },
  textRight: {</p>

<pre><code>position: 'absolute',
right: 0,
top: 0
</code></pre>

<p>  }
});</p>

<p>module.exports = Application;
```</p>

<h2>Result</h2>

<p><img class="<a" src="href="http://i.imgur.com/q7siPyO.gif">http://i.imgur.com/q7siPyO.gif</a>" title="End Result" ></p>

<p>You can check out and play with the end result here.</p>

<h2>Preview Online!</h2>

<p>Thanks to React Native Playground you can play with this code live online.</p>

<p><a href="https://rnplay.org/apps/6uPJug">https://rnplay.org/apps/6uPJug</a></p>

<p>Your homework can be to add a bounce when the card is released.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CSS-Layout and React-Art]]></title>
    <link href="http://browniefed.com/blog/2015/06/01/css-layout-and-react-art/"/>
    <updated>2015-06-01T10:29:00-07:00</updated>
    <id>http://browniefed.com/blog/2015/06/01/css-layout-and-react-art</id>
    <content type="html"><![CDATA[<h3>Intro</h3>

<p>If you&rsquo;ve used <code>react-native</code> before then you may know that &ldquo;css&rdquo; you&rsquo;re writing isn&rsquo;t actually CSS. It&rsquo;s a descriptor for a layout engine. That layout engine is <a href="https://github.com/facebook/css-layout">css-layout</a> which was created by <a href="https://twitter.com/Vjeux">@vjeux</a> and compiled to Java/Objective-C.</p>

<p>Layout is difficult. There have been attempts at various constraint based layouts in JavaScript, <a href="http://gridstylesheets.org/">GSS</a> is one of those. Which is a port of Apples <code>Cassowary</code> constraint solver which was also ported to JavaScript <a href="https://github.com/slightlyoff/cassowary.js">https://github.com/slightlyoff/cassowary.js</a>.</p>

<p>Now this is all fine and well but from the bit I&rsquo;ve read constraints fall down sometimes. This usually happens when you don&rsquo;t specify enough constraints based on the current layout.</p>

<h3>Layout is hard!</h3>

<p>Parent layouts get effected by their child layouts. CSS is weird in that you can remove items from layout with <code>position: absolute</code> but ultimately the top parent <code>width/height</code> is directly effected by it&rsquo;s children.</p>

<p>This is an over simplification but many times in <code>React</code> you have to hook into <code>componentDidMount</code> get the child width and take action.</p>

<p>An example would be even width labels in a form. We could measure the text but depending on <code>font</code>, <code>font-size</code> it could measure each value differently. So we hide the form on initial render, get the max label width and set it on state.</p>

<h3>CSS-Layout Basics</h3>

<p>It takes a subset of flexbox and some other styling parameters and returns <code>width</code>, and the <code>left/top</code> offsets for each item and it&rsquo;s children.</p>

<p>This example is taken directly from the <code>css-layout</code> git repo.</p>

<p>```
computeLayout(
  {style: {padding: 50}, children: [</p>

<pre><code>{style: {padding: 10, alignSelf: 'stretch'}}
</code></pre>

<p>  ]}
);
// =>
{</p>

<pre><code>width: 120,
height: 120,
top: 0,
left: 0,
children: [{
    width: 20,
    height: 20,
    top: 50,
    left: 50
}]
</code></pre>

<p>}
```</p>

<p>So explaining this. We have an item with a padding of <code>50</code>, so <code>50px</code> around the entire item.</p>

<p>It&rsquo;s child item has a padding of <code>10</code>, so <code>10px</code> all the way around.</p>

<p>Therefore the parent has <code>50*2 = 100</code> initial width/height. Now we take into account the children.</p>

<p>Width/Height:</p>

<p><code>
Parent: `50*2 = 100` +  `10*2 = 20` = `100 + 120`
Child: `10*2 = 20`
</code></p>

<p>Position:</p>

<p><code>
Parent: `x = 0, y = 0` since we are starting there.
Child: Parent padding `50` so our child is inset at `x = 50, y = 50`
</code></p>

<p>Lets change the child width and see what happens
```
computeLayout(</p>

<pre><code>{
    style: {
        padding: 50
    },
    children: [{
        style: {
            padding: 10,
            width: 1000,
            alignSelf: 'stretch'
        }
    }]
}
</code></pre>

<p>);
// =>
{</p>

<pre><code>"width": 1100,
"height": 120,
"top": 0,
"left": 0,
"children": [{
    "width": 1000,
    "height": 20,
    "top": 50,
    "left": 50
}]
</code></pre>

<p>}
<code>``
Because our child defined a width of</code>1000<code>we then add on our</code>50*2<code>of padding on both sides and now the parent has a width of</code>1100`.</p>

<p>There are some other nuances that you can read about in the <code>css-layout</code> repo.</p>

<h3>Basic Example</h3>

<p>First off we&rsquo;ll need a component tree. Now in React they transpile JSX, and build the component tree for us. However in our case we can just create a JSON tree.</p>

<p>```
var componentTree = {</p>

<pre><code>style: {
    padding: 10
},
component: Rectangle,
children: [{
    style: {
        padding: 10,
        flexDirection: 'column',
        alignItems: 'center'
    },
    component: Rectangle,
    children: [
        {
            style: {
                width: 30,
                height: 30
            },
            component: Rectangle
        },
        {
            style: {
                margin: 10,
                width: 50,
                height: 50,
                alignItems: 'center',
                justifyContent: 'center'
            },
            component: Circle,
            children: [
                {
                    style: {
                        width: 10,
                        height: 10
                    },
                    component: Circle
                }
            ]
        }
    ]
}]
</code></pre>

<p>};</p>

<p>```</p>

<p>We add a <code>component</code> parameter to the tree. This is the thing that will be rendered.
We could add additional properties here, maybe create custom renderers but we&rsquo;ll keep it simple.</p>

<p>The break down is like so</p>

<ul>
<li>A surrounding rectangle w/ <code>10px</code> of padding all around</li>
<li>1 child that is a rectangle with another <code>10px</code> of padding, and it&rsquo;s children in a <code>column</code> based layout.</li>
<li>We align each of the items in the <code>center</code></li>
<li>2 children one a Rectangle, one a Cirlce.</li>
<li>Rectangle = <code>width = 30, height = 30</code></li>
<li>Circle = <code>width = 50, height = 50</code> and a surrounding <code>10px</code> margin and it&rsquo;s children centered vertically and horizontally</li>
<li>That cirlce has a circle inside that is <code>width = 10</code> and `height = 10
We&rsquo;ll have to do some basic math on the Circle to compute the radius, and center it correctly.</li>
</ul>


<p>Now we&rsquo;ll need to traverse the layout.
We&rsquo;ll do that with a function that calls itself</p>

<p>```
function traverseLayout(componentTree, layout) {</p>

<pre><code>var Component = componentTree.component;
return (
    &lt;Group x={layout.left} y={layout.top}&gt;
        &lt;Component
            {...getProps(Component, layout)}
         /&gt;
         &lt;Group x={0} y={0}&gt;
            {
                !componentTree.children ? null : componentTree.children.map(function(child, index) {
                    return traverseLayout(child, layout.children[index]);
                })

            }
         &lt;/Group&gt;
    &lt;/Group&gt;
)
</code></pre>

<p>}
```
This is a super crude layout renderer but it works for our purposes.</p>

<p>It creates a group and we pass in our <code>top/left</code> to <code>x/y</code> of the group. This is necessary to make our children <code>top/left</code> work correctly.
Then renders the component with selected props. We&rsquo;ll just render <code>stroke="#000"</code> and a stroke={1}.</p>

<p>Then if we have children we will call ourself with the child component and layout.</p>

<p>To process the props we need to render different props for specific components.</p>

<p><code>Rectangle</code> needs <code>width/height</code> which we have.
<code>Circle</code> needs the radius computed, and to then be ofset by the radius. So we just divide the <code>width/2</code> and for positioning <code>y</code> we divide the <code>height/2</code>.</p>

<p>```
function getProps(component, layout) {</p>

<pre><code>var props = {
    x: 0,
    y: 0
};

if (Rectangle === component) {
    props.width = layout.width;
    props.height = layout.height;

} else if (Circle === component) {
    props.radius = layout.width/2;
    props.x += (layout.width/2)
    props.y += (layout.height/2);
}

props.stroke = "#000"; // Just to visualize
props.strokeWidth = 1; // Just to visualize
return props;
</code></pre>

<p>}
```</p>

<p>That is it, now we can render a tree of <code>Rectangles</code> and <code>Circles</code>. The complete code is below.</p>

<p>```
var React = require(&lsquo;react&rsquo;);
var ReactArt = require(&lsquo;react-art&rsquo;),</p>

<pre><code>Surface = ReactArt.Surface,
Group = ReactArt.Group,
computeLayout = require('css-layout'),
Circle = require('react-art/shapes/circle'),
Rectangle = require('react-art/shapes/rectangle');
</code></pre>

<p>var Surface = ReactArt.Surface;</p>

<p>var viewportWidth = function() {</p>

<pre><code>return  window.innerWidth - 100;
</code></pre>

<p>}
var viewportHeight = function() {</p>

<pre><code>return window.innerHeight - 100;
</code></pre>

<p>}</p>

<p>var componentTree = {</p>

<pre><code>style: {
    padding: 10
},
component: Rectangle,
children: [{
    style: {
        padding: 10,
        flexDirection: 'column',
        alignItems: 'center'
    },
    component: Rectangle,
    children: [
        {
            style: {
                width: 30,
                height: 30
            },
            component: Rectangle
        },
        {
            style: {
                margin: 10,
                width: 50,
                height: 50,
                alignItems: 'center',
                justifyContent: 'center'
            },
            component: Circle,
            children: [
                {
                    style: {
                        width: 10,
                        height: 10
                    },
                    component: Circle
                }
            ]
        }
    ]
}]
</code></pre>

<p>};</p>

<p>var layout = computeLayout(componentTree);</p>

<p>function traverseLayout(componentTree, layout) {</p>

<pre><code>var Component = componentTree.component;
return (
    &lt;Group x={layout.left} y={layout.top}&gt;
        &lt;Component
            {...getProps(Component, layout)}
         /&gt;
         &lt;Group x={0} y={0}&gt;
            {
                !componentTree.children ? null : componentTree.children.map(function(child, index) {
                    return traverseLayout(child, layout.children[index]);
                })

            }
         &lt;/Group&gt;
    &lt;/Group&gt;
)
</code></pre>

<p>}</p>

<p>function getProps(component, layout) {</p>

<pre><code>var props = {
    x: 0,
    y: 0
};

if (Rectangle === component) {
    props.width = layout.width;
    props.height = layout.height;

} else if (Circle === component) {
    props.radius = layout.width/2;
    props.x += (layout.width/2)
    props.y += (layout.height/2);
}

props.stroke = "#000";
props.strokeWidth = 1;
return props;
</code></pre>

<p>}</p>

<p>var Demo = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {

}
</code></pre>

<p>  },
  getRenderLayout: function() {</p>

<pre><code>return traverseLayout(componentTree, layout);
</code></pre>

<p>  },
  render: function () {</p>

<pre><code>return (
  &lt;div&gt;
    &lt;Surface
        width={viewportWidth()}
        height={viewportHeight()}
    &gt;
        {this.getRenderLayout()}
    &lt;/Surface&gt;
  &lt;/div&gt;
);
</code></pre>

<p>  }
});</p>

<p>module.exports = Demo;
```</p>

<h3>Possibilities</h3>

<p>Tic-tac-toe? Heh.</p>

<p>This could be made to layout components arbitrarily much like we do with <code>react-native</code>. It&rsquo;s not perfect and could only be used in specific scenarios but it&rsquo;s still a fun prototype.</p>

<h3>Demo</h3>

<p data-height="624" data-theme-id="0" data-slug-hash="zGZOMN" data-default-tab="result" data-user="browniefed" class='codepen'>See the Pen <a href='http://codepen.io/browniefed/pen/zGZOMN/'>zGZOMN</a> by Jason Brown (<a href='http://codepen.io/browniefed'>@browniefed</a>) on <a href='http://codepen.io'>CodePen</a>.</p>


<script async src="http://browniefed.com//assets.codepen.io/assets/embed/ei.js"></script>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Create a map with React-Art]]></title>
    <link href="http://browniefed.com/blog/2015/05/30/create-a-map-with-react-art/"/>
    <updated>2015-05-30T10:15:00-07:00</updated>
    <id>http://browniefed.com/blog/2015/05/30/create-a-map-with-react-art</id>
    <content type="html"><![CDATA[<h3>Intro</h3>

<p>Just Like the title states, we&rsquo;re going to make a map with <code>react-art</code>. When you think of maps many people jump straight to <code>leaflet</code>, <code>google maps</code>, or <code>mapbox</code>. Well one of the key things they are doing is just plotting map tiles.</p>

<p>Map tiles are just images that can be stitched together and form a map. That is why whenever you drag on a map portions of it pop in in squares.</p>

<p>Don&rsquo;t worry, I won&rsquo;t get deep into mapping terminology because I don&rsquo;t know it. If you want to learn checkout this post <a href="http://www.macwright.org/2012/05/15/how-web-maps-work.html">http://www.macwright.org/2012/05/15/how-web-maps-work.html</a></p>

<p>All you&rsquo;ll need to know is <code>Latitude</code>, <code>Longitude</code>, and <code>Tile</code> aka (an image of a piece of a map).</p>

<p>Our tilemap source will be the fabulous <a href="https://www.openstreetmap.org/">OpenStreetMap</a>. It&rsquo;s a community driven mapping solution. Check it out and contribute if you can!</p>

<p>This was going to be a blog post about creating a map but I ended up turning it into a library.</p>

<h3>What I Built</h3>

<p>I ended up writing up a library to show it off.</p>

<p>Checkout <a href="https://github.com/browniefed/react-art-map">https://github.com/browniefed/react-art-map</a> for the library and examples.</p>

<p>We use <a href="https://github.com/zacbarton/node-googlemaps-utils">https://github.com/zacbarton/node-googlemaps-utils</a> and
<a href="https://github.com/gagan-bansal/map-the-tiles">https://github.com/gagan-bansal/map-the-tiles</a>.</p>

<p>These 2 libraries are helper libraries.</p>

<p><code>googlemaps-utils</code> takes a <code>width/height</code> and a central <code>lat/long</code> and gives us a bounding box which is just the <code>top/left</code> coordinate and the <code>bottom/right</code> coordinate.</p>

<p>We then take that bounding box and convert it to meter points so we can generate a <a href="http://en.wikipedia.org/wiki/Mercator_projection">mercator projection</a>.</p>

<p>The <code>map-the-tiles</code> takes those meter points and returns <code>x,y,z</code> points;</p>

<p>Those <code>x,y,z</code> points get fed into the OSM url <code>http://{s}.tile.osm.org/{z}/{x}/{y}.png</code> and we get our tile images.</p>

<p>We can then render them at their given <code>top/left</code> points w/ <code>react-art</code>.</p>

<p>Ultimately this library was built with A LOT of googling and assembling some tools people already constructed.</p>

<h3>Some Internals</h3>

<p>Most of the logic is just in the <code>TileUtil</code>. There are likely much more efficient ways to do this however this is my first stab at it with my limited geo knowledge.</p>

<p>Converts <code>lat/long</code> to meter points
```</p>

<pre><code>degrees2meters(lon,lat) {
    var x = lon * 20037508.34 / 180;
    var y = Math.log(Math.tan((90 + lat) * Math.PI / 360)) / (Math.PI / 180);
    y = y * 20037508.34 / 180;
    return [x, y]
}
</code></pre>

<p>```</p>

<p>Converts meters to coordinates
```</p>

<pre><code>meters2degress(x,y) {
    var lon = x *  180 / 20037508.34 ;
    var lat = Number(180 / Math.PI * (2 * Math.atan(Math.exp(y * Math.PI / 180)) - Math.PI / 2));
    return [lon, lat]
}
</code></pre>

<p>```</p>

<p>The main layout generator.</p>

<p>```</p>

<pre><code>getTileLayout(options) {
    var layout = [];
    var bounds = gmu.calcBounds(options.center[1], options.center[0], options.zoom, options.width, options.height); // GET COORDINATE BOUNDS

    var topLeftMeters = TileUtil.degrees2meters(bounds.left, bounds.top),
        bottomRightMeters = TileUtil.degrees2meters(bounds.right, bounds.bottom);

    //Conver the coordinates each to meters

    var tiler = new MapTheTiles(null, options.tileWidth); // Create a generic tiler based on our tile width

    var layoutForBounds = {
        top: topLeftMeters[1],
        left: topLeftMeters[0],
        right: bottomRightMeters[0],
        bottom: bottomRightMeters[1]
    };
    //Pass in the meters for each point

    var tiles = tiler.getTiles(layoutForBounds, options.zoom) // Get the x,y,z points for our zoom level

    tiles.forEach(function(tile) {
        var coordPoint = {
            x: tile.X,
            y: tile.Y,
            z: tile.Z
        },
        coord = {
            x: tile.left,
            y: tile.top,
            img: TileUtil.getTileUrl(options.tileSource, coordPoint, options.subdomains) //Just format the OSM tile resource
        };

        layout.push(coord);
    }, this);

    return layout;
}
</code></pre>

<p>```</p>

<p>This is how we render each tile.
We have the <code>x/y</code> coordinates thanks to our tiler.</p>

<p>We use <code>Paths.js</code> to create a generic rectangular path.
This is so we can support <code>react-native</code> in the future since the shapes have yet to be created.</p>

<p>Then we create a new fill with the tile image and set it to the width/height of the generic tile at <code>0,0</code> of the shape.</p>

<p>This technically is a pattern for the background but because we set it to the exact <code>width/height</code> of the image it just renders the image once.</p>

<p>```
var rectanglePath = Rectangle({
  top: 0,
  left: 0,
  right: 256,
  bottom: 256
}).path.print();
///UP ABOVE</p>

<pre><code>    return layout.map(function(tile) {
        return (
            &lt;Shape
                d={rectanglePath}
                x={tile.x}
                y={tile.y}
                fill={new Pattern(tile.img, this.props.tileWidth , this.props.tileWidth, 0, 0)}
            /&gt;
        )
    }, this);
</code></pre>

<p>```</p>

<h3>The Code</h3>

<p>```
var React = require(&lsquo;react&rsquo;);
var ReactMap = require(&lsquo;react-art-map&rsquo;);
var ReactArt = require(&lsquo;react-art&rsquo;),</p>

<pre><code>Circle = require('react-art/shapes/circle');
</code></pre>

<p>var Map = ReactMap.Map;</p>

<p>var viewportWidth = function() {</p>

<pre><code>return  window.innerWidth - 100;
</code></pre>

<p>}
var viewportHeight = function() {</p>

<pre><code>return window.innerHeight - 100;
</code></pre>

<p>}</p>

<p>var center = [</p>

<pre><code>-122.668197,45.525292
</code></pre>

<p>],
offset = 3;</p>

<p>var Demo = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
  center: center,
  zoom: 15,
  x: 100
}
</code></pre>

<p>  },
  componentDidMount: function() {</p>

<pre><code>requestAnimationFrame(this.updateCircle);
</code></pre>

<p>  },
  updateCircle: function() {</p>

<pre><code>if (this.state.x &gt;= viewportWidth()) {
    offset = -3;
} else if ( this.state.x &lt;= 99) {
    offset = 3;
}

this.state.x += offset;
this.setState(this.state, function() {
    requestAnimationFrame(this.updateCircle);
});
</code></pre>

<p>  },
  handleDrag: function(newCenter) {</p>

<pre><code>this.setState({
  center: newCenter
});
</code></pre>

<p>  },
  render: function () {</p>

<pre><code>return (
  &lt;div&gt;
    &lt;Map
        width={viewportWidth()}
        height={viewportHeight()}
        center={this.state.center}
        zoom={this.state.zoom}
        tileSource="http://{s}.tile.osm.org/{z}/{x}/{y}.png"
        onDrag={this.handleDrag}
    &gt;
        &lt;Circle 
            x={this.state.x}
            y={100}
            radius={30}
            stroke="#000"
            strokeWidth={5}
        /&gt;
    &lt;/Map&gt;
  &lt;/div&gt;
);
</code></pre>

<p>  }
});</p>

<p>module.exports = Demo;
```</p>

<h3>React Native?!?!?!</h3>

<p>React Native has a map implementation but it doesn&rsquo;t allow for much flexibility. You can render pins but that is about it.</p>

<p>With this library once the Pattern fill gets implemented you can render any map tile based service + any cool visualiztions on the map that you want.</p>

<p>I&rsquo;ve logged an issue here <a href="https://github.com/facebook/react-native/issues/1462">https://github.com/facebook/react-native/issues/1462</a> so follow along for when it gets implemented.</p>

<h3>Results</h3>

<p data-height="624" data-theme-id="0" data-slug-hash="PqWRvz" data-default-tab="result" data-user="browniefed" class='codepen'>See the Pen <a href='http://codepen.io/browniefed/pen/PqWRvz/'>PqWRvz</a> by Jason Brown (<a href='http://codepen.io/browniefed'>@browniefed</a>) on <a href='http://codepen.io'>CodePen</a>.</p>


<script async src="http://browniefed.com//assets.codepen.io/assets/embed/ei.js"></script>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React-Art and Bar Charts]]></title>
    <link href="http://browniefed.com/blog/2015/05/29/react-art-and-bar-charts/"/>
    <updated>2015-05-29T08:53:00-07:00</updated>
    <id>http://browniefed.com/blog/2015/05/29/react-art-and-bar-charts</id>
    <content type="html"><![CDATA[<h3>Introduction</h3>

<p>I&rsquo;ve shown in the past how to utilize <code>react-art</code> and other libraries to do animations, and render arbitrary things. So now lets bring it all together, lets render a simple bar chart.</p>

<p>I&rsquo;m going to leverage <a href="https://github.com/andreaferretti/paths-js">Paths.js</a> because it was made for this exact reason. Given data, generate an immutable set of paths. Ultimately that is what visualizations are, a data set converted to a set of paths.</p>

<p>The end result will look something
<img class="<a" src="href="http://i.imgur.com/DpChFtO.png">http://i.imgur.com/DpChFtO.png</a>" title="Bar Chart Result w/ Hover" ></p>

<h3>Boilerplate</h3>

<p>I like to setup a boilerplate templat that just renders an arbitrary surface that is the full width of the viewport. Also to make things response we&rsquo;ll hook up some event listeners to the window resize and trigger a re-render.</p>

<p>We will bring in each side <code>100px</code> and add a <code>margin</code> of <code>50px</code> to each side to give us some padding on each side. Also note we should totally debounce the resize event on the window if this was production!</p>

<p>```
var React = require(&lsquo;react&rsquo;),</p>

<pre><code>ReactArt = require('react-art'),
Surface = ReactArt.Surface;
</code></pre>

<p>var viewportWidth = function() {</p>

<pre><code>return  window.innerWidth - 100;
</code></pre>

<p>}
var viewportHeight = function() {</p>

<pre><code>return window.innerHeight - 100;
</code></pre>

<p>}</p>

<p>var Demo = React.createClass({</p>

<pre><code>getInitialState: function() {
    return {
        width: viewportWidth(),
        height: viewportHeight()
    }
},
componentDidMount: function() {
    window.addEventListener('resize', this.refresh, false); //This should be debounced
},
componentWillUnmount: function() {
    window.removeEventListener('resize', this.refresh, false);
},
refresh: function() {
    this.setState({
        width: viewportWidth(),
        height: viewportHeight()
    });
},

render: function() {
    var bar = this.getBar();

    return (
        &lt;div style= style=&gt;
            &lt;Surface
                width={this.state.width}
                height={this.state.height}
            &gt;

            &lt;/Surface&gt;
        &lt;/div&gt;
    );
}
</code></pre>

<p>});</p>

<p>module.exports = Demo;
```</p>

<h3>Data and the Chart</h3>

<p>We need some data, so I&rsquo;ll steal some from the <code>Paths.js</code> wiki, and also steal the colors.</p>

<p>We&rsquo;ll add a method that returns a Bar Chart generated by <code>Paths.js</code> that is dervied from width/height we set on state.
A new Bar Chart will get called every time we call <code>setState</code>.</p>

<p>```
var data = [</p>

<pre><code>[
  { name: 'Italy', population: 59859996 },
  { name: 'Spain', population: 46704314 },
  { name: 'France', population: 65806000 },
  { name: 'Romania', population: 20121641 },
  { name: 'Greece', population: 10815197 }
],
[
  { name: 'Zambia', population: 14580290 },
  { name: 'Cameroon', population: 20386799 },
  { name: 'Nigeria', population: 173615000 },
  { name: 'Ethiopia', population: 86613986 },
  { name: 'Ghana', population: 24658823 }
]
</code></pre>

<p>  ];</p>

<p>var colorPallete = [&ldquo;#FEE871&rdquo;, &ldquo;#E5FAAF&rdquo;];</p>

<p>getBar: function() {</p>

<pre><code>var bar = Bar({
  data: data,
  accessor: function(x) { return x.population; }, // Value to use
  compute: {
    color: function(i) { return colorPallete[i]; } //Color of the bar
  },
  width: this.state.width, //Set it to our surface width so it is responsive when our surface width changes
  height: this.state.height, //Set it to our surface height so it's repsponsive
  gutter: 10
});

return bar;
</code></pre>

<p>}</p>

<p>```</p>

<h3>Lets create the X/Y axis bars</h3>

<p>The X axis and Y axis can be generated with straight lines by once again <code>Paths.js</code> <code>Path</code> method.</p>

<p>The <code>X</code> axis starts at the bottom left corner, so <code>0,height</code>, and runs to the far right, so <code>width,height</code>.</p>

<p>The <code>Y</code> axis starts at the top right corner, so <code>0,0</code>, and runs along the left side to the bottom so <code>0,height</code></p>

<p>We merely stroke a 1px black line.</p>

<p>```
getXAxis: function() {</p>

<pre><code>var path = Path().moveto(0, this.state.height).lineto(this.state.width, this.state.height);
return (
    &lt;Shape d={path.print()} strokeWidth={1} stroke="#000" /&gt;
);   
</code></pre>

<p>},
getYAxis: function() {</p>

<pre><code>var path = Path().moveto(0,0).lineto(0, this.state.height);
return (
    &lt;Shape d={path.print()} strokeWidth={1} stroke="#000" /&gt;
); 
</code></pre>

<p>},
render: function() {</p>

<pre><code>    return (
        &lt;div style= style=&gt;
            &lt;Surface
                width={this.state.width}
                height={this.state.height}
            &gt;
                &lt;Group&gt;
                    {this.getXAxis()}
                    {this.getYAxis()}
                &lt;/Group&gt;
            &lt;/Surface&gt;
        &lt;/div&gt;
    );
}
</code></pre>

<p>```</p>

<h3>Render the Bar Graph</h3>

<p>We&rsquo;ll call <code>this.getBar()</code> to just generate one bar graph and then pipe it into each function that needs it.
To make this more testable we&rsquo;d probably just want to provide each function with absolutely necessary info but just keep that in mind if you implement this for real.</p>

<p>All we do is map over each <code>curve</code> that we have, in our case we have <code>10</code> data points so therefore we have <code>10</code> curves.
The color comes from the way we grouped our data and the pallette we provided in the first step.</p>

<p>```</p>

<pre><code>getBarChart: function(bar) {
    return bar.curves.map(function(bar) {
        return (
            &lt;Group&gt;
              &lt;Shape d={bar.line.path.print()} fill={bar.color}/&gt;
            &lt;/Group&gt;
        )
    }, this)
},
render: function() {
    var bar = this.getBar();

    return (
        &lt;div style= style=&gt;
            &lt;Surface
                width={this.state.width}
                height={this.state.height}
            &gt;
                &lt;Group&gt;
                    {this.getBarChart(bar)} 
                &lt;/Group&gt;
                &lt;Group&gt;
                    {this.getXAxis(bar)}
                    {this.getYAxis(bar)}
                &lt;/Group&gt;
            &lt;/Surface&gt;
        &lt;/div&gt;
    );
}
</code></pre>

<p>```</p>

<h3>Render the Bar Information</h3>

<p>Lets also display some text about the bars. We&rsquo;ll use <code>Text</code> from <code>react-art</code> to do that.
We need to calculate a few points, which <code>Paths.js</code> will help us with.</p>

<p>Since each bar is a rectangle it just has 4 points, we can get the <code>points</code> from the path.
The path will gives us 4 arrays, each with <code>x,y</code> coordinates of each corner point.</p>

<p>We need to do a little subtraction of the <code>x,y</code> coordinates to figure out the width of each bar, and height of each bar so we can place our text.</p>

<p>We&rsquo;ll use the <code>Group</code> element from <code>react-art</code> to adjust our coordinate system to start at the top left of each bar.
The name and population will be aligned to the center, and at the bottom of the bar. We can use <code>x,y</code> coordinates to derive our width/height.</p>

<p>```</p>

<pre><code>getBarChart: function(bar) {
    return bar.curves.map(function(bar) {

        var points = bar.line.path.points(),
            right = points[0][0],
            top = points[0][1],
            left = points[2][0],
            bottom = points[2][1],
            width = right - left,
            height = bottom - top;

        return (
            &lt;Group&gt;
              &lt;Shape d={bar.line.path.print()} fill={bar.color}/&gt;

              &lt;Group x={left} y={top}&gt;
                &lt;Text x={width/2} y={height - 24} alignment="middle" fill="#000" font='bold 10px "Arial"'&gt;{bar.item.name}&lt;/Text&gt;
                &lt;Text x={width/2} y={height - 12} alignment="middle" fill="#000" font='bold 10px "Arial"'&gt;{bar.item.population +''}&lt;/Text&gt;
              &lt;/Group&gt;
            &lt;/Group&gt;
        )
    }, this)
},
</code></pre>

<p>```</p>

<h3>Hover data for fun</h3>

<p>Just to show how to handle mouse events we can have a <code>mouseMove</code> on each bar.
We&rsquo;ll bind each hover event with the <code>item</code> object which has the name and population.</p>

<p>When a new bar is hovered or the mouse is moved it will set the <code>hoveredItem</code> object and coordinates on our state which will cause a re-render.
Each movement of the mouse will cause a re-render so be sure and debounce this as well.</p>

<p>The hovered data displayed will actually use HTML not <code>react-art</code> since we wrap the <code>Surface</code> in a <code>div</code> and give it <code>position:relative</code>. This will mean it has the same coordinates as our <code>Surface</code> mouse events which is why we can just use <code>x,y</code> on the event.</p>

<p>```</p>

<pre><code>handleMouseMove: function(item, e) {
    this.setState({
        hoveredItem: item,
        hoveredY: e.y,
        hoveredX: e.x
    });
},
getBarChart: function(bar) {
    return bar.curves.map(function(bar) {

        var points = bar.line.path.points(),
            right = points[0][0],
            top = points[0][1],
            left = points[2][0],
            bottom = points[2][1],
            width = right - left,
            height = bottom - top;

        return (
            &lt;Group 
              onMouseMove={this.handleMouseMove.bind(this, bar.item)}
            &gt;
              &lt;Shape d={bar.line.path.print()} fill={bar.color}/&gt;

              &lt;Group x={left} y={top}&gt;
                &lt;Text x={width/2} y={height - 24} alignment="middle" fill="#000" font='bold 10px "Arial"'&gt;{bar.item.name}&lt;/Text&gt;
                &lt;Text x={width/2} y={height - 12} alignment="middle" fill="#000" font='bold 10px "Arial"'&gt;{bar.item.population +''}&lt;/Text&gt;
              &lt;/Group&gt;
            &lt;/Group&gt;
        )
    }, this)
},
getHoveredData: function() {
    if (!this.state.hoveredItem) {
        return null;
    }
    return (
            &lt;div style=&gt;
                &lt;h2&gt;{this.state.hoveredItem.name}&lt;/h2&gt;
                &lt;h5&gt;{this.state.hoveredItem.population}&lt;/h5&gt;
            &lt;/div&gt;
        )
},
render: function() {
    var bar = this.getBar();

    return (
        &lt;div style= style=&gt;
            &lt;Surface
                width={this.state.width}
                height={this.state.height}
            &gt;
                &lt;Group&gt;
                    {this.getBarChart(bar)} 
                &lt;/Group&gt;
                &lt;Group&gt;
                    {this.getXAxis(bar)}
                    {this.getYAxis(bar)}
                &lt;/Group&gt;
            &lt;/Surface&gt;
            {this.getHoveredData()}

        &lt;/div&gt;
    );
}
</code></pre>

<p>```</p>

<h3>Final Code</h3>

<p>Finally all the code combined.</p>

<p>```
var React = require(&lsquo;react&rsquo;),</p>

<pre><code>ReactArt = require('react-art'),
Surface = ReactArt.Surface,
Group = ReactArt.Group,
Text = ReactArt.Text,
Shape = ReactArt.Shape,
Bar = require('paths-js/bar'),
Path = require('paths-js/path');
</code></pre>

<p>var viewportWidth = function() {</p>

<pre><code>return  window.innerWidth - 100;
</code></pre>

<p>}
var viewportHeight = function() {</p>

<pre><code>return window.innerHeight - 100;
</code></pre>

<p>}</p>

<p>var data = [</p>

<pre><code>[
  { name: 'Italy', population: 59859996 },
  { name: 'Spain', population: 46704314 },
  { name: 'France', population: 65806000 },
  { name: 'Romania', population: 20121641 },
  { name: 'Greece', population: 10815197 }
],
[
  { name: 'Zambia', population: 14580290 },
  { name: 'Cameroon', population: 20386799 },
  { name: 'Nigeria', population: 173615000 },
  { name: 'Ethiopia', population: 86613986 },
  { name: 'Ghana', population: 24658823 }
]
</code></pre>

<p>  ];</p>

<p>var colorPallete = [&ldquo;#FEE871&rdquo;, &ldquo;#E5FAAF&rdquo;, &ldquo;#B7E5F5&rdquo;];</p>

<p>var Demo = React.createClass({</p>

<pre><code>getInitialState: function() {
    return {
        width: viewportWidth(),
        height: viewportHeight()
    }
},
componentDidMount: function() {
    window.addEventListener('resize', this.refresh, false); //This should be debounced
},
componentWillUnmount: function() {
    window.removeEventListener('resize', this.refresh, false);
},
refresh: function() {
    this.setState({
        width: viewportWidth(),
        height: viewportHeight()
    });
},
getBar: function() {

    var bar = Bar({
      data: data,
      accessor: function(x) { return x.population; }, // Value to use
      compute: {
        color: function(i) { return colorPallete[i]; } //Color of the bar
      },
      width: this.state.width, //Set it to our surface width so it is responsive when our surface width changes
      height: this.state.height, //Set it to our surface height so it's repsponsive
      gutter: 10
    });

    return bar;
},
handleMouseMove: function(item, e) {
    this.setState({
        hoveredItem: item,
        hoveredY: e.y,
        hoveredX: e.x
    });
},
getBarChart: function(bar) {
    return bar.curves.map(function(bar) {

        var points = bar.line.path.points(),
            right = points[0][0],
            top = points[0][1],
            left = points[2][0],
            bottom = points[2][1],
            width = right - left,
            height = bottom - top;

        return (
            &lt;Group 
              onMouseMove={this.handleMouseMove.bind(this, bar.item)}
            &gt;
              &lt;Shape d={bar.line.path.print()} fill={bar.color}/&gt;

              &lt;Group x={left} y={top}&gt;
                &lt;Text x={width/2} y={height - 24} alignment="middle" fill="#000" font='bold 10px "Arial"'&gt;{bar.item.name}&lt;/Text&gt;
                &lt;Text x={width/2} y={height - 12} alignment="middle" fill="#000" font='bold 10px "Arial"'&gt;{bar.item.population +''}&lt;/Text&gt;
              &lt;/Group&gt;
            &lt;/Group&gt;
        )
    }, this)
},
getXAxis: function(bar) {
    var path = Path().moveto(0, this.state.height).lineto(this.state.width, this.state.height);
    return (
        &lt;Shape d={path.print()} strokeWidth={1} stroke="#000" /&gt;
    );   
},
getYAxis: function(bar) {
    var path = Path().moveto(0,0).lineto(0, this.state.height);
    return (
        &lt;Shape d={path.print()} strokeWidth={1} stroke="#000" /&gt;
    ); 
},
getHoveredData: function() {
    if (!this.state.hoveredItem) {
        return null;
    }
    return (
            &lt;div style=&gt;
                &lt;h2&gt;{this.state.hoveredItem.name}&lt;/h2&gt;
                &lt;h5&gt;{this.state.hoveredItem.population}&lt;/h5&gt;
            &lt;/div&gt;
        )
},
render: function() {
    var bar = this.getBar();

    return (
        &lt;div style= style=&gt;
            &lt;Surface
                width={this.state.width}
                height={this.state.height}
            &gt;
                &lt;Group&gt;
                    {this.getBarChart(bar)} 
                &lt;/Group&gt;
                &lt;Group&gt;
                    {this.getXAxis(bar)}
                    {this.getYAxis(bar)}
                &lt;/Group&gt;
            &lt;/Surface&gt;
            {this.getHoveredData()}

        &lt;/div&gt;
    );
}
</code></pre>

<p>});</p>

<p>module.exports = Demo;
```</p>

<h3>Results</h3>

<p data-height="624" data-theme-id="0" data-slug-hash="LVxjPw" data-default-tab="result" data-user="browniefed" class='codepen'>See the Pen <a href='http://codepen.io/browniefed/pen/LVxjPw/'>LVxjPw</a> by Jason Brown (<a href='http://codepen.io/browniefed'>@browniefed</a>) on <a href='http://codepen.io'>CodePen</a>.</p>


<script async src="http://browniefed.com//assets.codepen.io/assets/embed/ei.js"></script>


<h3>Conclusion</h3>

<p>Once again <a href="https://github.com/andreaferretti/paths-js">Paths.js</a> comes in handy for generating arbitrary path information, and providing access to a lot of valuable data to making laying out your graphs with <code>react-art</code> a breeze.</p>

<p>Some homework for you is to add some vertical labels at each particular step.</p>
]]></content>
  </entry>
  
</feed>
