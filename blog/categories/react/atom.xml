<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: react | JavaScript Without Grammar]]></title>
  <link href="http://browniefed.com/blog/categories/react/atom.xml" rel="self"/>
  <link href="http://browniefed.com/"/>
  <updated>2016-01-13T09:30:07-08:00</updated>
  <id>http://browniefed.com/</id>
  <author>
    <name><![CDATA[Jason Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[React Native - How to create Twitter exploding hearts]]></title>
    <link href="http://browniefed.com/blog/2015/11/07/react-native-how-to-create-twitter-exploding-hearts/"/>
    <updated>2015-11-07T08:55:00-08:00</updated>
    <id>http://browniefed.com/blog/2015/11/07/react-native-how-to-create-twitter-exploding-hearts</id>
    <content type="html"><![CDATA[<p>So we&rsquo;re going to build this exploding heart, except just know Twitter kind of cheated. Not really but they used an image and played each frame adjusting <code>background-position</code> so it looked animated. Okay not cheated they used a really smart technique but what&rsquo;s the fun in doing that when we can build it for real!</p>

<p>I&rsquo;ve already built a Firework concept here <a href="http://browniefed.com/blog/2015/08/29/react-native-animated-with-react-art-firework-show/">http://browniefed.com/blog/2015/08/29/react-native-animated-with-react-art-firework-show/</a> and about Hearts here <a href="http://browniefed.com/blog/2015/09/07/react-native-periscope-hearts-animation/">http://browniefed.com/blog/2015/09/07/react-native-periscope-hearts-animation/</a> now we just need to bring them together.</p>

<p>For the record this is what theirs looks like here <a href="http://i.imgur.com/3a8PiSY.png">http://i.imgur.com/3a8PiSY.png</a></p>

<h2>What are we building</h2>

<p><img class="<a" src="href="http://i.imgur.com/lMOxqIL.gif">http://i.imgur.com/lMOxqIL.gif</a>" title="So not lazy like Twitter" ></p>

<!-- more -->


<h2>Concept</h2>

<p>Rather than iterating over 28 separate image frames what we&rsquo;re going to do instead is make some pseudo-keyframe-animations. We&rsquo;ll use <code>Animated</code> of course. We&rsquo;ll define our range from <code>0</code> to <code>28</code>. Meaning we&rsquo;ll have 28 frames to deal with.</p>

<p>This makes the math easy, because we can walk through each frame, and describe what the animation should look like for each frame.</p>

<p>We could create separate animated values for each property and coordinate the animation with <code>Animated.sequence</code> and <code>Animated.parallel</code> but I prefer interpolation. YMMV</p>

<h2>Setup</h2>

<p>```
var React = require(&lsquo;react-native&rsquo;);</p>

<p>var {
  AppRegistry,
  StyleSheet,
  View,
  Dimensions,
  TouchableWithoutFeedback,
  Animated
} = React;</p>

<p>var Art = require(&lsquo;ReactNativeART&rsquo;);</p>

<p>var {
  Surface,
  Group,
  Shape,
  Path
} = Art;</p>

<p>var AnimatedShape = Animated.createAnimatedComponent(Shape);</p>

<p>var {
  width: deviceWidth,
  height: deviceHeight
} = Dimensions.get(&lsquo;window&rsquo;);</p>

<p><code>``
We'll need to setup</code>ReactNativeArt` in XCode, you can check out how to do that <a href="http://browniefed.com/blog/2015/05/03/getting-react-art-running-on-react-native/">here</a>.</p>

<p>Things to call out here is we are creating a custom animated view, called <code>AnimatedShape</code>. We pass in the <code>art</code> <code>Shape</code> component into <code>Animated.createAnimatedComponent</code>. This allows us to use <code>Animated</code> values in any component.</p>

<h2>More Setup</h2>

<p>```
var HEART_SVG = &ldquo;M130.4-0.8c25.4 0 46 20.6 46 46.1 0 13.1-5.5 24.9-14.2 33.3L88 153.6 12.5 77.3c-7.9-8.3-12.8-19.6-12.8-31.9 0-25.5 20.6-46.1 46-46.2 19.1 0 35.5 11.7 42.4 28.4C94.9 11 111.3-0.8 130.4-0.8&rdquo;
var HEART_COLOR = &lsquo;rgb(226,38,77,1)&rsquo;;
var GRAY_HEART_COLOR = &ldquo;rgb(204,204,204,1)&rdquo;;</p>

<p>var FILL_COLORS = [
  &lsquo;rgba(221,70,136,1)&rsquo;,
  &lsquo;rgba(212,106,191,1)&rsquo;,
  &lsquo;rgba(204,142,245,1)&rsquo;,
  &lsquo;rgba(204,142,245,1)&rsquo;,
  &lsquo;rgba(204,142,245,1)&rsquo;,
  &lsquo;rgba(0,0,0,0)&rsquo;
];</p>

<p>var PARTICLE_COLORS = [
  &lsquo;rgb(158, 202, 250)&rsquo;,
  &lsquo;rgb(161, 235, 206)&rsquo;,
  &lsquo;rgb(208, 148, 246)&rsquo;,
  &lsquo;rgb(244, 141, 166)&rsquo;,
  &lsquo;rgb(234, 171, 104)&rsquo;,
  &lsquo;rgb(170, 163, 186)&rsquo;
]
```</p>

<p>More setup here. We create our heart SVG path to render, and setup a bunch of colors that we will use in our animations later. We need to set stuff up as <code>rgb</code> or <code>rgba</code> so that <code>Animated</code> can interpolate it correctly as at the moment it cannot do hex values.</p>

<p>```</p>

<p>function getXYParticle(total, i, radius) {
  var angle = ( (2*Math.PI) / total ) * i;</p>

<p>  var x = Math.round((radius<em>2) * Math.cos(angle &ndash; (Math.PI/2)));
  var y = Math.round((radius</em>2) * Math.sin(angle &ndash; (Math.PI/2)));
  return {</p>

<pre><code>x: x,
y: y
</code></pre>

<p>  }
}</p>

<p>function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max &ndash; min)) + min;
}</p>

<p>function shuffleArray(array) {</p>

<pre><code>for (var i = array.length - 1; i &gt; 0; i--) {
    var j = Math.floor(Math.random() * (i + 1));
    var temp = array[i];
    array[i] = array[j];
    array[j] = temp;
}
return array;
</code></pre>

<p>}</p>

<p><code>``
Yes more setup.</code>getXYParticle` is a function I&rsquo;ve modified from the fireworks particle blog post I wrote. This essentially distributes a random number of particles around a circle. This is what we will use for the little particles that blow up.</p>

<p>The <code>getRandomInt</code> is pretty self explanatory, but it just returns a random number and we&rsquo;ll use it to create some variance.</p>

<p><code>shuffleArray</code> also just shuffles things in an array, we&rsquo;ll use this to achieve random color effects later.</p>

<h2>Blank Canvas</h2>

<p>```
var ExplodingHearts = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
  animation: new Animated.Value(0) 
};
</code></pre>

<p>  },
  explode: function() {</p>

<pre><code>Animated.timing(this.state.animation, {
  duration: 1500,
  toValue: 28
}).start(() =&gt; {
  this.state.animation.setValue(0);
  this.forceUpdate();
}.bind(this));
</code></pre>

<p>  },</p>

<p>  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
    &lt;TouchableWithoutFeedback onPress={this.explode} style={styles.container}&gt; 
      &lt;View&gt;
        &lt;Surface width={deviceWidth} height={deviceHeight}&gt;
        &lt;/Surface&gt;
      &lt;/View&gt;
    &lt;/TouchableWithoutFeedback&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
});</p>

<p>```</p>

<p>We setup a blank canvas. We need to create our initial <code>animation</code> value so we just do a <code>new Animated.Value(0)</code> in our <code>getInitialState</code>.</p>

<p>We setup a <code>TouchableWithoutFeedback</code> for the ability to use <code>onPress</code> to trigger our animation. We then setup our <code>ART</code> <code>Surface</code> to fill the screen.</p>

<p>Why are we using ART for this? Well it&rsquo;ll make our rendering and animations very efficient, we could use a bunch of <code>Views</code> for this demo but on a large scale with lots of graphics work you should use <code>ART</code></p>

<p>Our <code>explode</code> function kicks off our animation and we do it over 1.5 seconds. We will animate to 28 because that is how many &ldquo;frames&rdquo; we have.</p>

<p>Don&rsquo;t worry about the callback, that&rsquo;s just to reset the animation when it is done, and also the <code>forceUpdate</code> re-renders so we get new random values on each subsequent trigger.</p>

<h2>Render A Heart</h2>

<p>```
<Surface width={deviceWidth} height={deviceHeight}></p>

<pre><code>&lt;AnimatedShape
  d={HEART_SVG}
  x={0}
  y={0}
  scale={1}
  fill={GRAY_HEART_COLOR}
/&gt;
</code></pre>

<p></Surface>
```</p>

<p>We just render a heart, pass in our SVG path, put it at the top left <code>0,0</code> coordinates. Scale is set to 1 and we fill it with our <code>GRAY_HEART_COLOR</code> we setup above.</p>

<h2>Talking Keyframes and Animations</h2>

<p>Before we dive in I want to explain what is about to happen. The original Twitter exploding has 28 frames. Our animation will start at <code>0</code>, and that is our default state. So we&rsquo;ll need to set everything up to default when we start <code>0</code> (initial render).</p>

<p>Then anytime from <code>1</code> to <code>28</code> we will need to design our values so that they produce the correct frame animation.</p>

<p><code>Animated</code> provides a way to interpolate. What that means is given a value, we want it to go through a formula and spit out another value. <code>Animated</code> does this via ranges, which can at times be a little inflexible and we have to hack around it&rsquo;s shortcomings to get desired effects.</p>

<p>All (well almost all) our animations will be interpolating from the single <code>this.state.animation</code> that we created earlier. This just makes it easy to comprehend and layout your animation frames. Because you can then specify that something happens at frame <code>10</code> instead of dividing <code>1/28</code> and say start at <code>0.03571428571</code>.</p>

<h2>Scale it up</h2>

<p>```
render: function() {</p>

<pre><code>var heart_scale = this.state.animation.interpolate({
  inputRange: [0, .01, 6, 10, 12, 18, 28],
  outputRange: [1, 0, .1, 1, 1.2, 1, 1],
  extrapolate: 'clamp'
});

var heart_fill = this.state.animation.interpolate({
  inputRange: [0, 2],
  outputRange: [GRAY_HEART_COLOR, HEART_COLOR],
  extrapolate: 'clamp'
})

var heart_x = heart_scale.interpolate({
  inputRange: [0, 1],
  outputRange: [90, 0],
})

var heart_y = heart_scale.interpolate({
  inputRange: [0, 1],
  outputRange: [75, 0],
})
</code></pre>

<p>}
```</p>

<p>Alright there is a lot going on. Lets break it down.</p>

<p>```</p>

<pre><code>var heart_scale = this.state.animation.interpolate({
  inputRange: [0, .01, 6, 10, 12, 18],
  outputRange: [1, 0, .1, 1, 1.2, 1],
  extrapolate: 'clamp'
});
</code></pre>

<p><code>``
We</code>interpolate<code>on the</code>this.state.animation<code>and give it an</code>inputRange<code>and</code>outputRange` array. These must have the same amount of array values.</p>

<p>I talked about some weird things with <code>Animated</code> and setting up defaults. Well <code>inputRange: [0, .01], outputRange: [1, 0]</code> is the first example.</p>

<p>At 0 we want it to be fully scaled, so output at 1. However as soon as the animation is triggered we want it to be at 0. If we only specified <code>0, 1</code> as the inputRange, it would have the heart scale down from 1 to 0. So specifying the scale inputRange at <code>0 =&gt; .01</code> means it&rsquo;ll basically disappear.</p>

<p>It&rsquo;s essentially a way to make an animation not a whole frame, and or happen virtually immediately.</p>

<p>There is a slight spring in the heart. So from frame <code>10</code> to <code>12</code> it will spring up fast to <code>1.2</code> scale, and then slowly fall back from <code>1.2</code> to <code>1</code> from frames <code>12</code> to <code>18</code>.</p>

<p><code>extrapolate: 'clamp'</code> IS EXTREMELY IMPORTANT HERE. If we want it to just stay the same once it hits frame 18 and not do anything else until the end we must add the clamp. Otherwise it will continue to animate at the current stepping value, so it would scale down below 1 and we don&rsquo;t want that.</p>

<p>```</p>

<pre><code>var heart_fill = this.state.animation.interpolate({
  inputRange: [0, 2],
  outputRange: [GRAY_HEART_COLOR, HEART_COLOR],
  extrapolate: 'clamp'
})
</code></pre>

<p><code>``
We have the heart hidden after frame</code>1<code>, so what this animation says is at</code>0` , inital render, be gray. Anytime from frame 2 and out be red, and always be read.</p>

<p>```</p>

<pre><code>var heart_x = heart_scale.interpolate({
  inputRange: [0, 1],
  outputRange: [90, 0],
})

var heart_y = heart_scale.interpolate({
  inputRange: [0, 1],
  outputRange: [75, 0],
})
</code></pre>

<p>```</p>

<p>This is the one part where we don&rsquo;t want to base things on the key frame. Because there is no <code>transform-origin</code> like there is in CSS, the default scale will scale out to the top left.
That isn&rsquo;t what we want.</p>

<p>So to scale out to the center we need to animate the x/y while scaling, so we interpolate off the interpolate for scale. Remember we default our scale up above to 1, so we are reversing stuff here saying when the scale is scaling down from 0 to 1 adjust to 90 for x and 75 for y.</p>

<p>The 90/75 just has to deal with the current surface center.</p>

<p>```</p>

<pre><code>return (
    &lt;Surface width={deviceWidth} height={deviceHeight}&gt;
        &lt;AnimatedShape
          d={HEART_SVG}
          x={heart_x}
          y={heart_y}
          scale={heart_scale}
          fill={heart_fill}
        /&gt;
    &lt;/Surface&gt;

)
</code></pre>

<p>```</p>

<p>We use our <code>AnimatedShape</code> and pass in the animated values we created. A lot of things I explain up above are the basic concepts through out this tutorial so I wont' explain them again.</p>

<h2>Add a Circle</h2>

<p>```
var AnimatedCircle = React.createClass({displayName: &ldquo;Circle&rdquo;,
  render: function() {</p>

<pre><code>var radius = this.props.radius;
var path = Path().moveTo(0, -radius)
    .arc(0, radius * 2, radius)
    .arc(0, radius * -2, radius)
    .close();
return React.createElement(AnimatedShape, React.__spread({},  this.props, {d: path}));
</code></pre>

<p>  }
});
```</p>

<p>This is taken from previous firework demos and default ReactART, but I&rsquo;ve converted it to use our <code>AnimatedShape</code> we created up above.</p>

<p>```
<Surface width={deviceWidth} height={deviceHeight}>
  <Group x={100} y={200}></p>

<pre><code>&lt;AnimatedShape
  d={HEART_SVG}
  x={heart_x}
  y={heart_y}
  scale={heart_scale}
  fill={heart_fill}
/&gt;
&lt;AnimatedCircle
  x={90}
  y={75}
  radius={150}
  scale={1}
  strokeWidth={3}
  fill="#000"
  opacity={1}
/&gt;
</code></pre>

<p>  </Group>
</Surface>
```</p>

<p>We render an arbitrary circle, at <code>90</code> and <code>75</code> which is the center of our current surface.</p>

<h2>Blow that Circle Up</h2>

<p>```</p>

<pre><code>var circle_scale = this.state.animation.interpolate({
  inputRange: [0, 1, 4],
  outputRange: [0, .3, 1],
  extrapolate: 'clamp'
});

var circle_stroke_width = this.state.animation.interpolate({
  inputRange: [0, 5.99, 6, 7, 10],
  outputRange: [0, 0, 15, 8, 0],
  extrapolate: 'clamp'
});

var circle_fill_colors = this.state.animation.interpolate({
  inputRange: [1, 2, 3, 4, 4.99, 5],
  outputRange: FILL_COLORS,
  extrapolate: 'clamp'
})

var circle_opacity = this.state.animation.interpolate({
  inputRange: [1,9.99, 10],
  outputRange: [1, 1, 0],
  extrapolate: 'clamp'
})
</code></pre>

<p>```</p>

<p>Alright so we scale up, based on the image we scale up to <code>.3</code> in a single frame, then over the course of 3 frames we scale up our circle to a scale of 1.</p>

<p>Our stroke width also changes however we won&rsquo;t always render it. We only need it for a few frames starting at frame 6. So we will specify that the stroke width stays at <code>0</code> from <code>0</code> to frame <code>5.99</code>.</p>

<p>Then over the course of 1 frame it goes to 15 which I chose at random, down to 8, and eventually 0 by frame 10.</p>

<p>We specify a range of colors in the array I talked about in setup. The weird part is that we have to specify the final color a few times before setting the fill to transparent. The reason is that if we specify just the transparent color the purple color will fade out to transparent but we want it to completely disappear and just show the stroke.</p>

<p>So we have to coordinate stroke frames appearing with the fill color disappearing.</p>

<p>Finally our opacity stays 1 until frame 9.99 (the end of our circle stroke) then we kill it on frame 10.</p>

<p>```</p>

<pre><code>&lt;AnimatedCircle
  x={89}
  y={75}
  radius={150}
  scale={circle_scale}
  strokeWidth={circle_stroke_width}
  stroke={FILL_COLORS[2]}
  fill={circle_fill_colors}
  opacity={circle_opacity}
/&gt;
</code></pre>

<p>```
We put those in and because our stroke color is always the same we just reference our fill colors.</p>

<h2>Bunch of Circles Blowing Up</h2>

<p>```
<Surface width={deviceWidth} height={deviceHeight}>
  <Group x={100} y={200}></p>

<pre><code>&lt;AnimatedShape
  d={HEART_SVG}
  x={heart_x}
  y={heart_y}
  scale={heart_scale}
  fill={heart_fill}
/&gt;
&lt;AnimatedCircle
  x={90}
  y={75}
  radius={150}
  scale={circle_scale}
  strokeWidth={circle_stroke_width}
  stroke={FILL_COLORS[2]}
  fill={circle_fill_colors}
  opacity={circle_opacity}
/&gt;

{this.getSmallExplosions(150, {x:90, y:75})}
</code></pre>

<p>  </Group>
</Surface>
```</p>

<p>Alright now we setup our final piece. Calling <code>getSmallExplosions</code> with some data. In our case the radius of our circle and the central coordinates.</p>

<p>```
  getSmallExplosions: function(radius, offset) {</p>

<pre><code>return [0,1,2,3,4,5,6].map((v, i, t) =&gt; {

  var scaleOut = this.state.animation.interpolate({
    inputRange: [0, 5.99, 6, 13.99, 14, 21],
    outputRange: [0, 0, 1, 1, 1, 0],
    extrapolate: 'clamp'
  });

  var moveUp = this.state.animation.interpolate({
    inputRange: [0, 5.99, 14],
    outputRange: [0, 0, -15],
    extrapolate: 'clamp'
  });

  var moveDown = this.state.animation.interpolate({
    inputRange: [0, 5.99, 14],
    outputRange: [0, 0, 15],
    extrapolate: 'clamp'
  });

  var color_top_particle = this.state.animation.interpolate({
    inputRange: [6, 8, 10, 12, 17, 21],
    outputRange: shuffleArray(PARTICLE_COLORS)
  })

  var color_bottom_particle = this.state.animation.interpolate({
    inputRange: [6, 8, 10, 12, 17, 21],
    outputRange: shuffleArray(PARTICLE_COLORS)
  })

  var position = getXYParticle(7, i, radius)

  return (
    &lt;Group 
      x={position.x + offset.x } 
      y={position.y + offset.y} 
      rotation={getRandomInt(0, 40) * i}
    &gt;
      &lt;AnimatedCircle 
        x={moveUp}
        y={moveUp}
        radius={15} 
        scale={scaleOut} 
        fill={color_top_particle} 
      /&gt;
      &lt;AnimatedCircle 
        x={moveDown}
        y={moveDown}
        radius={8} 
        scale={scaleOut} 
        fill={color_bottom_particle} 
      /&gt;
    &lt;/Group&gt;
  )
}, this)
</code></pre>

<p>  },
```</p>

<p>Not going to explain this one too indepth or I&rsquo;ll keep repeating myself. We create a bunch of animations for each particle but add some randomness into the mix. We call <code>shuffleArray</code> on our <code>PARTICLE_COLORS</code> so over the course of the frames it is active it&rsquo;ll animate to random colors for each particle.</p>

<p>Also we add a bit of <code>rotation</code> to the group, so when we animate the particles up/down they&rsquo;ll go in all different directions.</p>

<h2>Done</h2>

<p>Now you too can add a new interaction that all of your users will despise! No this isn&rsquo;t a perfect replica of the the Twiter animation because I added color variance and some random rotation to the small exploding/shrinking circles.</p>

<p><img class="<a" src="href="http://i.imgur.com/lMOxqIL.gif">http://i.imgur.com/lMOxqIL.gif</a>" title="That is hot" ></p>

<h3>Interactive Demo at <a href="https://rnplay.org/apps/nJjHdw">https://rnplay.org/apps/nJjHdw</a></h3>

<p>I&rsquo;m not posting the full code, this is a long one. Just check it out on RNPlay.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native - How to make Instagram]]></title>
    <link href="http://browniefed.com/blog/2015/11/02/react-native-how-to-make-instagram/"/>
    <updated>2015-11-02T04:48:00-08:00</updated>
    <id>http://browniefed.com/blog/2015/11/02/react-native-how-to-make-instagram</id>
    <content type="html"><![CDATA[<h2>OUTDATED</h2>

<p>This blog is a bit outdated, and uses gl-react-native 1.3. I highly recommend checking out <a href="https://github.com/gre/gl-react-image-effects">https://github.com/gre/gl-react-image-effects</a> which was inspired by this post and uses gl-react-native 2.*!</p>

<h2>Intro</h2>

<p>Instagram is a fantastic app and a great concept to model after for learning fragment shaders. We won&rsquo;t get too deep into fragment shaders but I&rsquo;ll take a little bit about what they are and point you to some resources.</p>

<p>We&rsquo;ll take advantage of the awesome <a href="https://github.com/ProjectSeptemberInc/gl-react-native">gl-react-native</a> component library by <a href="https://twitter.com/greweb">GaÃ«tan Renaudeau</a>.</p>

<p>There are some fantastic resources on basic concepts of fragment shaders, check them out below. Much of the fragment shader code we&rsquo;ll write is taken from there and or slightly modified! I am not an expert on this stuff, I&rsquo;m just playing around.</p>

<ul>
<li>GL React documentation: <a href="https://projectseptemberinc.gitbooks.io/gl-react/content/">https://projectseptemberinc.gitbooks.io/gl-react/content/</a></li>
<li>Great explanation of fragment shader effects: <a href="https://github.com/yulu/GLtext">https://github.com/yulu/GLtext</a></li>
<li>Some Instagram fragment shader pre-sets: <a href="https://github.com/yulu/Instagram_Filter/tree/master/res/raw">https://github.com/yulu/Instagram_Filter/tree/master/res/raw</a></li>
<li>More Instagram pre-sets however they&rsquo;re in CSS: <a href="http://una.im/CSSgram/">http://una.im/CSSgram/</a></li>
</ul>


<h2>What are we building</h2>

<p><img class="<a" src="href="http://i.imgur.com/IQDx6Ls.gif">http://i.imgur.com/IQDx6Ls.gif</a>" title="More saturation please" ></p>

<!-- more -->


<h2>Concept</h2>

<p>We&rsquo;ll write a fragment shader that takes various values and adjust a child image. We&rsquo;ll throw some sliders on there so the user can control it.</p>

<h2>Disclaimer</h2>

<p>I have no clue if this is the correct way to do this. Once again, I&rsquo;m just playing around. The presets that I linked to above may not output the exact filter you are expecting. Yes you may have to adjust the shader code to make it perfectly match whatever Instagram actually does. Don&rsquo;t ask me to do this for you.</p>

<p>Want to save off what you did? Check out <a href="https://github.com/jsierles/react-native-view-snapshot">https://github.com/jsierles/react-native-view-snapshot</a> or check out <a href="https://github.com/BradLarson/GPUImage">https://github.com/BradLarson/GPUImage</a> for some powerful image manipulations on iOS!</p>

<h2>Install</h2>

<p>You&rsquo;ll need to do <code>npm install gl-react-native</code> and also add it to Xcode. <code>gl-react-native</code> has instructions on how to do that in the README at <a href="https://github.com/ProjectSeptemberInc/gl-react-native">https://github.com/ProjectSeptemberInc/gl-react-native</a>.</p>

<h2>Setup</h2>

<p>```
var React = require(&lsquo;react-native&rsquo;);
var GL = require(&lsquo;gl-react-native&rsquo;);</p>

<p>var {
  AppRegistry,
  StyleSheet,
  Text,
  Image,
  View,
  ScrollView,
  SliderIOS
} = React;
```</p>

<p>Nothing too special here.</p>

<h2>Create a GL.View</h2>

<p>```
var Instagram = GL.createComponent(
  ({ children, &hellip;rest }) =>
  &lt;GL.View</p>

<pre><code>{...rest}
shader={shaders.instagram}
uniforms=&gt;
&lt;GL.Uniform name="tex"&gt;{children}&lt;/GL.Uniform&gt;
</code></pre>

<p>  &lt;/GL.View>
, { displayName: &ldquo;Instagram&rdquo; });</p>

<p>```</p>

<p><code>GL.createComponent</code> takes a function that returns and creates everything you need to render. It then provides the props to the function when it wants to render.</p>

<p><code>GL.View</code> is what receives the properties and the shader. The <code>GL.Uniform</code> is given a name that will be provided to the shader. The main purpose is to provide a texture to grab pixels from to feed the shader.</p>

<p>If you wanted a blank canvas to render arbitrary shaders then you would not need the <code>GL.Uniform</code>!</p>

<h2>Create an empty Shader</h2>

<p>```
const shaders = GL.Shaders.create({
  instagram: {</p>

<pre><code>frag: `
  void main() {

  }
`
</code></pre>

<p>  }
});</p>

<p>```</p>

<p>We call <code>GL.Shaders.create</code>. At some point <code>gl-react-native</code> may support Vertex shaders instead of just Fragment shaders. So we scope our <code>instagram</code> shader with another key <code>frag</code> and use ES2015/ES6 template strings so we can quickly edit and manipulate the shader rather than having to deal with quotes.</p>

<h2>Render Empty</h2>

<p>```
var rn_instagram = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
  width:0,
  height: 0,
};
</code></pre>

<p>  },
  renderWithDimensions: function(layout) {</p>

<pre><code>var {
  width,
  height
} = layout.nativeEvent.layout;
this.setState({
  width,
  height
})
</code></pre>

<p>  },
  getImage: function() {</p>

<pre><code>return (
  &lt;Instagram 
    width={this.state.width}
    height={this.state.height}
  &gt;
    &lt;Image
      source=
      style={styles.cover}
      resizeMode="cover"
    /&gt;
  &lt;/Instagram&gt;

)
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
    &lt;View style={styles.container} onLayout={this.renderWithDimensions}&gt;
      { this.state.width ? this.getImage() : null}
    &lt;/View&gt;
  &lt;/View&gt;
)
</code></pre>

<p>  }
});
<code>``
One limitation of</code>gl-react-native` is that width/height are almost always required. I say almost because I don&rsquo;t know for sure, but so far it seems to always be required.</p>

<p>So what that means is we need to create a container with <code>flex:1</code> so we can then use the <code>onLayout</code> function to get the measured width/height of whatever <code>flex:1</code> translates to. Once it is set in our <code>state</code> then we can render our <code>Instagram</code> component with our <code>Image</code>.</p>

<p><code>Image</code> has a <code>cover</code> class and <code>resizeMode</code> set to cover.
Our cover class looks like so</p>

<p>```
  cover: {</p>

<pre><code>position: 'absolute',
top: 0,
left: 0,
right: 0,
bottom: 0
</code></pre>

<p>  }
```
This will have the image cover and resize to fit the space provided.</p>

<h2>Create the master shader</h2>

<p>```
const shaders = GL.Shaders.create({
  instagram: {</p>

<pre><code>frag: `
  precision highp float;
  varying vec2 uv;
  uniform sampler2D tex;

  uniform float saturation;
  uniform float brightness;
  uniform float contrast;
  uniform float hue;
  uniform float gray;
  uniform float sepia;
  uniform float mixFactor;

  const vec3 W = vec3(0.2125, 0.7154, 0.0721);
  const mat3 rgb2yiq = mat3(0.299, 0.587, 0.114, 0.595716, -0.274453, -0.321263, 0.211456, -0.522591, 0.311135);
  const mat3 yiq2rgb = mat3(1.0, 0.9563, 0.6210, 1.0, -0.2721, -0.6474, 1.0, -1.1070, 1.7046);
  const vec3 SEPIA = vec3(1.2, 1.0, 0.8);

  vec3 BrightnessContrastSaturation(vec3 color, float brt, float con, float sat)
  {
    vec3 black = vec3(0., 0., 0.);
    vec3 middle = vec3(0.5, 0.5, 0.5);
    float luminance = dot(color, W);
    vec3 gray = vec3(luminance, luminance, luminance);

    vec3 brtColor = mix(black, color, brt);
    vec3 conColor = mix(middle, brtColor, con);
    vec3 satColor = mix(gray, conColor, sat);
    return satColor;
  }

  vec3 multiplyBlender(vec3 Color, vec3 filter){
    vec3 filter_result;
    float luminance = dot(filter, W);

    if(luminance &lt; 0.5)
      filter_result = 2. * filter * Color;
    else
      filter_result = Color;

    return filter_result;
  }

  vec3 ovelayBlender(vec3 Color, vec3 filter){
    vec3 filter_result;

    float luminance = dot(filter, W);

    if(luminance &lt; 0.5)
      filter_result = 2. * filter * Color;
    else
      filter_result = 1. - (1. - (2. *(filter - 0.5)))*(1. - Color);

    return filter_result;
  }

  vec3 applyHue(vec3 Color, float h) {
    vec3 yColor = rgb2yiq * Color;
    float originalHue = atan(yColor.b, yColor.g);
    float finalHue = originalHue + (h);
    float chroma = sqrt(yColor.b*yColor.b+yColor.g*yColor.g);
    vec3 yFinalColor = vec3(yColor.r, chroma * cos(finalHue), chroma * sin(finalHue));
    return vec3(yiq2rgb*yFinalColor);
  }

  vec3 applyGray(vec3 Color, float g) {
    float gray = dot(Color, vec3(0.299, 0.587, 0.114));
    return mix(Color, vec3(gray, gray, gray), g);
  }

  vec3 applySepia(vec3 Color, float s) {
    float gray = dot(Color, vec3(0.299, 0.587, 0.114));
    return mix(Color, vec3(gray) * SEPIA, s);
  }


  void main() {
    vec2 st = uv.st;
    vec3 irgb = texture2D(tex, st).rgb;
    vec3 filter = texture2D(tex, st).rgb;

    vec3 bcs_result = BrightnessContrastSaturation(irgb, brightness, contrast, saturation);
    vec3 hue_result = applyHue(bcs_result, hue);
    vec3 sepia_result = applySepia(hue_result, sepia);
    vec3 gray_result = applyGray(sepia_result, gray);

    vec3 after_filter = mix(gray_result, multiplyBlender(gray_result, filter), mixFactor);

    gl_FragColor = vec4(after_filter, 1.);
  }
`
</code></pre>

<p>  }
});</p>

<p>```</p>

<p>I wont' go too indepth here since I don&rsquo;t know a ton about what is happening. But quick explanation.</p>

<p>```</p>

<pre><code>varying vec2 uv;
uniform sampler2D tex;

uniform float saturation;
uniform float brightness;
uniform float contrast;
uniform float hue;
uniform float gray;
uniform float sepia;
uniform float mixFactor;
</code></pre>

<p><code>``
When we declare</code>uniform` in our shader it means that it is a value that is coming in from the outside. In our case from the JS world to the Obj-C world and into our shader.</p>

<p>We need to define it&rsquo;s type, in our case it&rsquo;s a <code>float</code> for most input values.</p>

<p>The <code>varying vec2 uv</code> is what I believe is the outside world providing the texture coordinates of what  is currently being processed. That way you can do specific things based on the coordinates you are at&hellip; like transforming a pixel color from one thing to another, adding things like vignettes, or whatever else you want to do.</p>

<p>In our <code>texture</code> case we receive a <code>sampler2D</code>. This has a bunch of data that allows us to extract a <code>rgb</code> out of it using our coordinates from above.
This is where we get the <code>rgb</code> value to manipulate based upon our shader.</p>

<p>We get that <code>rgb</code> value here <code>texture2D(tex, st).rgb;</code>. Which is assigned to a <code>vec3</code> which just is an arbitrary container of <code>3</code> values. In JavaScript just think of it as an array like <code>[1,2,3]</code> but can be referenced like an object with <code>.</code> notation.</p>

<p>```
void main() {</p>

<pre><code>vec2 st = uv.st;
vec3 irgb = texture2D(tex, st).rgb;
vec3 filter = texture2D(tex, st).rgb;

vec3 bcs_result = BrightnessContrastSaturation(irgb, brightness, contrast, saturation);
vec3 hue_result = applyHue(bcs_result, hue);
vec3 sepia_result = applySepia(hue_result, sepia);
vec3 gray_result = applyGray(sepia_result, gray);

vec3 after_filter = mix(gray_result, multiplyBlender(gray_result, filter), mixFactor);

gl_FragColor = vec4(after_filter, 1.);
</code></pre>

<p>}
```</p>

<p>Our main function is called and is where things start. We extract our coordinates from <code>uv</code>. Get our <code>rgb</code> value at those specific coordiantes.</p>

<p>Then pass it through our functions. Each function takes one or more of our <code>uniform</code> values that gets passed in. It then returns a <code>vec3</code> which is just an <code>rgb</code> color value. That color then gets passed into the next function.</p>

<p>We essentially just keep passing and mutating an <code>rgb</code> color value until the end.</p>

<p>Eventually <code>gl_FragColor</code> is where we spit out our final color for that specific coordinate that our shader was called with.</p>

<h2>Add State</h2>

<p>```
  getInitialState: function() {</p>

<pre><code>return {
  width:0,
  height: 0,
  saturation: 1,
  brightness: 1,
  contrast: 1,
  hue: 0,
  sepia: 0,
  gray: 0,
  mixFactor: 0
};
</code></pre>

<p>  },
```</p>

<p>We should fix up our state to have all the values that our shader needs. In our case we just make up a values for each shader and set random defaults.</p>

<h2>Fix the GL.View</h2>

<p>```
var Instagram = GL.createComponent(
  ({ brightness, saturation, contrast, hue, gray, sepia, mixFactor, children, &hellip;rest }) =>
  &lt;GL.View</p>

<pre><code>{...rest}
shader={shaders.instagram}
uniforms=&gt;
&lt;GL.Uniform name="tex"&gt;{children}&lt;/GL.Uniform&gt;
</code></pre>

<p>  &lt;/GL.View>
, { displayName: &ldquo;Instagram&rdquo; });
```</p>

<p>Now that You can see we now pass in all the necessary uniforms. If they exist here they must exist in your shader. If they exist in your shader and aren&rsquo;t used you will get an error! Or vice versa. Ultimately if you forget something you&rsquo;ll know because your shader won&rsquo;t compile and you&rsquo;ll get a red error screen like you may be used to.</p>

<p>```
getImage: function() {</p>

<pre><code>return (
  &lt;Instagram 
    brightness={this.state.brightness}
    saturation={this.state.saturation}
    contrast={this.state.contrast}
    hue={this.state.hue}
    gray={this.state.gray}
    sepia={this.state.sepia}
    mixFactor={this.state.mixFactor}
    width={this.state.width}
    height={this.state.height}
  &gt;
    &lt;Image
      source=
      style={styles.cover}
      resizeMode="cover"
    /&gt;
  &lt;/Instagram&gt;

)
</code></pre>

<p>  },
```</p>

<p>Pass in our state to the <code>GL.View</code> we created. We technically could have just used the <code>...</code> spread operator here but I&rsquo;m being explicity for the sake of this tutorial.</p>

<h2>Add Controls</h2>

<p>```</p>

<pre><code>    &lt;ScrollView style={styles.container}&gt;
      &lt;View&gt;
        &lt;Text&gt;Blend Factor: {this.state.mixFactor}&lt;/Text&gt;
        &lt;SliderIOS
          value={this.state.mixFactor}
          minimumValue={0}
          maximumValue={2}
          onValueChange={(mixFactor) =&gt; this.setState({mixFactor})}
        /&gt;
      &lt;/View&gt;
      &lt;View&gt;
        &lt;Text&gt;Brightness: {this.state.brightness}&lt;/Text&gt;
        &lt;SliderIOS
          value={this.state.brightness}
          minimumValue={0}
          maximumValue={3}
          onValueChange={(brightness) =&gt; this.setState({brightness})}
        /&gt;
      &lt;/View&gt;
    //OTHER CONTROLS
    &lt;/ScrollView&gt;
</code></pre>

<p>```</p>

<p>Nothing too crazy here either. We just setup our controls. When stuff changes we&rsquo;ll set state with the new value. The <code>minimumValue</code> and <code>maximumValue</code> I chose at complete randomness.</p>

<h2>DONE!</h2>

<p>We can finally control different properties of shaders that wrap arbitrary images. Go us. Go Shaders. Go OpenGLES 2.X spec.</p>

<h3>As always, live demo on <a href="https://rnplay.org/apps/I9G83g">https://rnplay.org/apps/I9G83g</a></h3>

<p><img class="<a" src="href="http://i.imgur.com/IQDx6Ls.gif">http://i.imgur.com/IQDx6Ls.gif</a>" title="Guess the city and win" ></p>

<h2>Full Code</h2>

<p></p>

<p>```
var React = require(&lsquo;react-native&rsquo;);
var GL = require(&lsquo;gl-react-native&rsquo;);</p>

<p>var {
  AppRegistry,
  StyleSheet,
  Text,
  Image,
  Dimensions,
  View,
  ScrollView,
  SliderIOS
} = React;</p>

<p>var {
  width,
  height
} = Dimensions.get(&lsquo;window&rsquo;);</p>

<p>var rn_instagram = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
  width:0,
  height: 0,
  saturation: 1,
  brightness: 1,
  contrast: 1,
  hue: 0,
  sepia: 0,
  gray: 0,
  mixFactor: 0
};
</code></pre>

<p>  },
  renderWithDimensions: function(layout) {</p>

<pre><code>var {
  width,
  height
} = layout.nativeEvent.layout;
this.setState({
  width,
  height
})
</code></pre>

<p>  },
  getImage: function() {</p>

<pre><code>return (
  &lt;Instagram 
    brightness={this.state.brightness}
    saturation={this.state.saturation}
    contrast={this.state.contrast}
    hue={this.state.hue}
    gray={this.state.gray}
    sepia={this.state.sepia}
    mixFactor={this.state.mixFactor}
    width={this.state.width}
    height={this.state.height}
  &gt;
    &lt;Image
      source={{uri: 'http://i.imgur.com/dSIa9jl.jpg'}}
      style={styles.cover}
      resizeMode="cover"
    /&gt;
  &lt;/Instagram&gt;

)
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
    &lt;View style={styles.container} onLayout={this.renderWithDimensions}&gt;
      { this.state.width ? this.getImage() : null}
    &lt;/View&gt;
    &lt;ScrollView style={styles.container}&gt;
      &lt;View&gt;
        &lt;Text&gt;Blend Factor: {this.state.mixFactor}&lt;/Text&gt;
        &lt;SliderIOS
          value={this.state.mixFactor}
          minimumValue={0}
          maximumValue={2}
          onValueChange={(mixFactor) =&gt; this.setState({mixFactor})}
        /&gt;
      &lt;/View&gt;
      &lt;View&gt;
        &lt;Text&gt;Brightness: {this.state.brightness}&lt;/Text&gt;
        &lt;SliderIOS
          value={this.state.brightness}
          minimumValue={0}
          maximumValue={3}
          onValueChange={(brightness) =&gt; this.setState({brightness})}
        /&gt;
      &lt;/View&gt;
      &lt;View&gt;
        &lt;Text&gt;Saturation: {this.state.saturation}&lt;/Text&gt;
        &lt;SliderIOS
          value={this.state.saturation}
          minimumValue={0}
          maximumValue={3}
          onValueChange={(saturation) =&gt; this.setState({saturation})}
        /&gt;
      &lt;/View&gt;
      &lt;View&gt;
        &lt;Text&gt;Contrast: {this.state.contrast}&lt;/Text&gt;
        &lt;SliderIOS
          value={this.state.contrast}
          minimumValue={0}
          maximumValue={3}
          onValueChange={(contrast) =&gt; this.setState({contrast})}
        /&gt;
      &lt;/View&gt;
      &lt;View&gt;
        &lt;Text&gt;Sepia: {this.state.sepia}&lt;/Text&gt;
        &lt;SliderIOS
          value={this.state.sepia}
          minimumValue={0}
          maximumValue={1}
          onValueChange={(sepia) =&gt; this.setState({sepia})}
        /&gt;
      &lt;/View&gt;
      &lt;View&gt;
        &lt;Text&gt;Grayscale: {this.state.gray}&lt;/Text&gt;
        &lt;SliderIOS
          value={this.state.gray}
          minimumValue={0}
          maximumValue={1}
          onValueChange={(gray) =&gt; this.setState({gray})}
        /&gt;
      &lt;/View&gt;
      &lt;View&gt;
        &lt;Text&gt;Hue: {this.state.hue}&lt;/Text&gt;
        &lt;SliderIOS
          value={this.state.hue}
          minimumValue={0}
          maximumValue={10}
          onValueChange={(hue) =&gt; this.setState({hue})}
        /&gt;
      &lt;/View&gt;
    &lt;/ScrollView&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
});</p>

<p>var styles = StyleSheet.create({
  container: {</p>

<pre><code>flex: 1
</code></pre>

<p>  },
  cover: {</p>

<pre><code>position: 'absolute',
top: 0,
left: 0,
right: 0,
bottom: 0
</code></pre>

<p>  }</p>

<p>});</p>

<p>const shaders = GL.Shaders.create({
  instagram: {</p>

<pre><code>frag: `
  precision highp float;
  varying vec2 uv;
  uniform sampler2D tex;
  uniform float saturation;
  uniform float brightness;
  uniform float contrast;
  uniform float hue;
  uniform float gray;
  uniform float sepia;
  uniform float mixFactor;

  const vec3 W = vec3(0.2125, 0.7154, 0.0721);
  const mat3 rgb2yiq = mat3(0.299, 0.587, 0.114, 0.595716, -0.274453, -0.321263, 0.211456, -0.522591, 0.311135);
  const mat3 yiq2rgb = mat3(1.0, 0.9563, 0.6210, 1.0, -0.2721, -0.6474, 1.0, -1.1070, 1.7046);
  const vec3 SEPIA = vec3(1.2, 1.0, 0.8);

  vec3 BrightnessContrastSaturation(vec3 color, float brt, float con, float sat)
  {
    vec3 black = vec3(0., 0., 0.);
    vec3 middle = vec3(0.5, 0.5, 0.5);
    float luminance = dot(color, W);
    vec3 gray = vec3(luminance, luminance, luminance);

    vec3 brtColor = mix(black, color, brt);
    vec3 conColor = mix(middle, brtColor, con);
    vec3 satColor = mix(gray, conColor, sat);
    return satColor;
  }

  vec3 multiplyBlender(vec3 Color, vec3 filter){
    vec3 filter_result;
    float luminance = dot(filter, W);

    if(luminance &lt; 0.5)
      filter_result = 2. * filter * Color;
    else
      filter_result = Color;

    return filter_result;
  }

  vec3 ovelayBlender(vec3 Color, vec3 filter){
    vec3 filter_result;

    float luminance = dot(filter, W);

    if(luminance &lt; 0.5)
      filter_result = 2. * filter * Color;
    else
      filter_result = 1. - (1. - (2. *(filter - 0.5)))*(1. - Color);

    return filter_result;
  }

  vec3 applyHue(vec3 Color, float h) {
    vec3 yColor = rgb2yiq * Color;
    float originalHue = atan(yColor.b, yColor.g);
    float finalHue = originalHue + (h);
    float chroma = sqrt(yColor.b*yColor.b+yColor.g*yColor.g);
    vec3 yFinalColor = vec3(yColor.r, chroma * cos(finalHue), chroma * sin(finalHue));
    return vec3(yiq2rgb*yFinalColor);
  }

  vec3 applyGray(vec3 Color, float g) {
    float gray = dot(Color, vec3(0.299, 0.587, 0.114));
    return mix(Color, vec3(gray, gray, gray), g);
  }

  vec3 applySepia(vec3 Color, float s) {
    float gray = dot(Color, vec3(0.299, 0.587, 0.114));
    return mix(Color, vec3(gray) * SEPIA, s);
  }


  void main() {
    vec2 st = uv.st;
    vec3 irgb = texture2D(tex, st).rgb;
    vec3 filter = texture2D(tex, st).rgb;

    vec3 bcs_result = BrightnessContrastSaturation(irgb, brightness, contrast, saturation);
    vec3 hue_result = applyHue(bcs_result, hue);
    vec3 sepia_result = applySepia(hue_result, sepia);
    vec3 gray_result = applyGray(sepia_result, gray);

    vec3 after_filter = mix(gray_result, multiplyBlender(gray_result, filter), mixFactor);

    gl_FragColor = vec4(after_filter, 1.);
  }
`
</code></pre>

<p>  }
});</p>

<p>var Instagram = GL.createComponent(
  ({ brightness, saturation, contrast, hue, gray, sepia, mixFactor, children, &hellip;rest }) =>
  &lt;GL.View</p>

<pre><code>{...rest}
shader={shaders.instagram}
uniforms={{ brightness, saturation, contrast, hue, gray, sepia, mixFactor }}&gt;
&lt;GL.Uniform name="tex"&gt;{children}&lt;/GL.Uniform&gt;
</code></pre>

<p>  &lt;/GL.View>
, { displayName: &ldquo;Instagram&rdquo; });</p>

<p>module.exports = rn_instagram;</p>

<p>AppRegistry.registerComponent(&lsquo;rn_instagram&rsquo;, () => rn_instagram);</p>

<p>```
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native - Recreating the Apple TV Icons]]></title>
    <link href="http://browniefed.com/blog/2015/10/23/react-native-recreating-the-apple-tv-icons/"/>
    <updated>2015-10-23T20:53:00-07:00</updated>
    <id>http://browniefed.com/blog/2015/10/23/react-native-recreating-the-apple-tv-icons</id>
    <content type="html"><![CDATA[<p>I had attempted to recreate this in the past but could never come up with anything elegant. I saw this post not too long ago <a href="https://medium.com/@nashvail/recreating-the-apple-tv-icons-in-javascript-and-css-eec306d41617">Recreating the Apple TV icons in JavaScript and CSS</a> by <a href="https://twitter.com/NashVail">Nash Vail</a>.</p>

<p>He then went on to create a <a href="https://github.com/nashvail/ATVIcons">jQuery plugin</a> to accomplish the effect. After reading the source and viewing the demos, it turns out re-making this in React Native is trivial.</p>

<p>So read the article, check out the <a href="http://nashvail.me/ATVIcons/">live demo</a> here and then we&rsquo;ll continue on.</p>

<h2>What are we building</h2>

<p><img class="<a" src="href="http://i.imgur.com/3TLQtmE.gif">http://i.imgur.com/3TLQtmE.gif</a>" title="No 3D glasses required" ></p>

<!-- more -->


<h2>Setup</h2>

<p>```
var React = require(&lsquo;react-native&rsquo;);
var {
  AppRegistry,
  StyleSheet,
  Text,
  View,
  PanResponder,
  Image,
  Animated
} = React;</p>

<p>var width = 280;
var height = 150;</p>

<p>```</p>

<p>Yes, Animated again. Can you believe I almost wrote this tutorial with out it? I had a <code>setState</code> implementation but I didn&rsquo;t take the lazy, non-performant way out, I built it with performance in mind! No thanks necessary, it would have weighed on my conscience had I released an animated tutorial using <code>setState</code>.</p>

<p>The card we&rsquo;re animating is <code>280</code> by <code>150</code>. It&rsquo;ll play into our calculations. This could be made dynamic though.</p>

<h2>Defaults</h2>

<p>```
  getInitialState: function() {</p>

<pre><code>return {
  maxRotation: 12,
  maxTranslation: 6,
  perspective: 800
};
</code></pre>

<p>  },
<code>``
In our</code>getInitialState<code>we'll set up some defaults. We'll set our</code>maxRotation<code>to 12, this means the card can only rotate a maximum of 12 degrees.</code>maxTranslation` is the same thing, it can only shift the card a maximum of 6.</p>

<p>You can read more about <code>perspective</code> here <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/perspective">https://developer.mozilla.org/en-US/docs/Web/CSS/perspective</a>.</p>

<p><code>
The perspective CSS property determines the distance between the z=0 plane and the user in order to give to the 3D-positioned element some perspective
</code></p>

<h2>Borrowed Function</h2>

<p><code>
function calculatePercentage(offset, dimension) {
  return ((-2 / dimension) * offset) + 1;
}
</code></p>

<p>This is the magic formula. Based upon what we pass in here it will spit out a value between <code>-1</code> and <code>1</code>. We use this to multiply by our <code>maxRotation</code> or <code>maxTranslation</code> to get the degree to apply. We won&rsquo;t do the multiplication though, we&rsquo;ll let <code>Animated</code> take care of that.</p>

<h2>PanResponder and Calculations</h2>

<p>```
  componentWillMount: function() {</p>

<pre><code>this._animations = {
  xRotationPercentage: new Animated.Value(0),
  yRotationPercentage: new Animated.Value(0),
  xTranslationPercentage: new Animated.Value(0),
  yTranslationPercentage: new Animated.Value(0)
}

this._panResponder = PanResponder.create({
  onStartShouldSetPanResponder: (evt, gestureState) =&gt; true,
  onStartShouldSetPanResponderCapture: (evt, gestureState) =&gt; true,
  onMoveShouldSetPanResponder: (evt, gestureState) =&gt; true,
  onMoveShouldSetPanResponderCapture: (evt, gestureState) =&gt; true,
  onPanResponderMove: (e, gestureState) =&gt; {
    e.persist();
    var {
      locationX: x,
      locationY: y
    } = e.nativeEvent;

    this._animations.xRotationPercentage.setValue(calculatePercentage(y, height));
    this._animations.yRotationPercentage.setValue(calculatePercentage(x, width) * -1);
    this._animations.xTranslationPercentage.setValue(calculatePercentage(x, width));
    this._animations.yTranslationPercentage.setValue(calculatePercentage(y, height));
  }
})
</code></pre>

<p>  },
<code>``
Alright there is sort of a lot here but not really. We setup an object to hold our animations called</code>this._animations<code>. We then setup our</code>PanResponder<code>defaults, and of course the one we care about is</code>onPanResponderMove`.</p>

<p>Here when it moves we get the <code>locationX</code> and <code>locationY</code> which is the <code>x/y</code> values relative to the <code>component</code> we attach it too.</p>

<p>Finally we run our calculations and call <code>setValue</code> on each <code>Animated.Value</code>. This is basically what <code>Animated.event</code> is doing under the hood for us, but instead we are performing calculations and calling <code>setValue</code> ourselves.</p>

<h2>Render-me-timbers</h2>

<p>```
  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
    &lt;View style= {...this._panResponder.panHandlers}&gt;
      &lt;Card  
          style=
          stackingFactor={1}
          {...this.state}
          {...this._animations}
      &gt;
        &lt;Card 
          style=
          stackingFactor={1.4}
          {...this.state}
          {...this._animations}
        &gt;
          &lt;Card
            style= 
            stackingFactor={1.8}
            {...this.state}
            {...this._animations}
          /&gt;
        &lt;/Card&gt;
      &lt;/Card&gt;
    &lt;/View&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
<code>``
We'll get to the card component in a second. We attach our</code>PanResponder<code>we created to the outer wrap object. Then we nest each card. This is crucial otherwise our layer will 3D transform behind the red layer.
So this is forcing the</code>Card` to sit in front of the previous card no matter what. I don&rsquo;t know if this is true, but it was happening to me and this is how I fixed it.</p>

<p>We use a prop called <code>stackingFactor</code>. All this does is slightly amplify that cards movements more causing a slight offset and the 3D effect.</p>

<p>```
var Card = React.createClass({
  componentWillMount: function() {</p>

<p>  var translateMax = (this.props.maxTranslation * this.props.stackingFactor);
  var rotateMax = this.props.maxRotation;</p>

<pre><code>this._xRotation = this.props.xRotationPercentage.interpolate({
  inputRange: [-1, 1],
  outputRange: [ (rotateMax * -1) + 'deg', rotateMax + 'deg'],
  extrapolate: 'clamp'
});

this._yRotation = this.props.yRotationPercentage.interpolate({
  inputRange: [-1, 1],
  outputRange: [ (rotateMax * -1) + 'deg', rotateMax + 'deg'],
  extrapolate: 'clamp'
});

this._translateX = this.props.xTranslationPercentage.interpolate({
  inputRange: [-1, 1],
  outputRange: [(translateMax * -1), translateMax],
  extrapolate: 'clamp'
})

this._translateY = this.props.yTranslationPercentage.interpolate({
  inputRange: [-1, 1],
  outputRange: [(translateMax * -1), translateMax],
  extrapolate: 'clamp'
})
</code></pre>

<p>  },</p>

<p>  getTransform:function() {</p>

<pre><code>return [
  {perspective: this.props.perspective},
  {rotateX: this._xRotation},
  {rotateY: this._yRotation},
  {translateX: this._translateX},
  {translateY: this._translateY},
]
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
  &lt;Animated.View 
    {...this.props} 
    style={[this.props.style, {transform: this.getTransform()}]}
  &gt;
    {this.props.children}
  &lt;/Animated.View&gt;
)
</code></pre>

<p>  }
})</p>

<p>```</p>

<p>That&rsquo;s a lot of <code>interpolate</code>! Well not really they&rsquo;re mostly all doing the same thing here. Remember when I said our calculations up above could return a percentage between <code>-1</code> and <code>1</code>.</p>

<p>Well all we have to do is specify that as our <code>inputRange</code> and then our <code>outputRange</code> is just whatever our small <code>maxRotation</code> or <code>maxTranslation</code>. <code>Animated</code> will take care of all the multiplication for us! Thanks Animated!</p>

<p>The <code>extrapolate: 'clamp'</code> is EXTREMELY important. Without it the values will go past their maximums. This can be accomplished since <code>locationX</code> and <code>locationY</code> could go beyond the <code>width</code> and <code>height</code> of the container. Long story short, <code>extrapolate: 'clamp'</code> your interpolations!</p>

<p>You can see how the <code>translateMax</code> is affected when our <code>stackingFactor</code> is larger.</p>

<p><code>
  var translateMax = (this.props.maxTranslation * this.props.stackingFactor);
</code></p>

<p>Our <code>getTransform</code> just maps the appropriate animated value to it&rsquo;s transform. Also so our <code>Card</code> can be nested we have to specify <code>{this.props.children}</code>.</p>

<h2>Look Ma' no setState</h2>

<p>That&rsquo;s right. We&rsquo;ve used all <code>Animated</code> here. No diffs are happening to cause re-render, so our animations should be quite performant.</p>

<h2>Done</h2>

<p>This is currently only supported on iOS but appropriate support for Android is being added here <a href="https://github.com/facebook/react-native/pull/3522">https://github.com/facebook/react-native/pull/3522</a></p>

<h3>As always live code <a href="https://rnplay.org/apps/qLNwNw">https://rnplay.org/apps/qLNwNw</a></h3>

<p><img class="<a" src="href="http://i.imgur.com/3TLQtmE.gif">http://i.imgur.com/3TLQtmE.gif</a>" title="Cheaper than going to the movies" ></p>

<h2>Full Code</h2>

<p>```
var React = require(&lsquo;react-native&rsquo;);
var {
  AppRegistry,
  StyleSheet,
  Text,
  View,
  PanResponder,
  Image,
  Animated
} = React;</p>

<p>var width = 280;
var height = 150;</p>

<p>function calculatePercentage(offset, dimension) {
  return ((-2 / dimension) * offset) + 1;
}</p>

<p>var AppleTV = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
  maxRotation: 12,
  maxTranslation: 6,
  perspective: 800
};
</code></pre>

<p>  },
  componentWillMount: function() {</p>

<pre><code>this._animations = {
  xRotationPercentage: new Animated.Value(0),
  yRotationPercentage: new Animated.Value(0),
  xTranslationPercentage: new Animated.Value(0),
  yTranslationPercentage: new Animated.Value(0)
}

this._panResponder = PanResponder.create({
  onStartShouldSetPanResponder: (evt, gestureState) =&gt; true,
  onStartShouldSetPanResponderCapture: (evt, gestureState) =&gt; true,
  onMoveShouldSetPanResponder: (evt, gestureState) =&gt; true,
  onMoveShouldSetPanResponderCapture: (evt, gestureState) =&gt; true,
  onPanResponderMove: (e, gestureState) =&gt; {
    e.persist();
    var {
      locationX: x,
      locationY: y
    } = e.nativeEvent;

    this._animations.xRotationPercentage.setValue(calculatePercentage(y, height));
    this._animations.yRotationPercentage.setValue(calculatePercentage(x, width) * -1);
    this._animations.xTranslationPercentage.setValue(calculatePercentage(x, width));
    this._animations.yTranslationPercentage.setValue(calculatePercentage(y, height));
  }
})
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
    &lt;View style= {...this._panResponder.panHandlers}&gt;
      &lt;Card  
          style=
          stackingFactor={1}
          {...this.state}
          {...this._animations}
      &gt;
        &lt;Card 
          style=
          stackingFactor={1.4}
          {...this.state}
          {...this._animations}
        &gt;
          &lt;Card
            style= 
            stackingFactor={1.8}
            {...this.state}
            {...this._animations}
          /&gt;
        &lt;/Card&gt;
      &lt;/Card&gt;
    &lt;/View&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
});</p>

<p>var Card = React.createClass({
  componentWillMount: function() {</p>

<p>  var translateMax = (this.props.maxTranslation * this.props.stackingFactor);
  var rotateMax = this.props.maxRotation;</p>

<pre><code>this._xRotation = this.props.xRotationPercentage.interpolate({
  inputRange: [-1, 1],
  outputRange: [ (rotateMax * -1) + 'deg', rotateMax + 'deg'],
  extrapolate: 'clamp'
});

this._yRotation = this.props.yRotationPercentage.interpolate({
  inputRange: [-1, 1],
  outputRange: [ (rotateMax * -1) + 'deg', rotateMax + 'deg'],
  extrapolate: 'clamp'
});

this._translateX = this.props.xTranslationPercentage.interpolate({
  inputRange: [-1, 1],
  outputRange: [(translateMax * -1), translateMax],
  extrapolate: 'clamp'
})

this._translateY = this.props.yTranslationPercentage.interpolate({
  inputRange: [-1, 1],
  outputRange: [(translateMax * -1), translateMax],
  extrapolate: 'clamp'
})
</code></pre>

<p>  },</p>

<p>  getTransform:function() {</p>

<pre><code>return [
  {perspective: this.props.perspective},
  {rotateX: this._xRotation},
  {rotateY: this._yRotation},
  {translateX: this._translateX},
  {translateY: this._translateY},
]
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
  &lt;Animated.View 
    {...this.props} 
    style={[this.props.style, {transform: this.getTransform()}]}
  &gt;
    {this.props.children}
  &lt;/Animated.View&gt;
)
</code></pre>

<p>  }
})</p>

<p>var styles = StyleSheet.create({
  container: {</p>

<pre><code>flex: 1,
justifyContent: 'center',
alignItems: 'center'
</code></pre>

<p>  }
});</p>

<p>AppRegistry.registerComponent(&lsquo;rn_dragtoshow&rsquo;, () => AppleTV);
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native - Easy Overlay Modal with Navigator]]></title>
    <link href="http://browniefed.com/blog/2015/10/18/react-native-easy-overlay-modal-with-navigator/"/>
    <updated>2015-10-18T01:43:00-07:00</updated>
    <id>http://browniefed.com/blog/2015/10/18/react-native-easy-overlay-modal-with-navigator</id>
    <content type="html"><![CDATA[<p>It pays to have the <code>Navigator</code> at the root of your application. This allows you to tunnel back and render something at the root. In our case a custom Modal overlay component. You can pass anything on the route object, and anytime you render the same component at the same place it will just re-render that same component. So lets use the power of React to solve our problems.</p>

<h2>What are we making</h2>

<p><img class="<a" src="href="http://i.imgur.com/5LhPD3l.gif">http://i.imgur.com/5LhPD3l.gif</a>" title="I should have made this loop" ></p>

<!-- more -->


<h2>Setup</h2>

<p>Lets setup our app</p>

<p>```
var React = require(&lsquo;react-native&rsquo;);
var {
  AppRegistry,
  StyleSheet,
  Text,
  View,
  Navigator,
  TouchableOpacity,
  Animated,
  Dimensions
} = React;</p>

<p>var {
  height: deviceHeight
} = Dimensions.get(&lsquo;window&rsquo;);
```</p>

<p>We&rsquo;ll get our <code>deviceHeight</code> so we can manually animate our modal up. You could use <code>LayoutAnimation</code> here as well and not deal with getting the deviceHeight but I like <code>Animated</code> so deal with it.</p>

<h2>Route Stack</h2>

<p>```
var RouteStack = {</p>

<pre><code>app: {
  component: App 
}
</code></pre>

<p>}
```</p>

<p>This is our super complex route stack. All we do is have a named route with the componet to render.</p>

<h2>Root Application</h2>

<p>```
var ModalApp = React.createClass({
  getInitialState: function() {</p>

<pre><code>return { modal: false };
</code></pre>

<p>  },
  renderScene: function(route, navigator) {</p>

<pre><code>var Component = route.component;

return (
  &lt;Component openModal={() =&gt; this.setState({modal: true})}/&gt;
);
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
    &lt;Navigator
        initialRoute={RouteStack.app}
        renderScene={this.renderScene}
    /&gt;
    {this.state.modal ? &lt;TopModal closeModal={() =&gt; this.setState({modal: false}) }/&gt; : null }
  &lt;/View&gt;
);
</code></pre>

<p>  }
});</p>

<p>```</p>

<p>This is the root of our application. Our render function is pretty basic. We render <code>Navigator</code> with our <code>intialRoute</code> being our only Route. Our <code>renderScene</code> function is going to control our logic.</p>

<p>When we render our component we pass down an <code>openModal</code> function. This will set <code>modal:true</code> on our state which will allow for us to open/close the modal over the current route. This will just cause <code>Navigator</code> to re-render at the current route. This means your rendered <code>Component</code> at the current route will have <code>componentWillReceiveProps</code> triggered. Our <code>TopModal</code> will receive a <code>closeModal</code> function to set <code>modal:false</code> on state and unmount our <code>TopModal</code>.</p>

<p>We put our modal after the <code>Navigator</code> so we can render on top of it.</p>

<h2>Open Modal</h2>

<p>```
var App = React.createClass({</p>

<pre><code>render: function() {
  return (
    &lt;View style={styles.flexCenter}&gt;
      &lt;TouchableOpacity onPress={this.props.openModal}&gt;
        &lt;Text&gt;Open Modal&lt;/Text&gt;  
      &lt;/TouchableOpacity&gt;
    &lt;/View&gt;
  )
}
</code></pre>

<p>});</p>

<p>```</p>

<p>All we do is when we want to open the modal just call the <code>openModal</code> function on props. That will call up to the function in <code>Navigator</code> <code>renderScene</code> and pop open the modal over the existing app.</p>

<h2>The Modal</h2>

<p>
```
var TopModal = React.createClass({
  getInitialState: function() {</p>

<pre><code>return { offset: new Animated.Value(deviceHeight) }
</code></pre>

<p>  },
  componentDidMount: function() {</p>

<pre><code>Animated.timing(this.state.offset, {
  duration: 100,
  toValue: 0
}).start();
</code></pre>

<p>  },
  closeModal: function() {</p>

<pre><code>Animated.timing(this.state.offset, {
  duration: 100,
  toValue: deviceHeight
}).start(this.props.closeModal);
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
    &lt;Animated.View style={[styles.modal, styles.flexCenter, {transform: [{translateY: this.state.offset}]}]}&gt;
      &lt;TouchableOpacity onPress={this.closeModal}&gt;
        &lt;Text style={{color: '#FFF'}}&gt;Close Menu&lt;/Text&gt;
      &lt;/TouchableOpacity&gt;
    &lt;/Animated.View&gt;
)
</code></pre>

<p>  }
});
<code>``

Here we have a basic modal. We set the</code>translateY<code>to the full device height so that it renders off screen, and on mount we slide it up in</code>100ms<code>. On close we slide it down, call the</code>closeModal<code>which will trigger the re-render in our</code>renderScene<code>. This case we won't have</code>modal: true<code>set so our</code>TopModal` will just unmount.</p>

<h2>Done</h2>

<p>Hey now go get your modal on. Just remember, React is flexible. Sometimes you need to pass something up to render at the top. Yes slightly a pain, but it&rsquo;s a manageable pain.</p>

<h4>Live Demo <a href="https://rnplay.org/apps/kF7avw">https://rnplay.org/apps/kF7avw</a></h4>

<p><img class="<a" src="href="http://i.imgur.com/5LhPD3l.gif">http://i.imgur.com/5LhPD3l.gif</a>" title="I should have made this loop" ></p>

<h2>Full Code</h2>

<p>
```
var React = require(&lsquo;react-native&rsquo;);
var {
  AppRegistry,
  StyleSheet,
  Text,
  View,
  Navigator,
  TouchableOpacity,
  Animated,
  Dimensions
} = React;</p>

<p>var {
  height: deviceHeight
} = Dimensions.get(&lsquo;window&rsquo;);</p>

<p>var TopModal = React.createClass({
  getInitialState: function() {</p>

<pre><code>return { offset: new Animated.Value(deviceHeight) }
</code></pre>

<p>  },
  componentDidMount: function() {</p>

<pre><code>Animated.timing(this.state.offset, {
  duration: 100,
  toValue: 0
}).start();
</code></pre>

<p>  },
  closeModal: function() {</p>

<pre><code>Animated.timing(this.state.offset, {
  duration: 100,
  toValue: deviceHeight
}).start(this.props.closeModal);
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
    &lt;Animated.View style={[styles.modal, styles.flexCenter, {transform: [{translateY: this.state.offset}]}]}&gt;
      &lt;TouchableOpacity onPress={this.closeModal}&gt;
        &lt;Text style={{color: '#FFF'}}&gt;Close Menu&lt;/Text&gt;
      &lt;/TouchableOpacity&gt;
    &lt;/Animated.View&gt;
)
</code></pre>

<p>  }
});</p>

<p>var App = React.createClass({</p>

<pre><code>render: function() {
  return (
    &lt;View style={styles.flexCenter}&gt;
      &lt;TouchableOpacity onPress={this.props.openModal}&gt;
        &lt;Text&gt;Open Modal&lt;/Text&gt;  
      &lt;/TouchableOpacity&gt;
    &lt;/View&gt;
  )
}
</code></pre>

<p>});</p>

<p>var RouteStack = {
  app: {</p>

<pre><code>component: App 
</code></pre>

<p>  }
}</p>

<p>var ModalApp = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
  modal: false 
};
</code></pre>

<p>  },
  renderScene: function(route, navigator) {</p>

<pre><code>var Component = route.component;
return (
  &lt;Component openModal={() =&gt; this.setState({modal: true})}/&gt;
)
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
    &lt;Navigator
      initialRoute={RouteStack.app}
      renderScene={this.renderScene}
    /&gt;
    {this.state.modal ? &lt;TopModal closeModal={() =&gt; this.setState({modal: false}) }/&gt; : null }
  &lt;/View&gt;
);
</code></pre>

<p>  }
});</p>

<p>var styles = StyleSheet.create({
  container: {</p>

<pre><code>flex: 1,
</code></pre>

<p>  },
  flexCenter: {</p>

<pre><code>flex: 1,
justifyContent: 'center', 
alignItems: 'center'
</code></pre>

<p>  },
  modal: {</p>

<pre><code>backgroundColor: 'rgba(0,0,0,.8)',
position: 'absolute',
top: 0,
right: 0,
bottom: 0,
left: 0
</code></pre>

<p>  }
});</p>

<p>```</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native - How to make Facebook Reactions]]></title>
    <link href="http://browniefed.com/blog/2015/10/11/react-native-how-to-make-facebook-reactions/"/>
    <updated>2015-10-11T11:35:00-07:00</updated>
    <id>http://browniefed.com/blog/2015/10/11/react-native-how-to-make-facebook-reactions</id>
    <content type="html"><![CDATA[<p>Facebook reactions is a new liking system that Facebook is trialing on a limited basis. Why wait for them to roll it out when we can roll it out ourselves</p>

<p>Thanks to <a href="http://www.engadget.com/2015/10/08/facebook-reactions/">Engadget</a> who created a gif of the animations from a youtube video. After a little slicing up and conversion from white to transparent we have a nice bunch of terrible animated gifs&hellip; but they&rsquo;re animated so deal with it. Like/Love aren&rsquo;t transparent since imagmagick was destroying the white in them.</p>

<p><strong>This code will target .12 and above, running on .11 seemed to cause some slightly different layout issues. I&rsquo;ve fixed them on RNPlay, so just a heads up. The difference is add <code>height:50</code> to our <code>likeContainer</code> </strong></p>

<p><strong>Update &ndash; Android:</strong></p>

<p>Animated Gifs are coming to React Native Android in .13. Also Android does not support <code>overflow: visible</code> so in order to get android to work we would need to get creative. On open they sit within the <code>overflow: hidden</code> container, once slid in we&rsquo;d have to move them outside. Although they are gifs, so you&rsquo;d have to find a way to sync em up.</p>

<p>Maybe 2 sets, one slides in, the other is rendered but hidden, then you toggle which is hidden and slide the other up. Fun stuff!</p>

<h2>What are we building</h2>

<p><img class="<a" src="href="http://i.imgur.com/dFLU8SI.gif">http://i.imgur.com/dFLU8SI.gif</a>" title="Neato" ></p>

<!-- more -->


<p></p>

<h2>Concept</h2>

<p>While holding down a button a pop up will show up, animated gifs will slide up from the bottom. While sliding and hovering over an item it will slide up slightly and scale up in size. On release of the finger, that item is selected, the images slide down and the pop up disappears.</p>

<p>This doesn&rsquo;t sound too bad, there are a few slight issues we&rsquo;ll run into that I&rsquo;ll call out. The main one is just the border around the container. We get creative with the component structure so the images will animate over the top of the border and not underneath it.</p>

<h2>Setup</h2>

<p></p>

<p>```
var React = require(&lsquo;react-native&rsquo;);
var {
  StyleSheet,
  Text,
  Image,
  View,
  PanResponder,
  TouchableOpacity,
  Animated
} = React;</p>

<p>var images = [
  {id: &lsquo;like&rsquo;, img: &lsquo;<a href="http://i.imgur.com/LwCYmcM.gif">http://i.imgur.com/LwCYmcM.gif</a>&rsquo;},
  {id: &lsquo;love&rsquo;, img: &lsquo;<a href="http://i.imgur.com/k5jMsaH.gif">http://i.imgur.com/k5jMsaH.gif</a>&rsquo;},
  {id: &lsquo;haha&rsquo;, img: &lsquo;<a href="http://i.imgur.com/f93vCxM.gif">http://i.imgur.com/f93vCxM.gif</a>&rsquo;},
  {id: &lsquo;yay&rsquo;, img: &lsquo;<a href="http://i.imgur.com/a44ke8c.gif">http://i.imgur.com/a44ke8c.gif</a>&rsquo;},
  {id: &lsquo;wow&rsquo;, img: &lsquo;<a href="http://i.imgur.com/9xTkN93.gif">http://i.imgur.com/9xTkN93.gif</a>&rsquo;},
  {id: &lsquo;sad&rsquo;, img: &lsquo;<a href="http://i.imgur.com/tFOrN5d.gif">http://i.imgur.com/tFOrN5d.gif</a>&rsquo;},
  {id: &lsquo;angry&rsquo;, img: &lsquo;<a href="http://i.imgur.com/1MgcQg0.gif">http://i.imgur.com/1MgcQg0.gif</a>&rsquo;}
]</p>

<p>var App = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
  selected: '',
  open: false
};
</code></pre>

<p>  },
  componentWillMount: function() {</p>

<pre><code>this._imgLayouts = {};
this._imageAnimations = {};
this._scaleAnimation = new Animated.Value(0);

images.forEach((img) =&gt; {
  this._imageAnimations[img.id] = {
    position: new Animated.Value(55),
    scale: new Animated.Value(1)
  };
});

this._panResponder = PanResponder.create({
  onStartShouldSetPanResponder: (evt, gestureState) =&gt; true,
  onStartShouldSetPanResponderCapture: (evt, gestureState) =&gt; true,
  onMoveShouldSetPanResponder: (evt, gestureState) =&gt; true,
  onMoveShouldSetPanResponderCapture: (evt, gestureState) =&gt; true,
});
</code></pre>

<p>  },</p>

<p>  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
    &lt;View
      style={styles.center}
      {...this._panResponder.panHandlers}
    &gt;
      &lt;Text&gt;Like&lt;/Text&gt;
      &lt;Text&gt;You selected: {this.state.selected}&lt;/Text&gt;
      &lt;Animated.View 
        style={[styles.likeContainer, this.getLikeContainerStyle()]}
      &gt;
        &lt;View style={styles.borderContainer} /&gt;
        &lt;View style={styles.imgContainer}&gt;
          {this.getImages()}
        &lt;/View&gt;
      &lt;/Animated.View&gt;
    &lt;/View&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
});</p>

<p>```</p>

<p></p>

<p>We setup our state, we have a <code>selected</code> which we will use to just display some selected text. Then we have an <code>open</code> which we set to false. I am not showing it yet, but we&rsquo;ll need to use <code>open</code> to dynamically control <code>overflow</code> for the container that holds our images so they can slide around correctly.</p>

<p>In our <code>componentWillMount</code> we setup some objects and create some animations. We&rsquo;ll need the coordinates of each image for selection purposes, we&rsquo;ll also have a map of our image animations, and we&rsquo;ll setup <code>_scaleAnimation</code> which we&rsquo;ll use to scale up the container when a user presses down.</p>

<p>Then we loop over each image, create a position, and scale animation for each. Why <code>55</code> and why not <code>ValueXY</code>? Well we are only animating the Y value so no need to have an extra animation. The <code>55</code> is our initial position, which we pass to <code>translateY</code> meaning, start this image <code>55</code> pixels down so we can eventually slide it up.</p>

<p>Finally we&rsquo;ll create a PanResponder to handle users pressing.</p>

<h2>Handle Press and Open</h2>

<p>So we&rsquo;ll put our <code>panHandlers</code> on our wrapping view so our coordinates are correct relatively for the images. That looks like this</p>

<p>```</p>

<pre><code>   &lt;View
      style={styles.center}
      {...this._panResponder.panHandlers}
    &gt;
    ///Other views
    &lt;/View&gt;
</code></pre>

<p>```</p>

<p>Then we need to adjust our PanResponder to call an open function on grant. Grant being the first thing that gets called when the touch is allowed.</p>

<p>```
this._panResponder = PanResponder.create({</p>

<pre><code>  onStartShouldSetPanResponder: (evt, gestureState) =&gt; true,
  onStartShouldSetPanResponderCapture: (evt, gestureState) =&gt; true,
  onMoveShouldSetPanResponder: (evt, gestureState) =&gt; true,
  onMoveShouldSetPanResponderCapture: (evt, gestureState) =&gt; true,
  onPanResponderGrant: this.open
</code></pre>

<p>})
```</p>

<p>Lets adjust our <code>Animated.View</code> container.</p>

<p>```
  getLikeContainerStyle: function() {</p>

<pre><code>return {
        transform: [{scaleY: this._scaleAnimation}],
        overflow: this.state.open ? 'visible': 'hidden'
      };
</code></pre>

<p>  },</p>

<p>  //other render components
  &lt;Animated.View</p>

<pre><code>style={[styles.likeContainer, this.getLikeContainerStyle()]}
</code></pre>

<blockquote><pre><code>&lt;View style={styles.borderContainer} /&gt;
&lt;View style={styles.imgContainer}&gt;
  {this.getImages()}
&lt;/View&gt;
</code></pre>

<p>  &lt;/Animated.View>
```</p></blockquote>

<p>Now our open function.</p>

<p>```
  open: function() {</p>

<pre><code>Animated.parallel([
  Animated.timing(this._scaleAnimation, {
    duration: 100,
    toValue: 1
  }),
  Animated.stagger(50, this.getImageAnimationArray(0))
]).start(() =&gt; this.setState({open: true}));
</code></pre>

<p>  },
  getImageAnimationArray: function(toValue) {</p>

<pre><code>return images.map((img) =&gt; {
  return Animated.timing(this._imageAnimations[img.id].position, {
    duration: 200,
    toValue: toValue
  })
});
</code></pre>

<p>  },
<code>``
We'll queue up some</code>parallel<code>animations so they run at the same time. The first is the initial scaling of the container. We'll do it over</code>100ms<code>, and go from 0 to 1.
The next thing we'll do is use</code>Animated.stagger<code>, this will trigger an array of animations, but with a delay in between each one. That means we can easily slide up each image reaction separately with</code>50ms` inbetween. What a handy function.</p>

<p>So we&rsquo;ll do a little forward thinking and create a <code>getImageAnimationArray</code> function because we&rsquo;ll have to do the exact opposite for the <code>close</code> so lets make a reusable function.</p>

<p>Finally we&rsquo;ll <code>setState</code> AFTER the animation is complete. This will not cause a jitter in our animation. This also allows the container to hide the images to start so they slide up. Then after the container is open we set <code>overflow: visible</code> so we can scale and slide them up and they&rsquo;ll actually be visible. If we don&rsquo;t do this then the images won&rsquo;t be able visible when the user tries to select them.</p>

<h2>Handle release and close</h2>

<p>Now modify the <code>_panResponder</code> for the release to close it, we basically just do the exact opposite of open.</p>

<p>```</p>

<pre><code>  onPanResponderRelease: (evt, gestureState) =&gt; {
     this.close()
  }
</code></pre>

<p>```</p>

<p>And our close function</p>

<p>```
  close: function(cb) {</p>

<pre><code>this.setState({open: false}, () =&gt; {
  Animated.stagger(100,[
    Animated.parallel(this.getImageAnimationArray(55, 0).reverse() ),
    Animated.timing(this._scaleAnimation, {
      duration: 100,
      toValue: 0
    })
  ]).start(cb);
})
</code></pre>

<p>  },
<code>``
We need to do a setState to make the containers overflow hidden. This is tricky because it'll instantly cause anything selected to be hidden. So we'll need to account for this in our release function later. But at the moment, we set</code>open` to false.</p>

<p>Rather than parallel we&rsquo;ll stagger our 2 animations. Our first will start and cause our reaction gifs to all slide down at the same time. Then <code>100ms</code> later we&rsquo;ll scale the container down to 0. This just adds a slight disappearing effect.</p>

<h2>Calculate image positions</h2>

<p>Before we can do image selections we need to know where our images coordinates are. Luckily we can do that with the <code>onLayout</code> callback.</p>

<p></p>

<p>```
  getImages: function() {</p>

<pre><code>return images.map((img) =&gt; {
  return (
    &lt;Animated.Image 
      onLayout={this.handleLayoutPosition.bind(this, img.id)}
      key={img.id} 
      source={{uri: img.img}} 
      style={[
          styles.img,
          {
            transform: [
              {scale: this._imageAnimations[img.id].scale},
              {translateY: this._imageAnimations[img.id].position}
            ]
          }
      ]} 
    /&gt;
  );
})
</code></pre>

<p>  },
```
</p>

<p>This is our image rendering function. It iterates over our images, passes in all necesary info and binds our <code>onLayout</code> function with the <code>image.id</code> which is just the reaction name. You can see here we also pass in our transform animations for <code>scale</code> and <code>translateY</code></p>

<p>```
  handleLayoutPosition: function(img, position) {</p>

<pre><code>this._imgLayouts[img] = {
  left: position.nativeEvent.layout.x,
  right: position.nativeEvent.layout.x + position.nativeEvent.layout.width
}
</code></pre>

<p>  },
<code>``
Here we setup a map, we'll set the</code>left<code>which is just the relative</code>x<code>coordinate, then setup our</code>right<code>which is</code>x + width`.</p>

<h2>Add in hover abilities</h2>

<p>```</p>

<pre><code>  onPanResponderMove: (evt, gestureState) =&gt; {
    var hoveredImg = this.getHoveredImg(Math.ceil(evt.nativeEvent.locationX));

    if (hoveredImg &amp;&amp; this._hoveredImg !== hoveredImg) {
      this.animateSelected(this._imageAnimations[hoveredImg])
    }
    if (this._hoveredImg !== hoveredImg &amp;&amp; this._hoveredImg) {
      this.animateFromSelect(this._imageAnimations[this._hoveredImg]);
    }

    this._hoveredImg = hoveredImg;
  },
</code></pre>

<p>```</p>

<p>We just do some basic logic here. If we have a <code>hoveredImg</code> and it&rsquo;s different than before, then call the animate function to make the image slide and scale up.
Also if we have a current <code>this._hoveredImg</code> and it&rsquo;s different then that means there is a new hovered image, so lets animate the previous image and scale it back down.</p>

<p>```
  animateSelected: function(imgAnimations) {</p>

<pre><code>Animated.parallel([
  Animated.timing(imgAnimations.position, {
    duration: 150,
    toValue: -30
  }),
  Animated.timing(imgAnimations.scale, {
    duration: 150,
    toValue: 1.8
  })
]).start();
</code></pre>

<p>  },
  animateFromSelect: function(imgAnimations, cb) {</p>

<pre><code>Animated.parallel([
  Animated.timing(imgAnimations.position, {
    duration: 50,
    toValue: 0
  }),
  Animated.timing(imgAnimations.scale, {
    duration: 50,
    toValue: 1
  })
]).start(cb);
</code></pre>

<p>  },
  getHoveredImg: function(x) {</p>

<pre><code>return Object.keys(this._imgLayouts).find((key) =&gt; {
  return x &gt;= this._imgLayouts[key].left &amp;&amp; x &lt;= this._imgLayouts[key].right;
})
</code></pre>

<p>  },
```</p>

<p>Nothing too much here to call out. Our <code>getHoveredImg</code> function runs through our layouts, and just checks if the <code>x</code> coordinate of the finger press is between the <code>left</code> and <code>right</code>. If it finds one it returns the reaction id.</p>

<p>The <code>animateSelected</code> and <code>animatedFromSelect</code> both take one the image animation objects and applies different animations to each.</p>

<h2>Add in selection text</h2>

<p>```</p>

<pre><code>  onPanResponderRelease: (evt, gestureState) =&gt; {
    if (this._hoveredImg) {
      this.animateFromSelect(this._imageAnimations[this._hoveredImg], this.close.bind(this, this.afterClose) )
    } else {
      this.close(this.afterClose);
    }
  }
</code></pre>

<p>```</p>

<p>I had mentioned this before. On the release if we have a current selection, then we need to first animate the selected image back to it&rsquo;s original position, which we have <code>animateFromSelect</code> already. Then when that is complete the callback is called which is our close function, which has a callback to trigger after close.</p>

<p>```
  afterClose: function() {</p>

<pre><code>if (this._hoveredImg) {
  this.setState({
    selected: this._hoveredImg
  })
}

this._hoveredImg = '';
</code></pre>

<p>  },
```</p>

<p>Our after close just sets some text of the hovered img and clears it. This may not be necessary for an actual app, but this is just so I can have some text to show a user they selected a reaction.</p>

<h2>Weird setup and styles</h2>

<p>I&rsquo;ll just point out some &ldquo;weird&rdquo; things I&rsquo;m doing to make things work correctly. Mainly rather than adding in the border on the <code>likeContainer</code> we need to add in 2 separate containers.</p>

<p>Our element structure</p>

<p>```
&lt;Animated.View</p>

<pre><code>        style={[styles.likeContainer, this.getLikeContainerStyle()]}
      &gt;
        &lt;View style={styles.borderContainer} /&gt;
        &lt;View style={styles.imgContainer}&gt;
          {this.getImages()}
        &lt;/View&gt;
      &lt;/Animated.View&gt;
</code></pre>

<p>```
Our weird styling.</p>

<p>```
  likeContainer: {</p>

<pre><code>position: 'absolute',
left: -10,
top: -30,
padding: 5,
flex: 1,
backgroundColor: '#FFF',
borderColor: 'transparent',
borderWidth: 0,
borderRadius: 20,
</code></pre>

<p>  },
  borderContainer: {</p>

<pre><code>backgroundColor: 'transparent',
position: 'absolute',
left: 0,
right: 0,
top: 0,
bottom: 0,
borderWidth: 1,
borderColor: '#444',
borderRadius: 20
</code></pre>

<p>  },
  imgContainer: {</p>

<pre><code>backgroundColor: 'transparent',
flexDirection: 'row',
</code></pre>

<p>  },
```</p>

<p>The <code>borderContainer</code> is absolutely positioned inside of the <code>likeContainer</code>. The <code>borderContainer</code> is just that, a bunch of border data.</p>

<p>The <code>likeContainer</code> also has border radius, transparent border styling so that it is shaped perfectly for overflow when the images slide down.</p>

<h2>DONE</h2>

<p>And there we have it. This is by no means an exact replica. It needs some serious polish and also needs to add a delay before opening when the users presses. It&rsquo;s good enough for me though. So go forth and add reactions to your app!</p>

<p>I didn&rsquo;t do anything crazy and assumed it would work on android. There a few issues with it so I&rsquo;m not sure exactly what&rsquo;s going on.</p>

<h4>Check it out live on RNPlay <a href="https://rnplay.org/apps/lIVMng">https://rnplay.org/apps/lIVMng</a></h4>

<p>As stated before there are minor tweaks from the code to make it work with react .11, not entirely certain why there are differences but there are.</p>

<p><img class="<a" src="href="http://i.imgur.com/dFLU8SI.gif">http://i.imgur.com/dFLU8SI.gif</a>" title="Neato" ></p>

<p>Full code here</p>

<p></p>

<p>```
var React = require(&lsquo;react-native&rsquo;);
var {
  StyleSheet,
  Text,
  Image,
  View,
  PanResponder,
  TouchableOpacity,
  Animated
} = React;</p>

<p>var images = [
  {id: &lsquo;like&rsquo;, img: &lsquo;<a href="http://i.imgur.com/LwCYmcM.gif">http://i.imgur.com/LwCYmcM.gif</a>&rsquo;},
  {id: &lsquo;love&rsquo;, img: &lsquo;<a href="http://i.imgur.com/k5jMsaH.gif">http://i.imgur.com/k5jMsaH.gif</a>&rsquo;},
  {id: &lsquo;haha&rsquo;, img: &lsquo;<a href="http://i.imgur.com/f93vCxM.gif">http://i.imgur.com/f93vCxM.gif</a>&rsquo;},
  {id: &lsquo;yay&rsquo;, img: &lsquo;<a href="http://i.imgur.com/a44ke8c.gif">http://i.imgur.com/a44ke8c.gif</a>&rsquo;},
  {id: &lsquo;wow&rsquo;, img: &lsquo;<a href="http://i.imgur.com/9xTkN93.gif">http://i.imgur.com/9xTkN93.gif</a>&rsquo;},
  {id: &lsquo;sad&rsquo;, img: &lsquo;<a href="http://i.imgur.com/tFOrN5d.gif">http://i.imgur.com/tFOrN5d.gif</a>&rsquo;},
  {id: &lsquo;angry&rsquo;, img: &lsquo;<a href="http://i.imgur.com/1MgcQg0.gif">http://i.imgur.com/1MgcQg0.gif</a>&rsquo;}
]</p>

<p>var App = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
  selected: '',
  open: false
};
</code></pre>

<p>  },
  componentWillMount: function() {</p>

<pre><code>this._imgLayouts = {};
this._imageAnimations = {};
this._hoveredImg = '';

this._scaleAnimation = new Animated.Value(0);

images.forEach((img) =&gt; {
  this._imageAnimations[img.id] = {
    position: new Animated.Value(55),
    scale: new Animated.Value(1)
  };
})

this._panResponder = PanResponder.create({
  onStartShouldSetPanResponder: (evt, gestureState) =&gt; true,
  onStartShouldSetPanResponderCapture: (evt, gestureState) =&gt; true,
  onMoveShouldSetPanResponder: (evt, gestureState) =&gt; true,
  onMoveShouldSetPanResponderCapture: (evt, gestureState) =&gt; true,
  onPanResponderGrant: this.open,
  onPanResponderMove: (evt, gestureState) =&gt; {
    var hoveredImg = this.getHoveredImg(Math.ceil(evt.nativeEvent.locationX));

    if (hoveredImg &amp;&amp; this._hoveredImg !== hoveredImg) {
      this.animateSelected(this._imageAnimations[hoveredImg])
    }
    if (this._hoveredImg !== hoveredImg &amp;&amp; this._hoveredImg) {
      this.animateFromSelect(this._imageAnimations[this._hoveredImg]);
    }

    this._hoveredImg = hoveredImg;
  },
  onPanResponderRelease: (evt, gestureState) =&gt; {
    if (this._hoveredImg) {
      this.animateFromSelect(this._imageAnimations[this._hoveredImg], this.close.bind(this, this.afterClose) )
    } else {
      this.close(this.afterClose);
    }
  }
});
</code></pre>

<p>  },
  afterClose: function() {</p>

<pre><code>if (this._hoveredImg) {
  this.setState({
    selected: this._hoveredImg
  })
}

this._hoveredImg = '';
</code></pre>

<p>  },
  animateSelected: function(imgAnimations) {</p>

<pre><code>Animated.parallel([
  Animated.timing(imgAnimations.position, {
    duration: 150,
    toValue: -30
  }),
  Animated.timing(imgAnimations.scale, {
    duration: 150,
    toValue: 1.8
  })
]).start();
</code></pre>

<p>  },
  animateFromSelect: function(imgAnimations, cb) {</p>

<pre><code>Animated.parallel([
  Animated.timing(imgAnimations.position, {
    duration: 50,
    toValue: 0
  }),
  Animated.timing(imgAnimations.scale, {
    duration: 50,
    toValue: 1
  })
]).start(cb);
</code></pre>

<p>  },
  getHoveredImg: function(x) {</p>

<pre><code>return Object.keys(this._imgLayouts).find((key) =&gt; {
  return x &gt;= this._imgLayouts[key].left &amp;&amp; x &lt;= this._imgLayouts[key].right;
})
</code></pre>

<p>  },</p>

<p>  getImageAnimationArray: function(toValue) {</p>

<pre><code>return images.map((img) =&gt; {
  return Animated.timing(this._imageAnimations[img.id].position, {
    duration: 200,
    toValue: toValue
  })
});
</code></pre>

<p>  },
  open: function() {</p>

<pre><code>Animated.parallel([
  Animated.timing(this._scaleAnimation, {
    duration: 100,
    toValue: 1
  }),
  Animated.stagger(50, this.getImageAnimationArray(0))
]).start(() =&gt; this.setState({open: true}));
</code></pre>

<p>  },
  close: function(cb) {</p>

<pre><code>this.setState({open: false}, () =&gt; {
  Animated.stagger(100,[
    Animated.parallel(this.getImageAnimationArray(55, 0).reverse() ),
    Animated.timing(this._scaleAnimation, {
      duration: 100,
      toValue: 0
    })
  ]).start(cb);
})
</code></pre>

<p>  },
  handleLayoutPosition: function(img, position) {</p>

<pre><code>this._imgLayouts[img] = {
  left: position.nativeEvent.layout.x,
  right: position.nativeEvent.layout.x + position.nativeEvent.layout.width
}
</code></pre>

<p>  },
  getImages: function() {</p>

<pre><code>return images.map((img) =&gt; {
  return (
    &lt;Animated.Image 
      onLayout={this.handleLayoutPosition.bind(this, img.id)}
      key={img.id} 
      source={{uri: img.img}} 
      style={[
          styles.img,
          {
            transform: [
              {scale: this._imageAnimations[img.id].scale},
              {translateY: this._imageAnimations[img.id].position}
            ]
          }
      ]} 
    /&gt;
  );
})
</code></pre>

<p>  },
  getLikeContainerStyle: function() {</p>

<pre><code>return {
        transform: [{scaleY: this._scaleAnimation}],
        overflow: this.state.open ? 'visible': 'hidden',
      };
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
    &lt;View
      style={styles.center}
      {...this._panResponder.panHandlers}
    &gt;
      &lt;Text&gt;Like&lt;/Text&gt;
      &lt;Text&gt;You selected: {this.state.selected}&lt;/Text&gt;
      &lt;Animated.View 
        style={[styles.likeContainer, this.getLikeContainerStyle()]}
      &gt;
        &lt;View style={styles.borderContainer} /&gt;
        &lt;View style={styles.imgContainer}&gt;
          {this.getImages()}
        &lt;/View&gt;
      &lt;/Animated.View&gt;
    &lt;/View&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
});</p>

<p>var styles = StyleSheet.create({
  container: {</p>

<pre><code>flex: 1,
</code></pre>

<p>  },
  center: {</p>

<pre><code>position: 'absolute',
left: 50,
top: 300
</code></pre>

<p>  },
  likeContainer: {</p>

<pre><code>position: 'absolute',
left: -10,
top: -30,
padding: 5,
flex: 1,
backgroundColor: '#FFF',
borderColor: 'transparent',
borderWidth: 0,
borderRadius: 20,
</code></pre>

<p>  },
  borderContainer: {</p>

<pre><code>backgroundColor: 'transparent',
position: 'absolute',
left: 0,
right: 0,
top: 0,
bottom: 0,
borderWidth: 1,
borderColor: '#444',
borderRadius: 20
</code></pre>

<p>  },
  imgContainer: {</p>

<pre><code>backgroundColor: 'transparent',
flexDirection: 'row',
</code></pre>

<p>  },
  img: {</p>

<pre><code>marginLeft: 5,
marginRight: 5,
width: 30,
height: 30,
overflow: 'visible'
</code></pre>

<p>  }
});</p>

<p>module.exports = App;
```</p>

<p></p>
]]></content>
  </entry>
  
</feed>
