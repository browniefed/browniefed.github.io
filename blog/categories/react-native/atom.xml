<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: react-native | JavaScript Without Grammar]]></title>
  <link href="http://browniefed.com/blog/categories/react-native/atom.xml" rel="self"/>
  <link href="http://browniefed.com/"/>
  <updated>2017-06-03T09:01:35-07:00</updated>
  <id>http://browniefed.com/</id>
  <author>
    <name><![CDATA[Jason Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[A Year in Review and What is Next]]></title>
    <link href="http://browniefed.com/blog/a-year-in-review-and-what-is-next/"/>
    <updated>2016-12-23T13:41:00-08:00</updated>
    <id>http://browniefed.com/blog/a-year-in-review-and-what-is-next</id>
    <content type="html"><![CDATA[<h2>Absence</h2>

<p>I made a decision to not post as much on this blog over the past year. Despite reaching upwards of 300,000 views in the past 1.5 years, I wasn&rsquo;t seeing the positive feedback I was hoping for. Not compliments, but increase knowledge around animations, and just a general positive impact on the community.</p>

<p>I now realize I was wrong. Over the course of the year many people have been posting new animated blog tutorials.
I won&rsquo;t go through my entire twitter timeline but one recently was from someone who posted an animation tutorial.</p>

<blockquote class="twitter-tweet" data-conversation="none" data-lang="en"><p lang="en" dir="ltr"><a href="https://twitter.com/browniefed">@browniefed</a> Thanks for you feedback. I appreciate it. Big fan of your blog btw. I&#39;ve learned a lot reading your posts!</p>&mdash; Rational App Dev (@rationalappdev) <a href="https://twitter.com/rationalappdev/status/812361076113219584">December 23, 2016</a></blockquote>


<script async src="http://browniefed.com//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>Lurking in chat channels, many have been helping others with animations and referencing my blog as where they learned.
It&rsquo;s a good feeling. This year I will return to the blog.</p>

<!-- more -->


<h2>Making Money</h2>

<p>This blog has made me $0 directly (except a $20 bitcoin gift, thanks Daniel). Indirectly it has been invaluable for being a resource where people learn my name, and attach it to things they'ved learned. Things that have helped them wow their coworkers, make an interaction a touch better, or just learn something that helps them ship that next feature.</p>

<p>I don&rsquo;t believe donations are sustainable.
Every resource that is valuable and sustainable are all charging money like <a href="https://reacttraining.com/">React Training</a>, or anything from <a href="https://reactforbeginners.com/">Wes Bos</a>, and anyone else that is selling courses like <a href="https://www.educative.io/">educative.io</a>.</p>

<p>I enjoy helping people but 75% of what I build/write/etc from now on will cost money ( or earn me money in some way).</p>

<h2>What Have I Been Doing</h2>

<p>Living my life I suppose. One thing I&rsquo;ve been doing is consuming way too much.
Consuming others knowledge is fun and valuable but I personally have not be investing.</p>

<p>I&rsquo;m trying to fix this. I&rsquo;m trying to consume less but that&rsquo;s a work in progress.</p>

<p>Since I&rsquo;ve been trying to focus on creationg I&rsquo;ve done some Egghead work. It&rsquo;s been great and Egghead is fantastic!</p>

<p><a href="https://egghead.io/courses/animate-react-native-ui-elements"><img src="https://d2eip9sf3oo6c2.cloudfront.net/series/covers/000/000/085/full/EGH_ImageGallery_Final-cover.png?1478539191" title="Egghead is poppin" ></a></p>

<p>You can check out my first course <a href="https://egghead.io/courses/animate-react-native-ui-elements">Animate React Native UI Elements</a>  <br/>
You can check out all my lessons here <a href="https://egghead.io/instructors/jason-brown-20a6bf03-254a-428c-9984-dca76cc84f32">Instructor &ndash; Jason Brown</a></p>

<p>More courses and lessons are on the way. 1 course is completed, and the other is in production.</p>

<h2>A Year to Reboot</h2>

<p>It&rsquo;ll be a good year to reboot, and I&rsquo;m definitely not waiting till the new year starts to take action.</p>

<p>My plans will include.</p>

<ul>
<li><p><strong>Heavier time investment in open source</strong>  <br/>
&mdash; I contribute where I want but I&rsquo;d like a few open source projects to maintain.</p></li>
<li><p><strong>Dumping knowledge into more outlets</strong>   <br/>
&mdash; Including more egghead, blog posts, my own knowledge base sites, interactive tutorials</p></li>
<li><p><strong>Consume less, Create more</strong>   <br/>
&mdash; Catching up on the latest things at night, not the instant it happens</p></li>
<li><p><strong>Better time management</strong>    <br/>
&mdash; Not much needs to be said here, but maintaining a healthy life style along w/ accomplishing all of this will be difficult</p></li>
<li><p><strong>Say No more often</strong>   <br/>
&mdash; This plays into time management, but saying no to things I know I don&rsquo;t really want to do will be crucial</p></li>
<li><p><strong>New Technologies</strong>  <br/>
&mdash; I&rsquo;ve been very focused on JS land. It&rsquo;s fun but I need to expand my breadth of knowledge. Basically be a better T-Shaped person.</p></li>
</ul>


<h2>Anyway</h2>

<p>It&rsquo;s been a good year for me personally. Excited for 2017. Looking forward to whatever the hell happens.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native FlexboxFroggy]]></title>
    <link href="http://browniefed.com/blog/react-native-flexboxfroggy/"/>
    <updated>2015-12-23T15:33:00-08:00</updated>
    <id>http://browniefed.com/blog/react-native-flexboxfroggy</id>
    <content type="html"><![CDATA[<p>If you are in the React Native world and haven&rsquo;t heard about <a href="https://exponentjs.com/">Exponent</a> then you&rsquo;ve been living under a rock. It&rsquo;s being built by James Ide, Brent Vatne, and Charlie Cheever. All who have contributed significantly to the React Native community and ecosystem.</p>

<p>Brent is holding a contest to win some awesome prizes, including tickets to the sold out ReactJS 2016 Conf. Check out the contest here <a href="https://gist.github.com/brentvatne/7d88f846417452355b18">https://gist.github.com/brentvatne/7d88f846417452355b18</a>.</p>

<p>What does this have to do with flexbox? Well as my entry into the contest I converted <a href="http://flexboxfroggy.com/">http://flexboxfroggy.com/</a> to React Native.</p>

<p><img class="<a" src="href="http://i.imgur.com/BuCjWBl.gif">http://i.imgur.com/BuCjWBl.gif</a>" title="CHEAT CODES" ></p>

<p>Even adding animations was a breeze! One line of code <code>LayoutAnimation.spring()</code> easily makes all frogs spring into place!</p>

<p><img class="<a" src="href="http://i.imgur.com/cyyYZAS.gif">http://i.imgur.com/cyyYZAS.gif</a>" title="Hop on froggies" ></p>

<p>You can check out the code here <a href="https://github.com/browniefed/flexboxfroggy">https://github.com/browniefed/flexboxfroggy</a></p>

<p>Or if you have Exponent installed you can run it easily on your phone by just tapping this link <a href="http://exp.host/@browniefed/flexboxfroggy">http://exp.host/@browniefed/flexboxfroggy</a></p>

<p>If you don&rsquo;t have Exponent installed I highly suggest you install it!</p>

<p>That&rsquo;s all from me for now. Looking forward to getting back to blogging in 2016!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native Animated Book]]></title>
    <link href="http://browniefed.com/blog/react-native-animated-book/"/>
    <updated>2015-12-23T15:31:00-08:00</updated>
    <id>http://browniefed.com/blog/react-native-animated-book</id>
    <content type="html"><![CDATA[<p>So I wrote a book of sorts on React Native animations. Mostly covering the animated API, and soon much much more. Check it out here <a href="http://browniefed.com/react-native-animation-book/">http://browniefed.com/react-native-animation-book/</a>.</p>

<p>I cover the API, and walk through basic animation examples, and soon advanced topics. Learn to create a fun dragging, spinning square.</p>

<p><img class="<a" src="href="http://browniefed.com/react-native-animation-book/images/SimpleDragAnimation.gif">http://browniefed.com/react-native-animation-book/images/SimpleDragAnimation.gif</a>" title="DragNSpin" ></p>

<p>This is just a quick update :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native - How to bridge a Swift View]]></title>
    <link href="http://browniefed.com/blog/react-native-how-to-bridge-a-swift-view/"/>
    <updated>2015-11-28T11:09:00-08:00</updated>
    <id>http://browniefed.com/blog/react-native-how-to-bridge-a-swift-view</id>
    <content type="html"><![CDATA[<p>So in my previous article we bridged an Objective-C View component, I learned a lot, and also learned that I did a few unnecessary things. No worry though, we&rsquo;ll learn from that and make improvements in our Swift bridging.</p>

<p>First off want to give a thanks to <a href="https://twitter.com/tony_xiao">Tony Xiao</a>. He&rsquo;s been a great help in sharing code and giving explanations to a Swift and native development novice like myself. Also <a href="https://twitter.com/realasa">Asa Miller</a> for writing some of the original code and always collaborating on whatever we&rsquo;re both working on.</p>

<h2>What</h2>

<p><img class="<a" src="href="http://i.imgur.com/TsOMRom.png">http://i.imgur.com/TsOMRom.png</a>" title="Gradients, are those still a thing?" ></p>

<p>We&rsquo;re going to bridge <a href="https://github.com/soffes/GradientView">https://github.com/soffes/GradientView</a>. Looks pretty nifty. Now we could also just use ReactART for this but we won&rsquo;t.</p>

<!-- more -->


<h2>Why Swift?</h2>

<p>It looks more like JavaScript, it&rsquo;s nicer to read (aka less brackets), and seemingly easier to write? I don&rsquo;t know, they say it&rsquo;s the next big thing.</p>

<h2>Why Not Swift?</h2>

<p>Well it can&rsquo;t be turned into a static library&hellip; wut? It seemingly can&rsquo;t be converted into one of those nice <code>.xcodeproj</code> files with a <code>.a</code> that we can easily link. However it can be converted into an <code>.xcodeproj</code> with a <code>.framework</code> we can link, not sure what the difference is but whatever. We&rsquo;ll still go about bridging. We could have also used Pods here, but once again the point of this post is about bridging and not Pods. I&rsquo;ll focus on those later.</p>

<h2>Create a Project</h2>

<p>I won&rsquo;t walk us through bundling up anything into a library, I&rsquo;ll just walk you through developing and integrating a Swift library.</p>

<p>So go ahead and fire off a <code>react-native init GradientTest</code> to create an empty project.</p>

<p>Once that is done open up the project <code>ios/GradientTest.xcodeproj</code> in XCode.</p>

<h2>Add GradientView</h2>

<p>Now lets pull in the <code>GradientView</code> library I had mentioned up above. I pulled it down and just put it in a <code>GradientView</code> folder in the <code>ios</code> directory.</p>

<p>Directory structure looks something like</p>

<p><img class="<a" src="href="http://i.imgur.com/wzIGDYk.png">http://i.imgur.com/wzIGDYk.png</a>" title="Aint nothin but a directory structure img" ></p>

<p>We&rsquo;ll go through the same general process of linking the library as always.</p>

<p>Right click, select <code>Add Files to GradientTest</code> and find the <code>GradientView.xcodeproj</code> that we just pulled down.</p>

<p>When we go to link the library in <code>Build Phases</code> like normal it will actually be <code>GradientView.framework</code> that we are going to link. Should look something like so.</p>

<p><img class="<a" src="href="http://i.imgur.com/6EIs7Vu.png">http://i.imgur.com/6EIs7Vu.png</a>" title="It is all magic to me" ></p>

<p>We&rsquo;ll still get some issues so lets go add <code>$(SRCROOT)/GradientView</code> recursive to the <code>Framework Search Paths</code>
Should look something like</p>

<p><img class="<a" src="href="http://i.imgur.com/bWs3LuJ.png">http://i.imgur.com/bWs3LuJ.png</a>" title="I wish XCode was more magical" ></p>

<h2>Create our Manager and Bridging Header</h2>

<p>We&rsquo;re going to first start off by creating a new <code>.swift</code> file. Simply do that by right clicking on our <code>GradientTest</code> folder, select <code>New file</code> and click on the swift selection and click create.</p>

<p>We&rsquo;ll call this file <code>RNGradientViewManager</code>.</p>

<p><strong> CREATE THE BRIDGING HEADER</strong></p>

<p><img class="<a" src="href="http://i.imgur.com/99mUsRS.png">http://i.imgur.com/99mUsRS.png</a>" title="Bridge across troubled code" ></p>

<p>This is super important. Our briding header file will be named <code>GradientTest-Bridging-Header.h</code>. This allows us to bridge the React View Manager (Objective-C) code into the Swift world.</p>

<p>Or as you can read in the file
```
//
//  Use this file to import your target&rsquo;s public headers that you would like to expose to Swift.
//</p>

<p>```</p>

<p>All we need to do is add our <code>RCTViewManager.h</code> import. So our <code>GradientTest-Bridging-Header.h</code> should just be this</p>

<p>```
//
//  Use this file to import your target&rsquo;s public headers that you would like to expose to Swift.
//</p>

<h1>import &ldquo;RCTViewManager.h&rdquo;</h1>

<p>```</p>

<h2>Add The Manager Code</h2>

<p>Okay now we need to add our Manager code, if you&rsquo;ve read my previous tutorial before on bridging Objective-C, I&rsquo;ve stated that the Manager is just a singleton View producer. Just because it is in swift is no different.</p>

<p><code>RNLinearGradientManager.swift</code></p>

<p>```
import Foundation</p>

<p>@objc(RNLinearGradient)
class RNGradientViewManager : RCTViewManager {
  override func view() &ndash;> UIView! {</p>

<pre><code>return UIView(); // We'll change this later
</code></pre>

<p>  }
}
```</p>

<p>We create an override for the <code>view</code> function, this is what React will call to produce the new view. Thanks to our bridging header we get access to <code>RCTViewManager</code> and create a class called <code>RNGradientViewManager</code>.</p>

<p>The important thing to call out here is the <code>@objc(RNLinearGradientSwift)</code> line. This is an arbitrary name I made up, but what it says is to tell XCode and the compiler to expose the class <code>RNGradientViewManager</code> to the Objective-C world and call it <code>RNLinearGradientSwift</code>.</p>

<h2>The Objective-C React Native Part</h2>

<p>Well at some point we have to dive into a little Objective-C. We&rsquo;ll create a new class and call it <code>RNLinearGradient</code></p>

<p><img class="<a" src="href="http://i.imgur.com/fcBMyIS.png">http://i.imgur.com/fcBMyIS.png</a>" title="How do you say cocoa" ></p>

<p>Then we&rsquo;ll subclass it off of <code>RCTView</code></p>

<p><img class="<a" src="href="http://i.imgur.com/57Vcf0j.png">http://i.imgur.com/57Vcf0j.png</a>" title="Generate code so I do not have to" ></p>

<p>That will create 2 files.</p>

<p><code>RNLinearGradient.h</code>
<code>RNLinearGradient.m</code></p>

<p>This is where we will tell React Native about what we need and what to call our stuff in the JavaScript world.</p>

<h4>First our <code>RNLinearGradient.m</code> file.</h4>

<p>```</p>

<h1>import &ldquo;RNLinearGradient.h&rdquo;</h1>

<h1>import &ldquo;RCTViewManager.h&rdquo;</h1>

<p>@interface RCT_EXTERN_MODULE(RNLinearGradientSwift, RCTViewManager)</p>

<p>RCT_EXPORT_VIEW_PROPERTY(locations, NSArray);
RCT_EXPORT_VIEW_PROPERTY(colors, NSArray);</p>

<p>@end
<code>``
We import our</code>RNLinearGradient.h<code>file we will get ot in a second, as well as our</code>RCTViewManager.h`</p>

<p>See there is our Manager we created and called <code>RNLinearGradientSwift</code>.</p>

<p>We create a new interface and call <code>RCT_EXTERN_MODULE</code> which will tell the JavaScript world about our module called <code>RNLinearGradientSwift</code>.</p>

<p>We&rsquo;ll also export 2 view properties. These are specific to <code>GradientView</code>. Both will be <code>NSArray</code> and take an array of colors and locations to create the gradient.</p>

<h4>Now our <code>RNLinearGradient.h</code> file.</h4>

<p>```</p>

<h1>import &ldquo;RCTView.h&rdquo;</h1>

<p>@interface RNLinearGradient : RCTView</p>

<p>@property (nonatomic, assign) NSArray <em>locations;
@property (nonatomic, assign) NSArray </em>colors;
@end</p>

<p><code>``
We import</code>RCTView` from React code, and then define our 2 properties.</p>

<p>Defining these properties here in this file tells React what properties to apply to the View that gets returned from our <code>view</code> function call in our <code>RNGradientViewManager</code>.</p>

<h2>Back to Swift</h2>

<p>Alright now we are back to swift. We&rsquo;ll go ahead and create a new swift file that will be the view that gets returned from the <code>view</code> function in our <code>RNGradientViewManager</code>.</p>

<p>Create a swift file called <code>RNGradientView</code></p>

<p>```
import Foundation
import GradientView</p>

<p>@objc(RNGradientView)
class RNGradientView : GradientView {
  required init?(coder aDecoder: NSCoder) {</p>

<pre><code>fatalError("init(coder:) has not been implemented")
</code></pre>

<p>  }
}
```</p>

<p>We&rsquo;ll import our <code>GradientView</code> library, and we&rsquo;ll create a class that inherits from it. Previously in my Objective-C tutorial we implemented the <code>addSubviews</code> call however here we&rsquo;ll implement things a bit different and have the view that gets returned the actual <code>GradientView</code>.</p>

<p>The whole <code>required init?(coder aDecoder: NSCoder)</code> part was autogenerated by XCode, it&rsquo;s all magic to me.</p>

<p>Now lets add an init for the frame. The frame is the <code>CGRect</code> that we get given. It tells us our origin <code>x,y</code> and also the size <code>width,height</code> of our view.</p>

<p>```
@objc(RNGradientView)
class RNGradientView : GradientView {</p>

<p>  override init(frame: CGRect) {</p>

<pre><code>super.init(frame: frame);
self.frame = frame;
</code></pre>

<p>  }</p>

<p>  required init?(coder aDecoder: NSCoder) {</p>

<pre><code>fatalError("init(coder:) has not been implemented")
</code></pre>

<p>  }
}
```</p>

<p>We call <code>super.init</code> with our frame, and then also assign <code>self.frame = frame</code>. Remember because we inherited from <code>GradientView</code> the <code>self</code> basically refers to <code>GradientView</code> so when we want to manipulate the <code>GradientView</code> we simply manipulate our <code>self</code>.</p>

<p>Lets add some setters now. We defined 2 different properties up above <code>locations</code> and <code>colors</code>. We now need to create our setters so we can receive the values and set them.</p>

<p>```
@objc(RNGradientView)
class RNGradientView : GradientView {</p>

<p>  override init(frame: CGRect) {</p>

<pre><code>super.init(frame: frame);
self.frame = frame;
</code></pre>

<p>  }</p>

<p>  required init?(coder aDecoder: NSCoder) {</p>

<pre><code>fatalError("init(coder:) has not been implemented")
</code></pre>

<p>  }</p>

<p>  func setLocations(locations: NSArray) {</p>

<pre><code>self.locations = locations.map({ return $0 as! CGFloat});
</code></pre>

<p>  }</p>

<p>  func setColors(colors: NSArray) {</p>

<pre><code>self.colors = colors.map({return RCTConvert.UIColor($0)})
</code></pre>

<p>  }
}
```</p>

<p>Our <code>locations</code> is an <code>NSArray</code> of various values, they are sent over from the JavaScript world like so.</p>

<p><code>&lt;LinearGradient locations={[0.2, 1]} /&gt;</code>, however they will be a mix of <code>doubles</code> and <code>integers</code> but we want everything as a <code>CGFloat</code> which is what <code>GradientView</code> is expecting.</p>

<p>From a JavaScript world you may be used to functional programming, we <code>map</code> over the array which will return a new array. Then we cast whatever values <code>double</code> or <code>integer</code>, etc as <code>CGFloat</code> and set that on <code>self.locations</code>.</p>

<p>Then for <code>colors</code> we&rsquo;ll do something similar. However in our JavaScript world we use the handy <code>processColors</code> provided to use by React. Which will process arbitrary <code>hex</code>, <code>rgb</code>, color names, and others into a value that can easily be passed over the bridge.</p>

<p>The JavaScript code could look something like <code>&lt;LinearGradient colors={['red', 'rgb(255,100,50)']} /&gt;</code>.</p>

<p>We take advantage of the <code>RCTConvert</code> from React which gives us a bunch of handy ways to convert arbitrary values into other values. In our case <code>GradientView</code> expects <code>UIColor</code>s in the shape of an array. So we can once again <code>map</code> over our array of values and pass them into <code>RCTConvert.UIColor</code>.</p>

<h2>Fix Our Manager</h2>

<p>Remember we just left our Manager to return a boring ole <code>UIView</code>, lets go fix it up to return our <code>RNGradientView</code>.</p>

<p>```
import Foundation</p>

<p>@objc(RNLinearGradientSwift)
class RNGradientViewManager : RCTViewManager {
  override func view() &ndash;> UIView! {</p>

<pre><code>return RNGradientView();
</code></pre>

<p>  }
}
```
That sure was hard :)</p>

<h2>JavaScript code</h2>

<p>We will need to write some JavaScript code but it should be pretty harmless.</p>

<p>```
import React, { requireNativeComponent, processColor } from &lsquo;react-native&rsquo;;
let RNLinearGradient = requireNativeComponent(&lsquo;RNLinearGradientSwift&rsquo;, LinearGradient);</p>

<p>class LinearGradient extends React.Component {
  render() {</p>

<pre><code>let { colors, ...otherProps } = this.props;
return &lt;RNLinearGradient {...otherProps} colors={processColor(colors)} /&gt;;
</code></pre>

<p>  }
}</p>

<p>LinearGradient.propTypes = {
  colors: React.PropTypes.array.isRequired,
  locations: React.PropTypes.array,
}</p>

<p>export default LinearGradient;
```</p>

<p>We bring in <code>React</code>, and our <code>requireNativeComponent</code> as well as <code>processColor</code> from React Native.</p>

<p>We create our <code>RNLinearGradient</code> component that we render, and as you can see once again there is our <code>RNLinearGradientSwift</code> that was externalized in our <code>RNGradientViewManager</code> as <code>RNLinearGradientSwift</code>.</p>

<p>We specify our <code>propTypes</code> as arrays.</p>

<p>Then we can pull of <code>colors</code> from <code>this.props</code>, and we call <code>processColor</code> with the array which will automatically map over and return a new array of all processed colors that will work nicely with the <code>RCTConvert.UIColor</code> call.</p>

<h2>HOW DO I USE THIS THING?</h2>

<p>```</p>

<pre><code>    &lt;LinearGradient 
      style={styles.gradient} 
      locations={[0, 1.0]} 
      colors={['#5ED2A0', '#339CB1']}
    /&gt;
</code></pre>

<p><code>``
To use we simply define some values.</code>locations<code>at</code>[0,1]` will specify the first color at 0 position and the second color at the end which is 1.
This can take more than just 2 colors and locations, it will take any number of colors and locations.</p>

<p>```</p>

<pre><code>    &lt;LinearGradient 
      style={styles.gradient} 
      locations={[0, .5, 1.0]} 
      colors={['#5ED2A0', 'red', '#339CB1']}
    /&gt;
</code></pre>

<p>```</p>

<p>Our gradient style is just postioned absolutely so it is basically covering the background as a gradient.</p>

<p>```
  gradient: {</p>

<pre><code>position: 'absolute',
top: 0,
left: 0,
bottom: 0,
right: 0,
</code></pre>

<p>  }
```</p>

<h2>DONE</h2>

<p>Awesome, we&rsquo;re done! You can check the full code up here <a href="https://github.com/asamiller/react-native-gradient">https://github.com/asamiller/react-native-gradient</a>. Yes it&rsquo;s not on my github repo, it&rsquo;s on a friends repo which we collaborated on together. Deal with it.</p>

<p><img class="<a" src="href="http://i.imgur.com/TsOMRom.png">http://i.imgur.com/TsOMRom.png</a>" title="Gradients are neatoooo" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native - How to Bridge an Objective-C View Component]]></title>
    <link href="http://browniefed.com/blog/react-native-how-to-bridge-an-objective-c-view-component/"/>
    <updated>2015-11-24T14:15:00-08:00</updated>
    <id>http://browniefed.com/blog/react-native-how-to-bridge-an-objective-c-view-component</id>
    <content type="html"><![CDATA[<p>I am not an Objective-C developer so some of the things I say here may be wrong, so tell me if I&rsquo;m wrong!
React Native is young enough that some cool existing native components need to still be bridged to take advantage of.
There is plenty of information out there about bridging modules, and view components.</p>

<p>Here are a fiew</p>

<ul>
<li><a href="http://moduscreate.com/leverage-existing-ios-views-react-native-app/">Leverage Existing iOS Views In Your React Native App</a></li>
<li><a href="http://brentvatne.ca/react-native-view-component-1/">React Native View Components (&frac12;)</a></li>
<li><a href="http://brentvatne.ca/react-native-view-component-2/">React Native View Components (2/2)</a></li>
<li><a href="http://brentvatne.ca/packaging-react-native-component/">Packaging a React Native component</a></li>
<li><a href="http://facebook.github.io/react-native/docs/native-components-ios.html#content">Native UI Components &ndash; React Native Documentation</a></li>
</ul>


<p>Some of these are more up to date and in depth and others lesser so.</p>

<h2>What?</h2>

<p><img class="<a" src="href="http://i.imgur.com/GFisosN.gif">http://i.imgur.com/GFisosN.gif</a>" title="NyanNyan Needs Performance" ></p>

<!-- more -->


<h2>What are we bridging?</h2>

<p>We are going to do a very basic bridge of <a href="https://github.com/Flipboard/FLAnimatedImage">FLAnimatedImage</a>.
Basically it&rsquo;s a performant component to render animated gifs.</p>

<p>Straight from their README.</p>

<p>FLAnimatedImage is a performant animated GIF engine for iOS:</p>

<ul>
<li>Plays multiple GIFs simultaneously with a playback speed comparable to desktop browsers</li>
<li>Honors variable frame delays</li>
<li>Behaves gracefully under memory pressure</li>
<li>Eliminates delays or blocking during the first playback loop</li>
<li>Interprets the frame delays of fast GIFs the same way modern browsers do</li>
</ul>


<h2>Creating a Component</h2>

<p>I tend to like to make my component as an application first and then I&rsquo;ll bust it out into a separate component. I already did that, so we&rsquo;ll just focus on the real process.</p>

<p>To do that we&rsquo;ll create a library.</p>

<p>In XCode go to <code>File &gt; New &gt; Project</code> and select <code>Static Library</code></p>

<p>Like so</p>

<p><img class="<a" src="href="http://i.imgur.com/xFBkJfD.png">http://i.imgur.com/xFBkJfD.png</a>" title="Stolen from Brent Vatne" ></p>

<p>Save that somewhere and call it <code>RNFLAnimatedImage</code> so that you can follow along with the tutorial.</p>

<h2>External Dependencies</h2>

<p>In our case we are depending on the FLAnimatedImage library. We have a few different choices, using pods?, using Carthage?, or just copy and pasting.
For the sake of this we&rsquo;re going to copy and paste. We&rsquo;ll get into this when the tutorial actually starts.</p>

<p>I essentially cloned the repo, and copied over the necessary files. You then go through the usual process of adding a library to an XCode project.
You can read about linking libraries here <a href="http://facebook.github.io/react-native/docs/linking-libraries-ios.html#content">http://facebook.github.io/react-native/docs/linking-libraries-ios.html#content</a>.</p>

<p>Basically do this.</p>

<p><img class="<a" src="href="http://i.imgur.com/AfCMdHF.png">http://i.imgur.com/AfCMdHF.png</a>" title="Find the FLAnimatedImage.xcodeporj" ></p>

<p>Then do this</p>

<p><img class="<a" src="href="http://i.imgur.com/BySd9oD.png">http://i.imgur.com/BySd9oD.png</a>" title="Press + and add the framework" ></p>

<h2>Manager vs View</h2>

<p>The Manager is the orchestrator of this particular view we are bridging. It&rsquo;s essentially a singleton (there is just one of them) that when asked will produce a new view to use of whatever kind you define. In our case we have an <code>RNFLAnimatedImageManager</code> that when asked will create an <code>RNFLAnimateImage</code> which will create and setup our <code>FLAnimatedImage</code> Objective-C component.</p>

<p>The Manager is also where we setup the module bridge, and declare what sort of properties we need, event callbacks, and additional constants to export if we need any.</p>

<p>The View portion is just that, the View. This is what will be instantiated and hook into some lifecycle events so you can manipulate the Objective-C world.</p>

<p>Each View will need to do different things during these lifecycle events, it&rsquo;s up to you to implement them and figure out what exactly needs to be handled for the component that you are bridging.</p>

<h2>Life Cycles/Initializer in the Objective C World</h2>

<p>The main life cycle we need to implement is <code>- (void)layoutSubviews</code>.
The other non-lifecycle method that is important is <code>- (instancetype)initWithEventDispatcher:(RCTEventDispatcher *)eventDispatcher</code>.</p>

<p>Additional life cycle calls are <code>- (void)insertReactSubview:(UIView *)view atIndex:(NSInteger)atIndex</code> and <code>- (void)removeReactSubview:(UIView *)subview</code> but we won&rsquo;t talk about those.</p>

<p>The <code>layoutSubviews</code> method gives us an arbitrary hook to control the current view component. You can manipulate the view, add subviews, or add sublayers. In our case we&rsquo;ll add the FLAnimatedImage as a subview.</p>

<p>The <code>initWithEventDispatcher</code> method allows us to handle initialization of the View and additionally save off our <code>eventDispatcher</code> which means we can send messages back to the JavaScript world.</p>

<p>So when you see people sending back callback functions to the native world this is what is sending back the events. So things like <code>onLoad</code>, <code>onVideoProgress</code>, etc you would use this event dispatcher to send out a <code>onLoad</code> or <code>onVideoProgress</code> event name with a payload of data.</p>

<h2>Specifying callbacks</h2>

<p>In a manager file you would specify something like so</p>

<p>```
&ndash; (NSArray *) customDirectEventTypes {
  return @[</p>

<pre><code>       @"onFrameChange"
      ];
</code></pre>

<p>}</p>

<p>```
In our case we may want to listen for when the GIF frame index changes.</p>

<p>We send stuff from Objective-C world to JavaScript like so</p>

<p>```</p>

<pre><code>  [_eventDispatcher sendInputEventWithName:@"onFrameChange" body:@{
                                                                   @"currentFrameIndex":[NSNumber numberWithUnsignedInteger:[object currentFrameIndex]],
                                                                   @"frameCount": [NSNumber numberWithUnsignedInteger:[_image frameCount]],
                                                                   @"target": self.reactTag
                                                                   }];
</code></pre>

<p>```</p>

<p>Then in our JavaScript world we can do this.</p>

<p>```</p>

<pre><code>      &lt;FLAnimatedImage 
        style= 
        src={this.state.url}
        resizeMode={this.state.resizeMode} 
        onFrameChange={(e) =&gt; console.log(e.nativeEvent.currentFrameIndex + '/' + e.nativeEvent.frameCount)}
      /&gt;
</code></pre>

<p>```</p>

<h2>Properties from ObjC to JavaScript</h2>

<p>That looks something like</p>

<p><code>RCTFLAnimatedImageManager.m</code></p>

<p>```</p>

<p>RCT_EXPORT_VIEW_PROPERTY(src, NSString);
RCT_EXPORT_VIEW_PROPERTY(contentMode, NSNumber);</p>

<p>```</p>

<p><code>RCTFLAnimatedImage.m</code></p>

<p>```</p>

<p>@property (nonatomic, assign) NSString <em>src;
@property (nonatomic, assign) NSNumber </em>contentMode;</p>

<p>```</p>

<p>In the JavaScript world when we render our component whatever the <code>src</code> prop is will be put there.</p>

<p>```</p>

<p><RNFlAnimatedImage src="http://someanimated.gif" resizeMode={1} /></p>

<p>```</p>

<p>In the JavaScript world we do need to define our <code>PropTypes</code> on the component.</p>

<p>
```
  propTypes: {</p>

<pre><code>/*
  native only
*/
contentMode: PropTypes.number,
/*

*/
src: PropTypes.string,
resizeMode: PropTypes.string,
onFrameChange: PropTypes.func
</code></pre>

<p>  }</p>

<p>```</p>

<p></p>

<h2>Exporting Constants</h2>

<p>Sometimes there are strings, numbers, enums, etc in the Objective-C world that you may want to use in the JavaScript world. To do this we use the <code>constantsToExport</code> method in our manager.</p>

<p>```
&ndash; (NSDictionary *) constantsToExport {
  return @{</p>

<pre><code>       @"ScaleAspectFit": @(UIViewContentModeScaleAspectFit),
       @"ScaleAspectFill": @(UIViewContentModeScaleAspectFill),
       @"ScaleToFill": @(UIViewContentModeScaleToFill)
      };
</code></pre>

<p>}</p>

<p>```</p>

<p>We export some <code>NSIntegers</code> (converting them to <code>NSNumbers</code> with the <code>@</code>, thanks Google) and this will get put onto React Native <code>NativeModules</code>.</p>

<p>```
React.NativeModules.RNFLAnimatedImageManager;
/*
  {</p>

<pre><code>  ScaleToFill: 0,
  ScaleAspectFit: 1,
  ScaleAspectFill: 2
</code></pre>

<p>  }
*/
```</p>

<h2>Stop?</h2>

<p>Alright that was all a preface to show you the little bits and areas that you can bridge. Maybe you just needed syntax, maybe you wondering about it&rsquo;s capabilities. Either way if you got enough information then no need to go any further. However I encourage you to read on.</p>

<h2>Tutorial Start</h2>

<p>So we have the empty <code>RNFLAnimatedImage</code> project you created right? Go do it now if you haven&rsquo;t already.</p>

<p>The first thing we are going to need to do is setup our <code>Header Search Paths</code> and add React to it.
We&rsquo;ll need to add various locations to tell Objective-C to look for all the <code>.h</code> and <code>.m</code> files.</p>

<p>add these 5</p>

<p><code>
$(inherited)
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include
$(SRCROOT)/../../React
$(SRCROOT)/../react-native/React
$(SRCROOT)/node_modules/react-native/React
</code></p>

<p>It should look something like.</p>

<p><img class="<a" src="href="http://i.imgur.com/GFfRgNV.png">http://i.imgur.com/GFfRgNV.png</a>" title="Header Search Paths for all the Reacts" ></p>

<p><code>FLAnimatedImage</code> ships as a framework, I wasn&rsquo;t able to import the required <code>.h</code> and <code>.m</code> files until I told XCode where to look for <code>FLAnimatedImage</code>.
So lets set that up, add <code>$(SRCROOT)/FLAnimatedImage</code> the <code>Framework Search Paths</code> right above <code>Header Search Paths</code></p>

<p><img class="<a" src="href="http://i.imgur.com/gkkZJ4d.png">http://i.imgur.com/gkkZJ4d.png</a>" title="I have no clue if this is correct" ></p>

<h2>Add Manager Files</h2>

<p>In creating this <code>RNFLAnimatedImage.m/.h</code> were created but lets create our manager files now.
Just right click on the folder select &ldquo;New File&rdquo; and create a <code>.m</code> and name in <code>RNFLAnimatedImageManager.m</code> , same for the <code>.h</code></p>

<p><img class="<a" src="href="http://i.imgur.com/jEQdrce.png">http://i.imgur.com/jEQdrce.png</a>" title="Sponsored by H and M" ></p>

<p>We need to add our new manager files to our compile source.</p>

<p><img class="<a" src="href="http://i.imgur.com/6Kzve8u.png">http://i.imgur.com/6Kzve8u.png</a>" title="Compile sources, what are they good for" ></p>

<h2>RNFLAnimatedImageManager.h</h2>

<p>```</p>

<h1>import &ldquo;RCTViewManager.h&rdquo;</h1>

<p>@interface RNFLAnimatedImageManager : RCTViewManager</p>

<p>@end
<code>``
That's it, we just have our</code>interface<code>we called</code>RNFLAnimatedImageManager<code>and inherit from</code>RCTViewManager` which is provided by React.</p>

<h2>RNFLAnimatedImageManager.m</h2>

<p>First we need to import some stuff</p>

<p>```</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<h1>import &ldquo;RCTBridge.h&rdquo;</h1>

<h1>import &ldquo;RNFLAnimatedImageManager.h&rdquo;</h1>

<h1>import &ldquo;RNFLAnimatedImage.h&rdquo;</h1>

<p><code>``
We bring in the bridging mechanism from React, the</code>Manager.h<code>file, and additionally the</code>.h` for the view we&rsquo;re bridging.</p>

<p>```
@implementation RNFLAnimatedImageManager</p>

<p>RCT_EXPORT_MODULE();</p>

<p>@synthesize bridge = _bridge;</p>

<p>```</p>

<p>Inside our implementation we call <code>RCT_EXPORT_MODULE()</code> that tells React we are exporting a module.</p>

<p>The <code>@synthesize bridge</code> stuff is declaring that we want to just auto generate some getters and setters for our bridge.</p>

<p><code>
- (UIView *)view
{
  return [[RNFLAnimatedImage alloc] initWithEventDispatcher:self.bridge.eventDispatcher];
}
</code>
This is called to create a new view. We are allocating our view <code>RNFLAnimatedImage</code> and initializing it with the <code>eventDispatcher</code> so we can communicate back to the JavaScript world.</p>

<p><code>
- (dispatch_queue_t)methodQueue
{
  return dispatch_get_main_queue();
}
</code>
This has something to do with dispatching :). I think it says that when we dispatch it should go on the main queue?</p>

<p><code>
RCT_EXPORT_VIEW_PROPERTY(src, NSString);
RCT_EXPORT_VIEW_PROPERTY(contentMode, NSNumber);
</code>
Define some properties to bridge.</p>

<p>```
&ndash; (NSArray *) customDirectEventTypes {
  return @[</p>

<pre><code>       @"onFrameChange"
      ];
</code></pre>

<p>}
```
Define some function callback/events we can dispatch.</p>

<p>```
&ndash; (NSDictionary *) constantsToExport {
  return @{</p>

<pre><code>       @"ScaleAspectFit": @(UIViewContentModeScaleAspectFit),
       @"ScaleAspectFill": @(UIViewContentModeScaleAspectFill),
       @"ScaleToFill": @(UIViewContentModeScaleToFill)
      };
</code></pre>

<p>}</p>

<p>@end
```</p>

<p>Finally we define some constants to export and end our implementation.</p>

<p>Link to the file on github <a href="https://github.com/browniefed/react-native-flanimatedimage/blob/master/RNFLAnimatedImage/RNFLAnimatedImage/RNFLAnimatedImageManager.m">https://github.com/browniefed/react-native-flanimatedimage/blob/master/RNFLAnimatedImage/RNFLAnimatedImage/RNFLAnimatedImageManager.m</a>.</p>

<h2>RNFLAnimatedImage.h</h2>

<p>```</p>

<h1>import &ldquo;RCTEventDispatcher.h&rdquo;</h1>

<h1>import &ldquo;FLAnimatedImage/FLAnimatedImage.h&rdquo;</h1>

<p>@class RCTEventDispatcher;</p>

<p>@interface RNFLAnimatedImage : UIView</p>

<p>@property (nonatomic, assign) NSString <em>src;
@property (nonatomic, assign) NSNumber </em>contentMode;</p>

<ul>
<li>(instancetype)initWithEventDispatcher:(RCTEventDispatcher *)eventDispatcher NS_DESIGNATED_INITIALIZER;</li>
</ul>


<p>@end
<code>``
We import our event dispatcher, and tell the compiler that the class</code>RCTEventDispatcher<code>will be defined.
We create our interface, give it the name</code>RNFLAniamtedImage<code>and inherit from the base</code>UIView`.</p>

<p>We add our properties, don&rsquo;t worry about the <code>nonatomic</code> stuff, if you want to know go le google it.</p>

<p>Finally we define our initWithEventDispatcher method that our <code>Manager</code> initialized with. The <code>NS_DESIGNATED_INITIALIZER</code> is to tell the compiler that this is our initializer vs the typical <code>init</code>.</p>

<h2>RNFlAnimatedImage.m</h2>

<p>Alright this will be where all of our bridging work comes into play. Read through the full source here <a href="https://github.com/browniefed/react-native-flanimatedimage/blob/master/RNFLAnimatedImage/RNFLAnimatedImage/RNFLAnimatedImage.m">https://github.com/browniefed/react-native-flanimatedimage/blob/master/RNFLAnimatedImage/RNFLAnimatedImage/RNFLAnimatedImage.m</a>.</p>

<p>So first we need to import stuff and define our basic implementation</p>

<p>```</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<h1>import &ldquo;FLAnimatedImage/FLAnimatedImage.h&rdquo;</h1>

<h1>import &ldquo;RCTBridgeModule.h&rdquo;</h1>

<h1>import &ldquo;RCTEventDispatcher.h&rdquo;</h1>

<h1>import &ldquo;UIView+React.h&rdquo;</h1>

<h1>import &ldquo;RNFLAnimatedImage.h&rdquo;</h1>

<p>@implementation RNFLAnimatedImage : UIView  {</p>

<p>}</p>

<p>@end
```</p>

<p>Don&rsquo;t worry too much about what&rsquo;s getting imported. Most of them are just so React can do it&rsquo;s thing.</p>

<p>
```</p>

<p>@implementation RNFLAnimatedImage : UIView  {</p>

<p>  RCTEventDispatcher <em>_eventDispatcher;
  FLAnimatedImage </em><em>image;
  FLAnimatedImageView *</em>imageView;</p>

<p>}</p>

<p>```</p>

<p></p>

<p>We now define our instance variables that we&rsquo;ll assign inside of this implementation. We setup our <code>eventDispatcher</code>, the <code>image</code> and <code>imageView</code> with their specific types.</p>

<p>```
&ndash; (instancetype)initWithEventDispatcher:(RCTEventDispatcher *)eventDispatcher
{
  if ((self = [super init])) {</p>

<pre><code>_eventDispatcher = eventDispatcher;
_imageView = [[FLAnimatedImageView alloc] init];

[_imageView addObserver:self forKeyPath:@"currentFrameIndex" options:0 context:nil];
</code></pre>

<p>  }</p>

<pre><code>return self;
</code></pre>

<p>}
<code>``
This is our initializer that we had defined. It receives</code>eventDispatcher<code>as the only argument. We then save it off to the</code>eventDispatcher<code>variable we create up above. Then create a new</code>FLAnimatedImageView<code>and save that off. The</code>addObserver<code>we'll get into later, but this is going to allow us to asynchronously hook into the</code>currentFrameIndex` of our animated gif and call the callback.</p>

<p>```</p>

<h1>pragma mark &ndash; React View Management</h1>

<ul>
<li><p>(void)insertReactSubview:(UIView *)view atIndex:(NSInteger)atIndex
{
  RCTLogError(@&ldquo;image cannot have any subviews&rdquo;);
  return;
}</p></li>
<li><p>(void)removeReactSubview:(UIView *)subview
{
  RCTLogError(@&ldquo;image cannot have any subviews&rdquo;);
  return;
}</p></li>
<li><p>(void)layoutSubviews
{
[super layoutSubviews];
<em>imageView.frame = self.bounds;
[self addSubview:</em>imageView];
}
```</p></li>
</ul>


<p>These are the important React added lifecylce methods. The <code>insertReactSubview</code> and <code>removeReactSubview</code> is how we would go about allowing <code>children</code>.</p>

<p>The <code>layoutSubviews</code> is the call that gives us the ability to add in our <code>FLAnimatedImageView</code> that we created into the <code>RNFLAnimatedImage</code> that we are creating. This method is going to be the one that is going to be mostly a custom implementation depending on what components you end up bridging.</p>

<p>The other import thing to call out is <code>self.bounds</code> this is a <code>CGRect</code> that contains <code>x,y</code> and <code>width/height</code> that is going to be provided from the <code>style</code> that is defined in the JavaScript world!</p>

<p>```
&ndash; (void)setSrc:(NSString *)src
{
  if (![src isEqual:_src]) {</p>

<pre><code>_src = [src copy];
[self reloadImage];
</code></pre>

<p>  }
}</p>

<ul>
<li>(void)setContentMode:(NSNumber *)contentMode
{
if(![contentMode isEqual:<em>contentMode]) {
  </em>contentMode = [contentMode copy];
  [self reloadImage];
}
}
<code>``
These are setters that we hook into so that when a</code>setState<code>happens and a re-render is triggered in the JavaScript world these get called. We check if our</code>src<code>is different and or if our</code>contentMode<code>is different, if it is we set our instance variables to the new values and call</code>reloadImage`.</li>
</ul>


<p><code>
-(void)reloadImage {
  _image = [FLAnimatedImage animatedImageWithGIFData:[NSData dataWithContentsOfURL:[NSURL URLWithString:_src]]];
  _imageView.contentMode = [_contentMode integerValue];
  _imageView.animatedImage = _image;
}
</code></p>

<p>Our reload image is more of a setup/modify image. We set our <code>image</code> to be the <code>FLAnimatedImage</code> with the gif data from a URL. We pass our <code>src</code> in there which comes from the bridged value from the JavaScript world.</p>

<p>We setup our contentMode on the <code>imageView</code> then set our <code>imageView.animatedImage</code> to be the <code>image</code> of the url.</p>

<p>```
&ndash;(void)observeValueForKeyPath:(NSString <em>)keyPath ofObject:(id)object change:(NSDictionary<NSString *,id> </em>)change context:(void *)context {
  if (object == _imageView) {</p>

<pre><code>if ([keyPath isEqualToString:@"currentFrameIndex"]) {
  [_eventDispatcher sendInputEventWithName:@"onFrameChange" body:@{
                                                                   @"currentFrameIndex":[NSNumber numberWithUnsignedInteger:[object currentFrameIndex]],
                                                                   @"frameCount": [NSNumber numberWithUnsignedInteger:[_image frameCount]],
                                                                   @"target": self.reactTag
                                                                   }];
}
</code></pre>

<p>  }
}
```</p>

<p>When observers get setup (like we did in the initializer) the <code>observerveValueForKeyPath</code> method will be called with the information about the thing that changed.
In our case <code>object</code> was setup to be our <code>imageView</code> and the <code>keyPath</code> was <code>currentFrameIndex</code>.</p>

<p>We do some checking to make sure that the <code>object</code> is in fact our <code>imageView</code>, and that the <code>keyPath</code> we are dealing with is the <code>currentFrameIndex</code>. If it is this when we send our event to be dispatched. It just so happens to be named <code>onFrameChange</code> and our <code>body</code> can be custom crafted and will be ultimately translated into JSON for us. We pass back the <code>currentFrameIndex</code> and the total <code>frameCount</code> as well as the React Component we are dealing with.</p>

<p>```
&ndash; (void)removeFromSuperview
{</p>

<pre><code>[_imageView removeObserver:self forKeyPath:@"currentFrameIndex"];
_eventDispatcher = nil;
_image = nil;
_imageView = nil;
[super removeFromSuperview];
</code></pre>

<p>}
```</p>

<p>Finally the <code>removeFromSuperview</code> function is called. This is the equivalence of <code>componentWillUnmount</code> in the React JavaScript world. Here we clean up the observer, as well as the other things we have created.</p>

<p>You are now done with Objective-C! Check out the full source code here <a href="https://github.com/browniefed/react-native-flanimatedimage/blob/master/RNFLAnimatedImage/RNFLAnimatedImage/RNFLAnimatedImage.m">https://github.com/browniefed/react-native-flanimatedimage/blob/master/RNFLAnimatedImage/RNFLAnimatedImage/RNFLAnimatedImage.m</a>.</p>

<h2>FLAnimatedImage.js</h2>

<p>Now we are back in our JavaScript world. We&rsquo;ve done the hard part.</p>

<p>```
var React = require(&lsquo;react-native&rsquo;);
var { requireNativeComponent, PropTypes, NativeModules, } = React;</p>

<p>var {
  ScaleToFill,
  ScaleAspectFit,
  ScaleAspectFill
} = NativeModules.RNFLAnimatedImageManager;</p>

<p>var MODES = {
  &lsquo;stretch&rsquo;: ScaleToFill,
  &lsquo;contain&rsquo;: ScaleAspectFit,
  &lsquo;cover&rsquo;: ScaleAspectFill
}</p>

<p>var FLAnimatedImage = React.createClass({
  propTypes: {</p>

<pre><code>/*
  native only
*/
contentMode: PropTypes.number,
/*

*/
src: PropTypes.string,
resizeMode: PropTypes.string,
onFrameChange: PropTypes.func
</code></pre>

<p>  },
  render() {</p>

<pre><code>var contentMode = MODES[this.props.resizeMode] || MODES.stretch;
return (
        &lt;RNFLAnimatedImage 
            {...this.props} 
            contentMode={contentMode}
        /&gt;
      );
</code></pre>

<p>  },
});</p>

<p>var RNFLAnimatedImage = requireNativeComponent(&lsquo;RNFLAnimatedImage&rsquo;, FLAnimatedImage);</p>

<p>module.exports = FLAnimatedImage;
```</p>

<p>The important parts to call out is that all values being passed to the component/native world need to have a <code>PropType</code> specified! If you noticed something a bit weird. We create a class called <code>FLAnimatedImage</code> which we call to <code>requireNativeComponent</code> that creates <code>RNFLAnimatedImage</code> which then <code>FLAnimatedImage</code> renders. Weird cyclic thing, but ultimately it allows us to tell React what component our class is going to need to be rendered.</p>

<p>The <code>MODES</code> thing is just so we can map a nice string the user can give us to one of the constants that we exported from our Objective-C world.</p>

<h2>DONE!</h2>

<p>Hey look you did it. We got through the weird brackted world of Objective-C. To use it we require it and pass in our props.

```</p>

<pre><code>      &lt;FLAnimatedImage 
        style={{flex: 1}} 
        src="http://raphaelschaad.com/static/nyan.gif"
        resizeMode="contain" 
        onFrameChange={(e) =&gt; console.log(e.nativeEvent.currentFrameIndex + '/' + e.nativeEvent.frameCount)}
      /&gt;
</code></pre>

<p>```
</p>

<h2>Final Code</h2>

<p>The code is all up on github, check the repo out here <a href="https://github.com/browniefed/react-native-flanimatedimage">https://github.com/browniefed/react-native-flanimatedimage</a> and the folder where the Objective-C code is at is right here <a href="https://github.com/browniefed/react-native-flanimatedimage/tree/master/RNFLAnimatedImage/RNFLAnimatedImage">https://github.com/browniefed/react-native-flanimatedimage/tree/master/RNFLAnimatedImage/RNFLAnimatedImage</a>.</p>

<p>Now we have a bridge AnimatedGif component at our exposure.</p>

<p><img class="<a" src="href="http://i.imgur.com/GFisosN.gif">http://i.imgur.com/GFisosN.gif</a>" title="Now that is stuck in your head" ></p>
]]></content>
  </entry>
  
</feed>
