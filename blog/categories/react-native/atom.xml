<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: react-native | JavaScript Without Grammar]]></title>
  <link href="http://browniefed.com/blog/categories/react-native/atom.xml" rel="self"/>
  <link href="http://browniefed.com/"/>
  <updated>2016-04-09T22:53:12-07:00</updated>
  <id>http://browniefed.com/</id>
  <author>
    <name><![CDATA[Jason Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[React Native FlexboxFroggy]]></title>
    <link href="http://browniefed.com/blog/react-native-flexboxfroggy/"/>
    <updated>2015-12-23T15:33:00-08:00</updated>
    <id>http://browniefed.com/blog/react-native-flexboxfroggy</id>
    <content type="html"><![CDATA[<p>If you are in the React Native world and haven&rsquo;t heard about <a href="https://exponentjs.com/">Exponent</a> then you&rsquo;ve been living under a rock. It&rsquo;s being built by James Ide, Brent Vatne, and Charlie Cheever. All who have contributed significantly to the React Native community and ecosystem.</p>

<p>Brent is holding a contest to win some awesome prizes, including tickets to the sold out ReactJS 2016 Conf. Check out the contest here <a href="https://gist.github.com/brentvatne/7d88f846417452355b18">https://gist.github.com/brentvatne/7d88f846417452355b18</a>.</p>

<p>What does this have to do with flexbox? Well as my entry into the contest I converted <a href="http://flexboxfroggy.com/">http://flexboxfroggy.com/</a> to React Native.</p>

<p><img class="<a" src="href="http://i.imgur.com/BuCjWBl.gif">http://i.imgur.com/BuCjWBl.gif</a>" title="CHEAT CODES" ></p>

<p>Even adding animations was a breeze! One line of code <code>LayoutAnimation.spring()</code> easily makes all frogs spring into place!</p>

<p><img class="<a" src="href="http://i.imgur.com/cyyYZAS.gif">http://i.imgur.com/cyyYZAS.gif</a>" title="Hop on froggies" ></p>

<p>You can check out the code here <a href="https://github.com/browniefed/flexboxfroggy">https://github.com/browniefed/flexboxfroggy</a></p>

<p>Or if you have Exponent installed you can run it easily on your phone by just tapping this link <a href="http://exp.host/@browniefed/flexboxfroggy">http://exp.host/@browniefed/flexboxfroggy</a></p>

<p>If you don&rsquo;t have Exponent installed I highly suggest you install it!</p>

<p>That&rsquo;s all from me for now. Looking forward to getting back to blogging in 2016!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native Animated Book]]></title>
    <link href="http://browniefed.com/blog/react-native-animated-book/"/>
    <updated>2015-12-23T15:31:00-08:00</updated>
    <id>http://browniefed.com/blog/react-native-animated-book</id>
    <content type="html"><![CDATA[<p>So I wrote a book of sorts on React Native animations. Mostly covering the animated API, and soon much much more. Check it out here <a href="http://browniefed.com/react-native-animation-book/">http://browniefed.com/react-native-animation-book/</a>.</p>

<p>I cover the API, and walk through basic animation examples, and soon advanced topics. Learn to create a fun dragging, spinning square.</p>

<p><img class="<a" src="href="http://browniefed.com/react-native-animation-book/images/SimpleDragAnimation.gif">http://browniefed.com/react-native-animation-book/images/SimpleDragAnimation.gif</a>" title="DragNSpin" ></p>

<p>This is just a quick update :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native - How to bridge a Swift View]]></title>
    <link href="http://browniefed.com/blog/react-native-how-to-bridge-a-swift-view/"/>
    <updated>2015-11-28T11:09:00-08:00</updated>
    <id>http://browniefed.com/blog/react-native-how-to-bridge-a-swift-view</id>
    <content type="html"><![CDATA[<p>So in my previous article we bridged an Objective-C View component, I learned a lot, and also learned that I did a few unnecessary things. No worry though, we&rsquo;ll learn from that and make improvements in our Swift bridging.</p>

<p>First off want to give a thanks to <a href="https://twitter.com/tony_xiao">Tony Xiao</a>. He&rsquo;s been a great help in sharing code and giving explanations to a Swift and native development novice like myself. Also <a href="https://twitter.com/realasa">Asa Miller</a> for writing some of the original code and always collaborating on whatever we&rsquo;re both working on.</p>

<h2>What</h2>

<p><img class="<a" src="href="http://i.imgur.com/TsOMRom.png">http://i.imgur.com/TsOMRom.png</a>" title="Gradients, are those still a thing?" ></p>

<p>We&rsquo;re going to bridge <a href="https://github.com/soffes/GradientView">https://github.com/soffes/GradientView</a>. Looks pretty nifty. Now we could also just use ReactART for this but we won&rsquo;t.</p>

<!-- more -->


<h2>Why Swift?</h2>

<p>It looks more like JavaScript, it&rsquo;s nicer to read (aka less brackets), and seemingly easier to write? I don&rsquo;t know, they say it&rsquo;s the next big thing.</p>

<h2>Why Not Swift?</h2>

<p>Well it can&rsquo;t be turned into a static library&hellip; wut? It seemingly can&rsquo;t be converted into one of those nice <code>.xcodeproj</code> files with a <code>.a</code> that we can easily link. However it can be converted into an <code>.xcodeproj</code> with a <code>.framework</code> we can link, not sure what the difference is but whatever. We&rsquo;ll still go about bridging. We could have also used Pods here, but once again the point of this post is about bridging and not Pods. I&rsquo;ll focus on those later.</p>

<h2>Create a Project</h2>

<p>I won&rsquo;t walk us through bundling up anything into a library, I&rsquo;ll just walk you through developing and integrating a Swift library.</p>

<p>So go ahead and fire off a <code>react-native init GradientTest</code> to create an empty project.</p>

<p>Once that is done open up the project <code>ios/GradientTest.xcodeproj</code> in XCode.</p>

<h2>Add GradientView</h2>

<p>Now lets pull in the <code>GradientView</code> library I had mentioned up above. I pulled it down and just put it in a <code>GradientView</code> folder in the <code>ios</code> directory.</p>

<p>Directory structure looks something like</p>

<p><img class="<a" src="href="http://i.imgur.com/wzIGDYk.png">http://i.imgur.com/wzIGDYk.png</a>" title="Aint nothin but a directory structure img" ></p>

<p>We&rsquo;ll go through the same general process of linking the library as always.</p>

<p>Right click, select <code>Add Files to GradientTest</code> and find the <code>GradientView.xcodeproj</code> that we just pulled down.</p>

<p>When we go to link the library in <code>Build Phases</code> like normal it will actually be <code>GradientView.framework</code> that we are going to link. Should look something like so.</p>

<p><img class="<a" src="href="http://i.imgur.com/6EIs7Vu.png">http://i.imgur.com/6EIs7Vu.png</a>" title="It is all magic to me" ></p>

<p>We&rsquo;ll still get some issues so lets go add <code>$(SRCROOT)/GradientView</code> recursive to the <code>Framework Search Paths</code>
Should look something like</p>

<p><img class="<a" src="href="http://i.imgur.com/bWs3LuJ.png">http://i.imgur.com/bWs3LuJ.png</a>" title="I wish XCode was more magical" ></p>

<h2>Create our Manager and Bridging Header</h2>

<p>We&rsquo;re going to first start off by creating a new <code>.swift</code> file. Simply do that by right clicking on our <code>GradientTest</code> folder, select <code>New file</code> and click on the swift selection and click create.</p>

<p>We&rsquo;ll call this file <code>RNGradientViewManager</code>.</p>

<p><strong> CREATE THE BRIDGING HEADER</strong></p>

<p><img class="<a" src="href="http://i.imgur.com/99mUsRS.png">http://i.imgur.com/99mUsRS.png</a>" title="Bridge across troubled code" ></p>

<p>This is super important. Our briding header file will be named <code>GradientTest-Bridging-Header.h</code>. This allows us to bridge the React View Manager (Objective-C) code into the Swift world.</p>

<p>Or as you can read in the file
```
//
//  Use this file to import your target&rsquo;s public headers that you would like to expose to Swift.
//</p>

<p>```</p>

<p>All we need to do is add our <code>RCTViewManager.h</code> import. So our <code>GradientTest-Bridging-Header.h</code> should just be this</p>

<p>```
//
//  Use this file to import your target&rsquo;s public headers that you would like to expose to Swift.
//</p>

<h1>import &ldquo;RCTViewManager.h&rdquo;</h1>

<p>```</p>

<h2>Add The Manager Code</h2>

<p>Okay now we need to add our Manager code, if you&rsquo;ve read my previous tutorial before on bridging Objective-C, I&rsquo;ve stated that the Manager is just a singleton View producer. Just because it is in swift is no different.</p>

<p><code>RNLinearGradientManager.swift</code></p>

<p>```
import Foundation</p>

<p>@objc(RNLinearGradient)
class RNGradientViewManager : RCTViewManager {
  override func view() &ndash;> UIView! {</p>

<pre><code>return UIView(); // We'll change this later
</code></pre>

<p>  }
}
```</p>

<p>We create an override for the <code>view</code> function, this is what React will call to produce the new view. Thanks to our bridging header we get access to <code>RCTViewManager</code> and create a class called <code>RNGradientViewManager</code>.</p>

<p>The important thing to call out here is the <code>@objc(RNLinearGradientSwift)</code> line. This is an arbitrary name I made up, but what it says is to tell XCode and the compiler to expose the class <code>RNGradientViewManager</code> to the Objective-C world and call it <code>RNLinearGradientSwift</code>.</p>

<h2>The Objective-C React Native Part</h2>

<p>Well at some point we have to dive into a little Objective-C. We&rsquo;ll create a new class and call it <code>RNLinearGradient</code></p>

<p><img class="<a" src="href="http://i.imgur.com/fcBMyIS.png">http://i.imgur.com/fcBMyIS.png</a>" title="How do you say cocoa" ></p>

<p>Then we&rsquo;ll subclass it off of <code>RCTView</code></p>

<p><img class="<a" src="href="http://i.imgur.com/57Vcf0j.png">http://i.imgur.com/57Vcf0j.png</a>" title="Generate code so I do not have to" ></p>

<p>That will create 2 files.</p>

<p><code>RNLinearGradient.h</code>
<code>RNLinearGradient.m</code></p>

<p>This is where we will tell React Native about what we need and what to call our stuff in the JavaScript world.</p>

<h4>First our <code>RNLinearGradient.m</code> file.</h4>

<p>```</p>

<h1>import &ldquo;RNLinearGradient.h&rdquo;</h1>

<h1>import &ldquo;RCTViewManager.h&rdquo;</h1>

<p>@interface RCT_EXTERN_MODULE(RNLinearGradientSwift, RCTViewManager)</p>

<p>RCT_EXPORT_VIEW_PROPERTY(locations, NSArray);
RCT_EXPORT_VIEW_PROPERTY(colors, NSArray);</p>

<p>@end
<code>``
We import our</code>RNLinearGradient.h<code>file we will get ot in a second, as well as our</code>RCTViewManager.h`</p>

<p>See there is our Manager we created and called <code>RNLinearGradientSwift</code>.</p>

<p>We create a new interface and call <code>RCT_EXTERN_MODULE</code> which will tell the JavaScript world about our module called <code>RNLinearGradientSwift</code>.</p>

<p>We&rsquo;ll also export 2 view properties. These are specific to <code>GradientView</code>. Both will be <code>NSArray</code> and take an array of colors and locations to create the gradient.</p>

<h4>Now our <code>RNLinearGradient.h</code> file.</h4>

<p>```</p>

<h1>import &ldquo;RCTView.h&rdquo;</h1>

<p>@interface RNLinearGradient : RCTView</p>

<p>@property (nonatomic, assign) NSArray <em>locations;
@property (nonatomic, assign) NSArray </em>colors;
@end</p>

<p><code>``
We import</code>RCTView` from React code, and then define our 2 properties.</p>

<p>Defining these properties here in this file tells React what properties to apply to the View that gets returned from our <code>view</code> function call in our <code>RNGradientViewManager</code>.</p>

<h2>Back to Swift</h2>

<p>Alright now we are back to swift. We&rsquo;ll go ahead and create a new swift file that will be the view that gets returned from the <code>view</code> function in our <code>RNGradientViewManager</code>.</p>

<p>Create a swift file called <code>RNGradientView</code></p>

<p>```
import Foundation
import GradientView</p>

<p>@objc(RNGradientView)
class RNGradientView : GradientView {
  required init?(coder aDecoder: NSCoder) {</p>

<pre><code>fatalError("init(coder:) has not been implemented")
</code></pre>

<p>  }
}
```</p>

<p>We&rsquo;ll import our <code>GradientView</code> library, and we&rsquo;ll create a class that inherits from it. Previously in my Objective-C tutorial we implemented the <code>addSubviews</code> call however here we&rsquo;ll implement things a bit different and have the view that gets returned the actual <code>GradientView</code>.</p>

<p>The whole <code>required init?(coder aDecoder: NSCoder)</code> part was autogenerated by XCode, it&rsquo;s all magic to me.</p>

<p>Now lets add an init for the frame. The frame is the <code>CGRect</code> that we get given. It tells us our origin <code>x,y</code> and also the size <code>width,height</code> of our view.</p>

<p>```
@objc(RNGradientView)
class RNGradientView : GradientView {</p>

<p>  override init(frame: CGRect) {</p>

<pre><code>super.init(frame: frame);
self.frame = frame;
</code></pre>

<p>  }</p>

<p>  required init?(coder aDecoder: NSCoder) {</p>

<pre><code>fatalError("init(coder:) has not been implemented")
</code></pre>

<p>  }
}
```</p>

<p>We call <code>super.init</code> with our frame, and then also assign <code>self.frame = frame</code>. Remember because we inherited from <code>GradientView</code> the <code>self</code> basically refers to <code>GradientView</code> so when we want to manipulate the <code>GradientView</code> we simply manipulate our <code>self</code>.</p>

<p>Lets add some setters now. We defined 2 different properties up above <code>locations</code> and <code>colors</code>. We now need to create our setters so we can receive the values and set them.</p>

<p>```
@objc(RNGradientView)
class RNGradientView : GradientView {</p>

<p>  override init(frame: CGRect) {</p>

<pre><code>super.init(frame: frame);
self.frame = frame;
</code></pre>

<p>  }</p>

<p>  required init?(coder aDecoder: NSCoder) {</p>

<pre><code>fatalError("init(coder:) has not been implemented")
</code></pre>

<p>  }</p>

<p>  func setLocations(locations: NSArray) {</p>

<pre><code>self.locations = locations.map({ return $0 as! CGFloat});
</code></pre>

<p>  }</p>

<p>  func setColors(colors: NSArray) {</p>

<pre><code>self.colors = colors.map({return RCTConvert.UIColor($0)})
</code></pre>

<p>  }
}
```</p>

<p>Our <code>locations</code> is an <code>NSArray</code> of various values, they are sent over from the JavaScript world like so.</p>

<p><code>&lt;LinearGradient locations={[0.2, 1]} /&gt;</code>, however they will be a mix of <code>doubles</code> and <code>integers</code> but we want everything as a <code>CGFloat</code> which is what <code>GradientView</code> is expecting.</p>

<p>From a JavaScript world you may be used to functional programming, we <code>map</code> over the array which will return a new array. Then we cast whatever values <code>double</code> or <code>integer</code>, etc as <code>CGFloat</code> and set that on <code>self.locations</code>.</p>

<p>Then for <code>colors</code> we&rsquo;ll do something similar. However in our JavaScript world we use the handy <code>processColors</code> provided to use by React. Which will process arbitrary <code>hex</code>, <code>rgb</code>, color names, and others into a value that can easily be passed over the bridge.</p>

<p>The JavaScript code could look something like <code>&lt;LinearGradient colors={['red', 'rgb(255,100,50)']} /&gt;</code>.</p>

<p>We take advantage of the <code>RCTConvert</code> from React which gives us a bunch of handy ways to convert arbitrary values into other values. In our case <code>GradientView</code> expects <code>UIColor</code>s in the shape of an array. So we can once again <code>map</code> over our array of values and pass them into <code>RCTConvert.UIColor</code>.</p>

<h2>Fix Our Manager</h2>

<p>Remember we just left our Manager to return a boring ole <code>UIView</code>, lets go fix it up to return our <code>RNGradientView</code>.</p>

<p>```
import Foundation</p>

<p>@objc(RNLinearGradientSwift)
class RNGradientViewManager : RCTViewManager {
  override func view() &ndash;> UIView! {</p>

<pre><code>return RNGradientView();
</code></pre>

<p>  }
}
```
That sure was hard :)</p>

<h2>JavaScript code</h2>

<p>We will need to write some JavaScript code but it should be pretty harmless.</p>

<p>```
import React, { requireNativeComponent, processColor } from &lsquo;react-native&rsquo;;
let RNLinearGradient = requireNativeComponent(&lsquo;RNLinearGradientSwift&rsquo;, LinearGradient);</p>

<p>class LinearGradient extends React.Component {
  render() {</p>

<pre><code>let { colors, ...otherProps } = this.props;
return &lt;RNLinearGradient {...otherProps} colors={processColor(colors)} /&gt;;
</code></pre>

<p>  }
}</p>

<p>LinearGradient.propTypes = {
  colors: React.PropTypes.array.isRequired,
  locations: React.PropTypes.array,
}</p>

<p>export default LinearGradient;
```</p>

<p>We bring in <code>React</code>, and our <code>requireNativeComponent</code> as well as <code>processColor</code> from React Native.</p>

<p>We create our <code>RNLinearGradient</code> component that we render, and as you can see once again there is our <code>RNLinearGradientSwift</code> that was externalized in our <code>RNGradientViewManager</code> as <code>RNLinearGradientSwift</code>.</p>

<p>We specify our <code>propTypes</code> as arrays.</p>

<p>Then we can pull of <code>colors</code> from <code>this.props</code>, and we call <code>processColor</code> with the array which will automatically map over and return a new array of all processed colors that will work nicely with the <code>RCTConvert.UIColor</code> call.</p>

<h2>HOW DO I USE THIS THING?</h2>

<p>```</p>

<pre><code>    &lt;LinearGradient 
      style={styles.gradient} 
      locations={[0, 1.0]} 
      colors={['#5ED2A0', '#339CB1']}
    /&gt;
</code></pre>

<p><code>``
To use we simply define some values.</code>locations<code>at</code>[0,1]` will specify the first color at 0 position and the second color at the end which is 1.
This can take more than just 2 colors and locations, it will take any number of colors and locations.</p>

<p>```</p>

<pre><code>    &lt;LinearGradient 
      style={styles.gradient} 
      locations={[0, .5, 1.0]} 
      colors={['#5ED2A0', 'red', '#339CB1']}
    /&gt;
</code></pre>

<p>```</p>

<p>Our gradient style is just postioned absolutely so it is basically covering the background as a gradient.</p>

<p>```
  gradient: {</p>

<pre><code>position: 'absolute',
top: 0,
left: 0,
bottom: 0,
right: 0,
</code></pre>

<p>  }
```</p>

<h2>DONE</h2>

<p>Awesome, we&rsquo;re done! You can check the full code up here <a href="https://github.com/asamiller/react-native-gradient">https://github.com/asamiller/react-native-gradient</a>. Yes it&rsquo;s not on my github repo, it&rsquo;s on a friends repo which we collaborated on together. Deal with it.</p>

<p><img class="<a" src="href="http://i.imgur.com/TsOMRom.png">http://i.imgur.com/TsOMRom.png</a>" title="Gradients are neatoooo" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native - How to Bridge an Objective-C View Component]]></title>
    <link href="http://browniefed.com/blog/react-native-how-to-bridge-an-objective-c-view-component/"/>
    <updated>2015-11-24T14:15:00-08:00</updated>
    <id>http://browniefed.com/blog/react-native-how-to-bridge-an-objective-c-view-component</id>
    <content type="html"><![CDATA[<p>I am not an Objective-C developer so some of the things I say here may be wrong, so tell me if I&rsquo;m wrong!
React Native is young enough that some cool existing native components need to still be bridged to take advantage of.
There is plenty of information out there about bridging modules, and view components.</p>

<p>Here are a fiew</p>

<ul>
<li><a href="http://moduscreate.com/leverage-existing-ios-views-react-native-app/">Leverage Existing iOS Views In Your React Native App</a></li>
<li><a href="http://brentvatne.ca/react-native-view-component-1/">React Native View Components (&frac12;)</a></li>
<li><a href="http://brentvatne.ca/react-native-view-component-2/">React Native View Components (2/2)</a></li>
<li><a href="http://brentvatne.ca/packaging-react-native-component/">Packaging a React Native component</a></li>
<li><a href="http://facebook.github.io/react-native/docs/native-components-ios.html#content">Native UI Components &ndash; React Native Documentation</a></li>
</ul>


<p>Some of these are more up to date and in depth and others lesser so.</p>

<h2>What?</h2>

<p><img class="<a" src="href="http://i.imgur.com/GFisosN.gif">http://i.imgur.com/GFisosN.gif</a>" title="NyanNyan Needs Performance" ></p>

<!-- more -->


<h2>What are we bridging?</h2>

<p>We are going to do a very basic bridge of <a href="https://github.com/Flipboard/FLAnimatedImage">FLAnimatedImage</a>.
Basically it&rsquo;s a performant component to render animated gifs.</p>

<p>Straight from their README.</p>

<p>FLAnimatedImage is a performant animated GIF engine for iOS:</p>

<ul>
<li>Plays multiple GIFs simultaneously with a playback speed comparable to desktop browsers</li>
<li>Honors variable frame delays</li>
<li>Behaves gracefully under memory pressure</li>
<li>Eliminates delays or blocking during the first playback loop</li>
<li>Interprets the frame delays of fast GIFs the same way modern browsers do</li>
</ul>


<h2>Creating a Component</h2>

<p>I tend to like to make my component as an application first and then I&rsquo;ll bust it out into a separate component. I already did that, so we&rsquo;ll just focus on the real process.</p>

<p>To do that we&rsquo;ll create a library.</p>

<p>In XCode go to <code>File &gt; New &gt; Project</code> and select <code>Static Library</code></p>

<p>Like so</p>

<p><img class="<a" src="href="http://i.imgur.com/xFBkJfD.png">http://i.imgur.com/xFBkJfD.png</a>" title="Stolen from Brent Vatne" ></p>

<p>Save that somewhere and call it <code>RNFLAnimatedImage</code> so that you can follow along with the tutorial.</p>

<h2>External Dependencies</h2>

<p>In our case we are depending on the FLAnimatedImage library. We have a few different choices, using pods?, using Carthage?, or just copy and pasting.
For the sake of this we&rsquo;re going to copy and paste. We&rsquo;ll get into this when the tutorial actually starts.</p>

<p>I essentially cloned the repo, and copied over the necessary files. You then go through the usual process of adding a library to an XCode project.
You can read about linking libraries here <a href="http://facebook.github.io/react-native/docs/linking-libraries-ios.html#content">http://facebook.github.io/react-native/docs/linking-libraries-ios.html#content</a>.</p>

<p>Basically do this.</p>

<p><img class="<a" src="href="http://i.imgur.com/AfCMdHF.png">http://i.imgur.com/AfCMdHF.png</a>" title="Find the FLAnimatedImage.xcodeporj" ></p>

<p>Then do this</p>

<p><img class="<a" src="href="http://i.imgur.com/BySd9oD.png">http://i.imgur.com/BySd9oD.png</a>" title="Press + and add the framework" ></p>

<h2>Manager vs View</h2>

<p>The Manager is the orchestrator of this particular view we are bridging. It&rsquo;s essentially a singleton (there is just one of them) that when asked will produce a new view to use of whatever kind you define. In our case we have an <code>RNFLAnimatedImageManager</code> that when asked will create an <code>RNFLAnimateImage</code> which will create and setup our <code>FLAnimatedImage</code> Objective-C component.</p>

<p>The Manager is also where we setup the module bridge, and declare what sort of properties we need, event callbacks, and additional constants to export if we need any.</p>

<p>The View portion is just that, the View. This is what will be instantiated and hook into some lifecycle events so you can manipulate the Objective-C world.</p>

<p>Each View will need to do different things during these lifecycle events, it&rsquo;s up to you to implement them and figure out what exactly needs to be handled for the component that you are bridging.</p>

<h2>Life Cycles/Initializer in the Objective C World</h2>

<p>The main life cycle we need to implement is <code>- (void)layoutSubviews</code>.
The other non-lifecycle method that is important is <code>- (instancetype)initWithEventDispatcher:(RCTEventDispatcher *)eventDispatcher</code>.</p>

<p>Additional life cycle calls are <code>- (void)insertReactSubview:(UIView *)view atIndex:(NSInteger)atIndex</code> and <code>- (void)removeReactSubview:(UIView *)subview</code> but we won&rsquo;t talk about those.</p>

<p>The <code>layoutSubviews</code> method gives us an arbitrary hook to control the current view component. You can manipulate the view, add subviews, or add sublayers. In our case we&rsquo;ll add the FLAnimatedImage as a subview.</p>

<p>The <code>initWithEventDispatcher</code> method allows us to handle initialization of the View and additionally save off our <code>eventDispatcher</code> which means we can send messages back to the JavaScript world.</p>

<p>So when you see people sending back callback functions to the native world this is what is sending back the events. So things like <code>onLoad</code>, <code>onVideoProgress</code>, etc you would use this event dispatcher to send out a <code>onLoad</code> or <code>onVideoProgress</code> event name with a payload of data.</p>

<h2>Specifying callbacks</h2>

<p>In a manager file you would specify something like so</p>

<p>```
&ndash; (NSArray *) customDirectEventTypes {
  return @[</p>

<pre><code>       @"onFrameChange"
      ];
</code></pre>

<p>}</p>

<p>```
In our case we may want to listen for when the GIF frame index changes.</p>

<p>We send stuff from Objective-C world to JavaScript like so</p>

<p>```</p>

<pre><code>  [_eventDispatcher sendInputEventWithName:@"onFrameChange" body:@{
                                                                   @"currentFrameIndex":[NSNumber numberWithUnsignedInteger:[object currentFrameIndex]],
                                                                   @"frameCount": [NSNumber numberWithUnsignedInteger:[_image frameCount]],
                                                                   @"target": self.reactTag
                                                                   }];
</code></pre>

<p>```</p>

<p>Then in our JavaScript world we can do this.</p>

<p>```</p>

<pre><code>      &lt;FLAnimatedImage 
        style= 
        src={this.state.url}
        resizeMode={this.state.resizeMode} 
        onFrameChange={(e) =&gt; console.log(e.nativeEvent.currentFrameIndex + '/' + e.nativeEvent.frameCount)}
      /&gt;
</code></pre>

<p>```</p>

<h2>Properties from ObjC to JavaScript</h2>

<p>That looks something like</p>

<p><code>RCTFLAnimatedImageManager.m</code></p>

<p>```</p>

<p>RCT_EXPORT_VIEW_PROPERTY(src, NSString);
RCT_EXPORT_VIEW_PROPERTY(contentMode, NSNumber);</p>

<p>```</p>

<p><code>RCTFLAnimatedImage.m</code></p>

<p>```</p>

<p>@property (nonatomic, assign) NSString <em>src;
@property (nonatomic, assign) NSNumber </em>contentMode;</p>

<p>```</p>

<p>In the JavaScript world when we render our component whatever the <code>src</code> prop is will be put there.</p>

<p>```</p>

<p><RNFlAnimatedImage src="http://someanimated.gif" resizeMode={1} /></p>

<p>```</p>

<p>In the JavaScript world we do need to define our <code>PropTypes</code> on the component.</p>

<p>
```
  propTypes: {</p>

<pre><code>/*
  native only
*/
contentMode: PropTypes.number,
/*

*/
src: PropTypes.string,
resizeMode: PropTypes.string,
onFrameChange: PropTypes.func
</code></pre>

<p>  }</p>

<p>```</p>

<p></p>

<h2>Exporting Constants</h2>

<p>Sometimes there are strings, numbers, enums, etc in the Objective-C world that you may want to use in the JavaScript world. To do this we use the <code>constantsToExport</code> method in our manager.</p>

<p>```
&ndash; (NSDictionary *) constantsToExport {
  return @{</p>

<pre><code>       @"ScaleAspectFit": @(UIViewContentModeScaleAspectFit),
       @"ScaleAspectFill": @(UIViewContentModeScaleAspectFill),
       @"ScaleToFill": @(UIViewContentModeScaleToFill)
      };
</code></pre>

<p>}</p>

<p>```</p>

<p>We export some <code>NSIntegers</code> (converting them to <code>NSNumbers</code> with the <code>@</code>, thanks Google) and this will get put onto React Native <code>NativeModules</code>.</p>

<p>```
React.NativeModules.RNFLAnimatedImageManager;
/*
  {</p>

<pre><code>  ScaleToFill: 0,
  ScaleAspectFit: 1,
  ScaleAspectFill: 2
</code></pre>

<p>  }
*/
```</p>

<h2>Stop?</h2>

<p>Alright that was all a preface to show you the little bits and areas that you can bridge. Maybe you just needed syntax, maybe you wondering about it&rsquo;s capabilities. Either way if you got enough information then no need to go any further. However I encourage you to read on.</p>

<h2>Tutorial Start</h2>

<p>So we have the empty <code>RNFLAnimatedImage</code> project you created right? Go do it now if you haven&rsquo;t already.</p>

<p>The first thing we are going to need to do is setup our <code>Header Search Paths</code> and add React to it.
We&rsquo;ll need to add various locations to tell Objective-C to look for all the <code>.h</code> and <code>.m</code> files.</p>

<p>add these 5</p>

<p><code>
$(inherited)
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include
$(SRCROOT)/../../React
$(SRCROOT)/../react-native/React
$(SRCROOT)/node_modules/react-native/React
</code></p>

<p>It should look something like.</p>

<p><img class="<a" src="href="http://i.imgur.com/GFfRgNV.png">http://i.imgur.com/GFfRgNV.png</a>" title="Header Search Paths for all the Reacts" ></p>

<p><code>FLAnimatedImage</code> ships as a framework, I wasn&rsquo;t able to import the required <code>.h</code> and <code>.m</code> files until I told XCode where to look for <code>FLAnimatedImage</code>.
So lets set that up, add <code>$(SRCROOT)/FLAnimatedImage</code> the <code>Framework Search Paths</code> right above <code>Header Search Paths</code></p>

<p><img class="<a" src="href="http://i.imgur.com/gkkZJ4d.png">http://i.imgur.com/gkkZJ4d.png</a>" title="I have no clue if this is correct" ></p>

<h2>Add Manager Files</h2>

<p>In creating this <code>RNFLAnimatedImage.m/.h</code> were created but lets create our manager files now.
Just right click on the folder select &ldquo;New File&rdquo; and create a <code>.m</code> and name in <code>RNFLAnimatedImageManager.m</code> , same for the <code>.h</code></p>

<p><img class="<a" src="href="http://i.imgur.com/jEQdrce.png">http://i.imgur.com/jEQdrce.png</a>" title="Sponsored by H and M" ></p>

<p>We need to add our new manager files to our compile source.</p>

<p><img class="<a" src="href="http://i.imgur.com/6Kzve8u.png">http://i.imgur.com/6Kzve8u.png</a>" title="Compile sources, what are they good for" ></p>

<h2>RNFLAnimatedImageManager.h</h2>

<p>```</p>

<h1>import &ldquo;RCTViewManager.h&rdquo;</h1>

<p>@interface RNFLAnimatedImageManager : RCTViewManager</p>

<p>@end
<code>``
That's it, we just have our</code>interface<code>we called</code>RNFLAnimatedImageManager<code>and inherit from</code>RCTViewManager` which is provided by React.</p>

<h2>RNFLAnimatedImageManager.m</h2>

<p>First we need to import some stuff</p>

<p>```</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<h1>import &ldquo;RCTBridge.h&rdquo;</h1>

<h1>import &ldquo;RNFLAnimatedImageManager.h&rdquo;</h1>

<h1>import &ldquo;RNFLAnimatedImage.h&rdquo;</h1>

<p><code>``
We bring in the bridging mechanism from React, the</code>Manager.h<code>file, and additionally the</code>.h` for the view we&rsquo;re bridging.</p>

<p>```
@implementation RNFLAnimatedImageManager</p>

<p>RCT_EXPORT_MODULE();</p>

<p>@synthesize bridge = _bridge;</p>

<p>```</p>

<p>Inside our implementation we call <code>RCT_EXPORT_MODULE()</code> that tells React we are exporting a module.</p>

<p>The <code>@synthesize bridge</code> stuff is declaring that we want to just auto generate some getters and setters for our bridge.</p>

<p><code>
- (UIView *)view
{
  return [[RNFLAnimatedImage alloc] initWithEventDispatcher:self.bridge.eventDispatcher];
}
</code>
This is called to create a new view. We are allocating our view <code>RNFLAnimatedImage</code> and initializing it with the <code>eventDispatcher</code> so we can communicate back to the JavaScript world.</p>

<p><code>
- (dispatch_queue_t)methodQueue
{
  return dispatch_get_main_queue();
}
</code>
This has something to do with dispatching :). I think it says that when we dispatch it should go on the main queue?</p>

<p><code>
RCT_EXPORT_VIEW_PROPERTY(src, NSString);
RCT_EXPORT_VIEW_PROPERTY(contentMode, NSNumber);
</code>
Define some properties to bridge.</p>

<p>```
&ndash; (NSArray *) customDirectEventTypes {
  return @[</p>

<pre><code>       @"onFrameChange"
      ];
</code></pre>

<p>}
```
Define some function callback/events we can dispatch.</p>

<p>```
&ndash; (NSDictionary *) constantsToExport {
  return @{</p>

<pre><code>       @"ScaleAspectFit": @(UIViewContentModeScaleAspectFit),
       @"ScaleAspectFill": @(UIViewContentModeScaleAspectFill),
       @"ScaleToFill": @(UIViewContentModeScaleToFill)
      };
</code></pre>

<p>}</p>

<p>@end
```</p>

<p>Finally we define some constants to export and end our implementation.</p>

<p>Link to the file on github <a href="https://github.com/browniefed/react-native-flanimatedimage/blob/master/RNFLAnimatedImage/RNFLAnimatedImage/RNFLAnimatedImageManager.m">https://github.com/browniefed/react-native-flanimatedimage/blob/master/RNFLAnimatedImage/RNFLAnimatedImage/RNFLAnimatedImageManager.m</a>.</p>

<h2>RNFLAnimatedImage.h</h2>

<p>```</p>

<h1>import &ldquo;RCTEventDispatcher.h&rdquo;</h1>

<h1>import &ldquo;FLAnimatedImage/FLAnimatedImage.h&rdquo;</h1>

<p>@class RCTEventDispatcher;</p>

<p>@interface RNFLAnimatedImage : UIView</p>

<p>@property (nonatomic, assign) NSString <em>src;
@property (nonatomic, assign) NSNumber </em>contentMode;</p>

<ul>
<li>(instancetype)initWithEventDispatcher:(RCTEventDispatcher *)eventDispatcher NS_DESIGNATED_INITIALIZER;</li>
</ul>


<p>@end
<code>``
We import our event dispatcher, and tell the compiler that the class</code>RCTEventDispatcher<code>will be defined.
We create our interface, give it the name</code>RNFLAniamtedImage<code>and inherit from the base</code>UIView`.</p>

<p>We add our properties, don&rsquo;t worry about the <code>nonatomic</code> stuff, if you want to know go le google it.</p>

<p>Finally we define our initWithEventDispatcher method that our <code>Manager</code> initialized with. The <code>NS_DESIGNATED_INITIALIZER</code> is to tell the compiler that this is our initializer vs the typical <code>init</code>.</p>

<h2>RNFlAnimatedImage.m</h2>

<p>Alright this will be where all of our bridging work comes into play. Read through the full source here <a href="https://github.com/browniefed/react-native-flanimatedimage/blob/master/RNFLAnimatedImage/RNFLAnimatedImage/RNFLAnimatedImage.m">https://github.com/browniefed/react-native-flanimatedimage/blob/master/RNFLAnimatedImage/RNFLAnimatedImage/RNFLAnimatedImage.m</a>.</p>

<p>So first we need to import stuff and define our basic implementation</p>

<p>```</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<h1>import &ldquo;FLAnimatedImage/FLAnimatedImage.h&rdquo;</h1>

<h1>import &ldquo;RCTBridgeModule.h&rdquo;</h1>

<h1>import &ldquo;RCTEventDispatcher.h&rdquo;</h1>

<h1>import &ldquo;UIView+React.h&rdquo;</h1>

<h1>import &ldquo;RNFLAnimatedImage.h&rdquo;</h1>

<p>@implementation RNFLAnimatedImage : UIView  {</p>

<p>}</p>

<p>@end
```</p>

<p>Don&rsquo;t worry too much about what&rsquo;s getting imported. Most of them are just so React can do it&rsquo;s thing.</p>

<p>
```</p>

<p>@implementation RNFLAnimatedImage : UIView  {</p>

<p>  RCTEventDispatcher <em>_eventDispatcher;
  FLAnimatedImage </em><em>image;
  FLAnimatedImageView *</em>imageView;</p>

<p>}</p>

<p>```</p>

<p></p>

<p>We now define our instance variables that we&rsquo;ll assign inside of this implementation. We setup our <code>eventDispatcher</code>, the <code>image</code> and <code>imageView</code> with their specific types.</p>

<p>```
&ndash; (instancetype)initWithEventDispatcher:(RCTEventDispatcher *)eventDispatcher
{
  if ((self = [super init])) {</p>

<pre><code>_eventDispatcher = eventDispatcher;
_imageView = [[FLAnimatedImageView alloc] init];

[_imageView addObserver:self forKeyPath:@"currentFrameIndex" options:0 context:nil];
</code></pre>

<p>  }</p>

<pre><code>return self;
</code></pre>

<p>}
<code>``
This is our initializer that we had defined. It receives</code>eventDispatcher<code>as the only argument. We then save it off to the</code>eventDispatcher<code>variable we create up above. Then create a new</code>FLAnimatedImageView<code>and save that off. The</code>addObserver<code>we'll get into later, but this is going to allow us to asynchronously hook into the</code>currentFrameIndex` of our animated gif and call the callback.</p>

<p>```</p>

<h1>pragma mark &ndash; React View Management</h1>

<ul>
<li><p>(void)insertReactSubview:(UIView *)view atIndex:(NSInteger)atIndex
{
  RCTLogError(@&ldquo;image cannot have any subviews&rdquo;);
  return;
}</p></li>
<li><p>(void)removeReactSubview:(UIView *)subview
{
  RCTLogError(@&ldquo;image cannot have any subviews&rdquo;);
  return;
}</p></li>
<li><p>(void)layoutSubviews
{
[super layoutSubviews];
<em>imageView.frame = self.bounds;
[self addSubview:</em>imageView];
}
```</p></li>
</ul>


<p>These are the important React added lifecylce methods. The <code>insertReactSubview</code> and <code>removeReactSubview</code> is how we would go about allowing <code>children</code>.</p>

<p>The <code>layoutSubviews</code> is the call that gives us the ability to add in our <code>FLAnimatedImageView</code> that we created into the <code>RNFLAnimatedImage</code> that we are creating. This method is going to be the one that is going to be mostly a custom implementation depending on what components you end up bridging.</p>

<p>The other import thing to call out is <code>self.bounds</code> this is a <code>CGRect</code> that contains <code>x,y</code> and <code>width/height</code> that is going to be provided from the <code>style</code> that is defined in the JavaScript world!</p>

<p>```
&ndash; (void)setSrc:(NSString *)src
{
  if (![src isEqual:_src]) {</p>

<pre><code>_src = [src copy];
[self reloadImage];
</code></pre>

<p>  }
}</p>

<ul>
<li>(void)setContentMode:(NSNumber *)contentMode
{
if(![contentMode isEqual:<em>contentMode]) {
  </em>contentMode = [contentMode copy];
  [self reloadImage];
}
}
<code>``
These are setters that we hook into so that when a</code>setState<code>happens and a re-render is triggered in the JavaScript world these get called. We check if our</code>src<code>is different and or if our</code>contentMode<code>is different, if it is we set our instance variables to the new values and call</code>reloadImage`.</li>
</ul>


<p><code>
-(void)reloadImage {
  _image = [FLAnimatedImage animatedImageWithGIFData:[NSData dataWithContentsOfURL:[NSURL URLWithString:_src]]];
  _imageView.contentMode = [_contentMode integerValue];
  _imageView.animatedImage = _image;
}
</code></p>

<p>Our reload image is more of a setup/modify image. We set our <code>image</code> to be the <code>FLAnimatedImage</code> with the gif data from a URL. We pass our <code>src</code> in there which comes from the bridged value from the JavaScript world.</p>

<p>We setup our contentMode on the <code>imageView</code> then set our <code>imageView.animatedImage</code> to be the <code>image</code> of the url.</p>

<p>```
&ndash;(void)observeValueForKeyPath:(NSString <em>)keyPath ofObject:(id)object change:(NSDictionary<NSString *,id> </em>)change context:(void *)context {
  if (object == _imageView) {</p>

<pre><code>if ([keyPath isEqualToString:@"currentFrameIndex"]) {
  [_eventDispatcher sendInputEventWithName:@"onFrameChange" body:@{
                                                                   @"currentFrameIndex":[NSNumber numberWithUnsignedInteger:[object currentFrameIndex]],
                                                                   @"frameCount": [NSNumber numberWithUnsignedInteger:[_image frameCount]],
                                                                   @"target": self.reactTag
                                                                   }];
}
</code></pre>

<p>  }
}
```</p>

<p>When observers get setup (like we did in the initializer) the <code>observerveValueForKeyPath</code> method will be called with the information about the thing that changed.
In our case <code>object</code> was setup to be our <code>imageView</code> and the <code>keyPath</code> was <code>currentFrameIndex</code>.</p>

<p>We do some checking to make sure that the <code>object</code> is in fact our <code>imageView</code>, and that the <code>keyPath</code> we are dealing with is the <code>currentFrameIndex</code>. If it is this when we send our event to be dispatched. It just so happens to be named <code>onFrameChange</code> and our <code>body</code> can be custom crafted and will be ultimately translated into JSON for us. We pass back the <code>currentFrameIndex</code> and the total <code>frameCount</code> as well as the React Component we are dealing with.</p>

<p>```
&ndash; (void)removeFromSuperview
{</p>

<pre><code>[_imageView removeObserver:self forKeyPath:@"currentFrameIndex"];
_eventDispatcher = nil;
_image = nil;
_imageView = nil;
[super removeFromSuperview];
</code></pre>

<p>}
```</p>

<p>Finally the <code>removeFromSuperview</code> function is called. This is the equivalence of <code>componentWillUnmount</code> in the React JavaScript world. Here we clean up the observer, as well as the other things we have created.</p>

<p>You are now done with Objective-C! Check out the full source code here <a href="https://github.com/browniefed/react-native-flanimatedimage/blob/master/RNFLAnimatedImage/RNFLAnimatedImage/RNFLAnimatedImage.m">https://github.com/browniefed/react-native-flanimatedimage/blob/master/RNFLAnimatedImage/RNFLAnimatedImage/RNFLAnimatedImage.m</a>.</p>

<h2>FLAnimatedImage.js</h2>

<p>Now we are back in our JavaScript world. We&rsquo;ve done the hard part.</p>

<p>```
var React = require(&lsquo;react-native&rsquo;);
var { requireNativeComponent, PropTypes, NativeModules, } = React;</p>

<p>var {
  ScaleToFill,
  ScaleAspectFit,
  ScaleAspectFill
} = NativeModules.RNFLAnimatedImageManager;</p>

<p>var MODES = {
  &lsquo;stretch&rsquo;: ScaleToFill,
  &lsquo;contain&rsquo;: ScaleAspectFit,
  &lsquo;cover&rsquo;: ScaleAspectFill
}</p>

<p>var FLAnimatedImage = React.createClass({
  propTypes: {</p>

<pre><code>/*
  native only
*/
contentMode: PropTypes.number,
/*

*/
src: PropTypes.string,
resizeMode: PropTypes.string,
onFrameChange: PropTypes.func
</code></pre>

<p>  },
  render() {</p>

<pre><code>var contentMode = MODES[this.props.resizeMode] || MODES.stretch;
return (
        &lt;RNFLAnimatedImage 
            {...this.props} 
            contentMode={contentMode}
        /&gt;
      );
</code></pre>

<p>  },
});</p>

<p>var RNFLAnimatedImage = requireNativeComponent(&lsquo;RNFLAnimatedImage&rsquo;, FLAnimatedImage);</p>

<p>module.exports = FLAnimatedImage;
```</p>

<p>The important parts to call out is that all values being passed to the component/native world need to have a <code>PropType</code> specified! If you noticed something a bit weird. We create a class called <code>FLAnimatedImage</code> which we call to <code>requireNativeComponent</code> that creates <code>RNFLAnimatedImage</code> which then <code>FLAnimatedImage</code> renders. Weird cyclic thing, but ultimately it allows us to tell React what component our class is going to need to be rendered.</p>

<p>The <code>MODES</code> thing is just so we can map a nice string the user can give us to one of the constants that we exported from our Objective-C world.</p>

<h2>DONE!</h2>

<p>Hey look you did it. We got through the weird brackted world of Objective-C. To use it we require it and pass in our props.

```</p>

<pre><code>      &lt;FLAnimatedImage 
        style={{flex: 1}} 
        src="http://raphaelschaad.com/static/nyan.gif"
        resizeMode="contain" 
        onFrameChange={(e) =&gt; console.log(e.nativeEvent.currentFrameIndex + '/' + e.nativeEvent.frameCount)}
      /&gt;
</code></pre>

<p>```
</p>

<h2>Final Code</h2>

<p>The code is all up on github, check the repo out here <a href="https://github.com/browniefed/react-native-flanimatedimage">https://github.com/browniefed/react-native-flanimatedimage</a> and the folder where the Objective-C code is at is right here <a href="https://github.com/browniefed/react-native-flanimatedimage/tree/master/RNFLAnimatedImage/RNFLAnimatedImage">https://github.com/browniefed/react-native-flanimatedimage/tree/master/RNFLAnimatedImage/RNFLAnimatedImage</a>.</p>

<p>Now we have a bridge AnimatedGif component at our exposure.</p>

<p><img class="<a" src="href="http://i.imgur.com/GFisosN.gif">http://i.imgur.com/GFisosN.gif</a>" title="Now that is stuck in your head" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native - How to create Twitter exploding hearts]]></title>
    <link href="http://browniefed.com/blog/react-native-how-to-create-twitter-exploding-hearts/"/>
    <updated>2015-11-07T08:55:00-08:00</updated>
    <id>http://browniefed.com/blog/react-native-how-to-create-twitter-exploding-hearts</id>
    <content type="html"><![CDATA[<p>So we&rsquo;re going to build this exploding heart, except just know Twitter kind of cheated. Not really but they used an image and played each frame adjusting <code>background-position</code> so it looked animated. Okay not cheated they used a really smart technique but what&rsquo;s the fun in doing that when we can build it for real!</p>

<p>I&rsquo;ve already built a Firework concept here <a href="http://browniefed.com/blog/2015/08/29/react-native-animated-with-react-art-firework-show/">http://browniefed.com/blog/2015/08/29/react-native-animated-with-react-art-firework-show/</a> and about Hearts here <a href="http://browniefed.com/blog/2015/09/07/react-native-periscope-hearts-animation/">http://browniefed.com/blog/2015/09/07/react-native-periscope-hearts-animation/</a> now we just need to bring them together.</p>

<p>For the record this is what theirs looks like here <a href="http://i.imgur.com/3a8PiSY.png">http://i.imgur.com/3a8PiSY.png</a></p>

<h2>What are we building</h2>

<p><img class="<a" src="href="http://i.imgur.com/lMOxqIL.gif">http://i.imgur.com/lMOxqIL.gif</a>" title="So not lazy like Twitter" ></p>

<!-- more -->


<h2>Concept</h2>

<p>Rather than iterating over 28 separate image frames what we&rsquo;re going to do instead is make some pseudo-keyframe-animations. We&rsquo;ll use <code>Animated</code> of course. We&rsquo;ll define our range from <code>0</code> to <code>28</code>. Meaning we&rsquo;ll have 28 frames to deal with.</p>

<p>This makes the math easy, because we can walk through each frame, and describe what the animation should look like for each frame.</p>

<p>We could create separate animated values for each property and coordinate the animation with <code>Animated.sequence</code> and <code>Animated.parallel</code> but I prefer interpolation. YMMV</p>

<h2>Setup</h2>

<p>```
var React = require(&lsquo;react-native&rsquo;);</p>

<p>var {
  AppRegistry,
  StyleSheet,
  View,
  Dimensions,
  TouchableWithoutFeedback,
  Animated
} = React;</p>

<p>var Art = require(&lsquo;ReactNativeART&rsquo;);</p>

<p>var {
  Surface,
  Group,
  Shape,
  Path
} = Art;</p>

<p>var AnimatedShape = Animated.createAnimatedComponent(Shape);</p>

<p>var {
  width: deviceWidth,
  height: deviceHeight
} = Dimensions.get(&lsquo;window&rsquo;);</p>

<p><code>``
We'll need to setup</code>ReactNativeArt` in XCode, you can check out how to do that <a href="http://browniefed.com/blog/2015/05/03/getting-react-art-running-on-react-native/">here</a>.</p>

<p>Things to call out here is we are creating a custom animated view, called <code>AnimatedShape</code>. We pass in the <code>art</code> <code>Shape</code> component into <code>Animated.createAnimatedComponent</code>. This allows us to use <code>Animated</code> values in any component.</p>

<h2>More Setup</h2>

<p>```
var HEART_SVG = &ldquo;M130.4-0.8c25.4 0 46 20.6 46 46.1 0 13.1-5.5 24.9-14.2 33.3L88 153.6 12.5 77.3c-7.9-8.3-12.8-19.6-12.8-31.9 0-25.5 20.6-46.1 46-46.2 19.1 0 35.5 11.7 42.4 28.4C94.9 11 111.3-0.8 130.4-0.8&rdquo;
var HEART_COLOR = &lsquo;rgb(226,38,77,1)&rsquo;;
var GRAY_HEART_COLOR = &ldquo;rgb(204,204,204,1)&rdquo;;</p>

<p>var FILL_COLORS = [
  &lsquo;rgba(221,70,136,1)&rsquo;,
  &lsquo;rgba(212,106,191,1)&rsquo;,
  &lsquo;rgba(204,142,245,1)&rsquo;,
  &lsquo;rgba(204,142,245,1)&rsquo;,
  &lsquo;rgba(204,142,245,1)&rsquo;,
  &lsquo;rgba(0,0,0,0)&rsquo;
];</p>

<p>var PARTICLE_COLORS = [
  &lsquo;rgb(158, 202, 250)&rsquo;,
  &lsquo;rgb(161, 235, 206)&rsquo;,
  &lsquo;rgb(208, 148, 246)&rsquo;,
  &lsquo;rgb(244, 141, 166)&rsquo;,
  &lsquo;rgb(234, 171, 104)&rsquo;,
  &lsquo;rgb(170, 163, 186)&rsquo;
]
```</p>

<p>More setup here. We create our heart SVG path to render, and setup a bunch of colors that we will use in our animations later. We need to set stuff up as <code>rgb</code> or <code>rgba</code> so that <code>Animated</code> can interpolate it correctly as at the moment it cannot do hex values.</p>

<p>```</p>

<p>function getXYParticle(total, i, radius) {
  var angle = ( (2*Math.PI) / total ) * i;</p>

<p>  var x = Math.round((radius<em>2) * Math.cos(angle &ndash; (Math.PI/2)));
  var y = Math.round((radius</em>2) * Math.sin(angle &ndash; (Math.PI/2)));
  return {</p>

<pre><code>x: x,
y: y
</code></pre>

<p>  }
}</p>

<p>function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max &ndash; min)) + min;
}</p>

<p>function shuffleArray(array) {</p>

<pre><code>for (var i = array.length - 1; i &gt; 0; i--) {
    var j = Math.floor(Math.random() * (i + 1));
    var temp = array[i];
    array[i] = array[j];
    array[j] = temp;
}
return array;
</code></pre>

<p>}</p>

<p><code>``
Yes more setup.</code>getXYParticle` is a function I&rsquo;ve modified from the fireworks particle blog post I wrote. This essentially distributes a random number of particles around a circle. This is what we will use for the little particles that blow up.</p>

<p>The <code>getRandomInt</code> is pretty self explanatory, but it just returns a random number and we&rsquo;ll use it to create some variance.</p>

<p><code>shuffleArray</code> also just shuffles things in an array, we&rsquo;ll use this to achieve random color effects later.</p>

<h2>Blank Canvas</h2>

<p>```
var ExplodingHearts = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
  animation: new Animated.Value(0) 
};
</code></pre>

<p>  },
  explode: function() {</p>

<pre><code>Animated.timing(this.state.animation, {
  duration: 1500,
  toValue: 28
}).start(() =&gt; {
  this.state.animation.setValue(0);
  this.forceUpdate();
}.bind(this));
</code></pre>

<p>  },</p>

<p>  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
    &lt;TouchableWithoutFeedback onPress={this.explode} style={styles.container}&gt; 
      &lt;View&gt;
        &lt;Surface width={deviceWidth} height={deviceHeight}&gt;
        &lt;/Surface&gt;
      &lt;/View&gt;
    &lt;/TouchableWithoutFeedback&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
});</p>

<p>```</p>

<p>We setup a blank canvas. We need to create our initial <code>animation</code> value so we just do a <code>new Animated.Value(0)</code> in our <code>getInitialState</code>.</p>

<p>We setup a <code>TouchableWithoutFeedback</code> for the ability to use <code>onPress</code> to trigger our animation. We then setup our <code>ART</code> <code>Surface</code> to fill the screen.</p>

<p>Why are we using ART for this? Well it&rsquo;ll make our rendering and animations very efficient, we could use a bunch of <code>Views</code> for this demo but on a large scale with lots of graphics work you should use <code>ART</code></p>

<p>Our <code>explode</code> function kicks off our animation and we do it over 1.5 seconds. We will animate to 28 because that is how many &ldquo;frames&rdquo; we have.</p>

<p>Don&rsquo;t worry about the callback, that&rsquo;s just to reset the animation when it is done, and also the <code>forceUpdate</code> re-renders so we get new random values on each subsequent trigger.</p>

<h2>Render A Heart</h2>

<p>```
<Surface width={deviceWidth} height={deviceHeight}></p>

<pre><code>&lt;AnimatedShape
  d={HEART_SVG}
  x={0}
  y={0}
  scale={1}
  fill={GRAY_HEART_COLOR}
/&gt;
</code></pre>

<p></Surface>
```</p>

<p>We just render a heart, pass in our SVG path, put it at the top left <code>0,0</code> coordinates. Scale is set to 1 and we fill it with our <code>GRAY_HEART_COLOR</code> we setup above.</p>

<h2>Talking Keyframes and Animations</h2>

<p>Before we dive in I want to explain what is about to happen. The original Twitter exploding has 28 frames. Our animation will start at <code>0</code>, and that is our default state. So we&rsquo;ll need to set everything up to default when we start <code>0</code> (initial render).</p>

<p>Then anytime from <code>1</code> to <code>28</code> we will need to design our values so that they produce the correct frame animation.</p>

<p><code>Animated</code> provides a way to interpolate. What that means is given a value, we want it to go through a formula and spit out another value. <code>Animated</code> does this via ranges, which can at times be a little inflexible and we have to hack around it&rsquo;s shortcomings to get desired effects.</p>

<p>All (well almost all) our animations will be interpolating from the single <code>this.state.animation</code> that we created earlier. This just makes it easy to comprehend and layout your animation frames. Because you can then specify that something happens at frame <code>10</code> instead of dividing <code>1/28</code> and say start at <code>0.03571428571</code>.</p>

<h2>Scale it up</h2>

<p>```
render: function() {</p>

<pre><code>var heart_scale = this.state.animation.interpolate({
  inputRange: [0, .01, 6, 10, 12, 18, 28],
  outputRange: [1, 0, .1, 1, 1.2, 1, 1],
  extrapolate: 'clamp'
});

var heart_fill = this.state.animation.interpolate({
  inputRange: [0, 2],
  outputRange: [GRAY_HEART_COLOR, HEART_COLOR],
  extrapolate: 'clamp'
})

var heart_x = heart_scale.interpolate({
  inputRange: [0, 1],
  outputRange: [90, 0],
})

var heart_y = heart_scale.interpolate({
  inputRange: [0, 1],
  outputRange: [75, 0],
})
</code></pre>

<p>}
```</p>

<p>Alright there is a lot going on. Lets break it down.</p>

<p>```</p>

<pre><code>var heart_scale = this.state.animation.interpolate({
  inputRange: [0, .01, 6, 10, 12, 18],
  outputRange: [1, 0, .1, 1, 1.2, 1],
  extrapolate: 'clamp'
});
</code></pre>

<p><code>``
We</code>interpolate<code>on the</code>this.state.animation<code>and give it an</code>inputRange<code>and</code>outputRange` array. These must have the same amount of array values.</p>

<p>I talked about some weird things with <code>Animated</code> and setting up defaults. Well <code>inputRange: [0, .01], outputRange: [1, 0]</code> is the first example.</p>

<p>At 0 we want it to be fully scaled, so output at 1. However as soon as the animation is triggered we want it to be at 0. If we only specified <code>0, 1</code> as the inputRange, it would have the heart scale down from 1 to 0. So specifying the scale inputRange at <code>0 =&gt; .01</code> means it&rsquo;ll basically disappear.</p>

<p>It&rsquo;s essentially a way to make an animation not a whole frame, and or happen virtually immediately.</p>

<p>There is a slight spring in the heart. So from frame <code>10</code> to <code>12</code> it will spring up fast to <code>1.2</code> scale, and then slowly fall back from <code>1.2</code> to <code>1</code> from frames <code>12</code> to <code>18</code>.</p>

<p><code>extrapolate: 'clamp'</code> IS EXTREMELY IMPORTANT HERE. If we want it to just stay the same once it hits frame 18 and not do anything else until the end we must add the clamp. Otherwise it will continue to animate at the current stepping value, so it would scale down below 1 and we don&rsquo;t want that.</p>

<p>```</p>

<pre><code>var heart_fill = this.state.animation.interpolate({
  inputRange: [0, 2],
  outputRange: [GRAY_HEART_COLOR, HEART_COLOR],
  extrapolate: 'clamp'
})
</code></pre>

<p><code>``
We have the heart hidden after frame</code>1<code>, so what this animation says is at</code>0` , inital render, be gray. Anytime from frame 2 and out be red, and always be read.</p>

<p>```</p>

<pre><code>var heart_x = heart_scale.interpolate({
  inputRange: [0, 1],
  outputRange: [90, 0],
})

var heart_y = heart_scale.interpolate({
  inputRange: [0, 1],
  outputRange: [75, 0],
})
</code></pre>

<p>```</p>

<p>This is the one part where we don&rsquo;t want to base things on the key frame. Because there is no <code>transform-origin</code> like there is in CSS, the default scale will scale out to the top left.
That isn&rsquo;t what we want.</p>

<p>So to scale out to the center we need to animate the x/y while scaling, so we interpolate off the interpolate for scale. Remember we default our scale up above to 1, so we are reversing stuff here saying when the scale is scaling down from 0 to 1 adjust to 90 for x and 75 for y.</p>

<p>The 90/75 just has to deal with the current surface center.</p>

<p>```</p>

<pre><code>return (
    &lt;Surface width={deviceWidth} height={deviceHeight}&gt;
        &lt;AnimatedShape
          d={HEART_SVG}
          x={heart_x}
          y={heart_y}
          scale={heart_scale}
          fill={heart_fill}
        /&gt;
    &lt;/Surface&gt;

)
</code></pre>

<p>```</p>

<p>We use our <code>AnimatedShape</code> and pass in the animated values we created. A lot of things I explain up above are the basic concepts through out this tutorial so I wont' explain them again.</p>

<h2>Add a Circle</h2>

<p>```
var AnimatedCircle = React.createClass({displayName: &ldquo;Circle&rdquo;,
  render: function() {</p>

<pre><code>var radius = this.props.radius;
var path = Path().moveTo(0, -radius)
    .arc(0, radius * 2, radius)
    .arc(0, radius * -2, radius)
    .close();
return React.createElement(AnimatedShape, React.__spread({},  this.props, {d: path}));
</code></pre>

<p>  }
});
```</p>

<p>This is taken from previous firework demos and default ReactART, but I&rsquo;ve converted it to use our <code>AnimatedShape</code> we created up above.</p>

<p>```
<Surface width={deviceWidth} height={deviceHeight}>
  <Group x={100} y={200}></p>

<pre><code>&lt;AnimatedShape
  d={HEART_SVG}
  x={heart_x}
  y={heart_y}
  scale={heart_scale}
  fill={heart_fill}
/&gt;
&lt;AnimatedCircle
  x={90}
  y={75}
  radius={150}
  scale={1}
  strokeWidth={3}
  fill="#000"
  opacity={1}
/&gt;
</code></pre>

<p>  </Group>
</Surface>
```</p>

<p>We render an arbitrary circle, at <code>90</code> and <code>75</code> which is the center of our current surface.</p>

<h2>Blow that Circle Up</h2>

<p>```</p>

<pre><code>var circle_scale = this.state.animation.interpolate({
  inputRange: [0, 1, 4],
  outputRange: [0, .3, 1],
  extrapolate: 'clamp'
});

var circle_stroke_width = this.state.animation.interpolate({
  inputRange: [0, 5.99, 6, 7, 10],
  outputRange: [0, 0, 15, 8, 0],
  extrapolate: 'clamp'
});

var circle_fill_colors = this.state.animation.interpolate({
  inputRange: [1, 2, 3, 4, 4.99, 5],
  outputRange: FILL_COLORS,
  extrapolate: 'clamp'
})

var circle_opacity = this.state.animation.interpolate({
  inputRange: [1,9.99, 10],
  outputRange: [1, 1, 0],
  extrapolate: 'clamp'
})
</code></pre>

<p>```</p>

<p>Alright so we scale up, based on the image we scale up to <code>.3</code> in a single frame, then over the course of 3 frames we scale up our circle to a scale of 1.</p>

<p>Our stroke width also changes however we won&rsquo;t always render it. We only need it for a few frames starting at frame 6. So we will specify that the stroke width stays at <code>0</code> from <code>0</code> to frame <code>5.99</code>.</p>

<p>Then over the course of 1 frame it goes to 15 which I chose at random, down to 8, and eventually 0 by frame 10.</p>

<p>We specify a range of colors in the array I talked about in setup. The weird part is that we have to specify the final color a few times before setting the fill to transparent. The reason is that if we specify just the transparent color the purple color will fade out to transparent but we want it to completely disappear and just show the stroke.</p>

<p>So we have to coordinate stroke frames appearing with the fill color disappearing.</p>

<p>Finally our opacity stays 1 until frame 9.99 (the end of our circle stroke) then we kill it on frame 10.</p>

<p>```</p>

<pre><code>&lt;AnimatedCircle
  x={89}
  y={75}
  radius={150}
  scale={circle_scale}
  strokeWidth={circle_stroke_width}
  stroke={FILL_COLORS[2]}
  fill={circle_fill_colors}
  opacity={circle_opacity}
/&gt;
</code></pre>

<p>```
We put those in and because our stroke color is always the same we just reference our fill colors.</p>

<h2>Bunch of Circles Blowing Up</h2>

<p>```
<Surface width={deviceWidth} height={deviceHeight}>
  <Group x={100} y={200}></p>

<pre><code>&lt;AnimatedShape
  d={HEART_SVG}
  x={heart_x}
  y={heart_y}
  scale={heart_scale}
  fill={heart_fill}
/&gt;
&lt;AnimatedCircle
  x={90}
  y={75}
  radius={150}
  scale={circle_scale}
  strokeWidth={circle_stroke_width}
  stroke={FILL_COLORS[2]}
  fill={circle_fill_colors}
  opacity={circle_opacity}
/&gt;

{this.getSmallExplosions(150, {x:90, y:75})}
</code></pre>

<p>  </Group>
</Surface>
```</p>

<p>Alright now we setup our final piece. Calling <code>getSmallExplosions</code> with some data. In our case the radius of our circle and the central coordinates.</p>

<p>```
  getSmallExplosions: function(radius, offset) {</p>

<pre><code>return [0,1,2,3,4,5,6].map((v, i, t) =&gt; {

  var scaleOut = this.state.animation.interpolate({
    inputRange: [0, 5.99, 6, 13.99, 14, 21],
    outputRange: [0, 0, 1, 1, 1, 0],
    extrapolate: 'clamp'
  });

  var moveUp = this.state.animation.interpolate({
    inputRange: [0, 5.99, 14],
    outputRange: [0, 0, -15],
    extrapolate: 'clamp'
  });

  var moveDown = this.state.animation.interpolate({
    inputRange: [0, 5.99, 14],
    outputRange: [0, 0, 15],
    extrapolate: 'clamp'
  });

  var color_top_particle = this.state.animation.interpolate({
    inputRange: [6, 8, 10, 12, 17, 21],
    outputRange: shuffleArray(PARTICLE_COLORS)
  })

  var color_bottom_particle = this.state.animation.interpolate({
    inputRange: [6, 8, 10, 12, 17, 21],
    outputRange: shuffleArray(PARTICLE_COLORS)
  })

  var position = getXYParticle(7, i, radius)

  return (
    &lt;Group 
      x={position.x + offset.x } 
      y={position.y + offset.y} 
      rotation={getRandomInt(0, 40) * i}
    &gt;
      &lt;AnimatedCircle 
        x={moveUp}
        y={moveUp}
        radius={15} 
        scale={scaleOut} 
        fill={color_top_particle} 
      /&gt;
      &lt;AnimatedCircle 
        x={moveDown}
        y={moveDown}
        radius={8} 
        scale={scaleOut} 
        fill={color_bottom_particle} 
      /&gt;
    &lt;/Group&gt;
  )
}, this)
</code></pre>

<p>  },
```</p>

<p>Not going to explain this one too indepth or I&rsquo;ll keep repeating myself. We create a bunch of animations for each particle but add some randomness into the mix. We call <code>shuffleArray</code> on our <code>PARTICLE_COLORS</code> so over the course of the frames it is active it&rsquo;ll animate to random colors for each particle.</p>

<p>Also we add a bit of <code>rotation</code> to the group, so when we animate the particles up/down they&rsquo;ll go in all different directions.</p>

<h2>Done</h2>

<p>Now you too can add a new interaction that all of your users will despise! No this isn&rsquo;t a perfect replica of the the Twiter animation because I added color variance and some random rotation to the small exploding/shrinking circles.</p>

<p><img class="<a" src="href="http://i.imgur.com/lMOxqIL.gif">http://i.imgur.com/lMOxqIL.gif</a>" title="That is hot" ></p>

<h3>Interactive Demo at <a href="https://rnplay.org/apps/nJjHdw">https://rnplay.org/apps/nJjHdw</a></h3>

<p>I&rsquo;m not posting the full code, this is a long one. Just check it out on RNPlay.</p>
]]></content>
  </entry>
  
</feed>
