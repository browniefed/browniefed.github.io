<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: react-native | JavaScript Without Grammar]]></title>
  <link href="http://browniefed.com/blog/categories/react-native/atom.xml" rel="self"/>
  <link href="http://browniefed.com/"/>
  <updated>2015-09-01T22:06:47-07:00</updated>
  <id>http://browniefed.com/</id>
  <author>
    <name><![CDATA[Jason Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[React Native Youtube Animated Video Slide]]></title>
    <link href="http://browniefed.com/blog/2015/08/31/react-native-youtube-animated-video-slide/"/>
    <updated>2015-08-31T08:58:00-07:00</updated>
    <id>http://browniefed.com/blog/2015/08/31/react-native-youtube-animated-video-slide</id>
    <content type="html"><![CDATA[<h1>Introduciton</h1>

<p>I was going to spend some time digging into <a href="https://github.com/ProjectSeptemberInc/gl-react-native">gl-react-native</a> when someone asked in the slack channel how to achieve youtube like video sliding navigation. Now I won&rsquo;t get into the navigation portion, just the animation part. The navigation portion can be solved by basically treating video routes as a modal. Thus they are always over the top of whatever the previous route was.</p>

<h1>What are we building?</h1>

<p>If you haven&rsquo;t seen it, YouTube allows you to drag the current playing video down to the bottom right corner and have it continue to play while you browse the rest of the app.</p>

<p>Something like this.</p>

<p><img class="<a" src="href="http://i.imgur.com/gwbkw5f.gif">http://i.imgur.com/gwbkw5f.gif</a>" title="YouTube demo clone" ></p>

<!-- more -->


<h1>Setup</h1>

<p>React native doesn&rsquo;t have a <code>Video</code> component but Brent Vatne created a fantastic video component called <a href="https://github.com/brentvatne/react-native-video">react-native-video</a>. This allows you to use videos added to your app bundle, or external video urls.</p>

<p>So unlike a normal project you will need to run <code>npm install react-native-video --save</code>. Then follow the instructions on the <code>README</code> in <code>react-native-video</code> on how to add the library in XCode.</p>

<p>```
var React = require(&lsquo;react-native&rsquo;);
var Video = require(&lsquo;react-native-video&rsquo;);</p>

<p>var Dimensions = require(&lsquo;Dimensions&rsquo;);
var {width: deviceWidth, height: deviceHeight} = Dimensions.get(&lsquo;window&rsquo;);</p>

<p>var videoWidth = deviceWidth,</p>

<pre><code>videoHeight = Math.round((deviceWidth/16)*9);
</code></pre>

<p>var {
  AppRegistry,
  StyleSheet,
  View,
  Text,
  Animated,
  PanResponder,
  ScrollView
} = React;</p>

<p>var AnimatedVideo = Animated.createAnimatedComponent(Video);
var AnimatedScrollView = Animated.createAnimatedComponent(ScrollView);</p>

<p>```</p>

<p>So a few things to call out here.</p>

<p>We pull in dimensions of the screen and name them <code>deviceHeight</code> and <code>deviceWidth</code>. This is so we can calculate <code>videoWidth</code> and <code>videoHeight</code>. We use a simple calculation to create a video that is in the <code>16:9</code> aspect ratio.</p>

<p>Then we use <code>createAnimatedComponent</code> to create an animated <code>ScrollView</code> and <code>AnimatedVideo</code> element.</p>

<h1>Basic Component</h1>

<p>```
var YoutubeVideoSlide = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
  scale: new Animated.Value(1),
  position: new Animated.ValueXY(),
};
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
          &lt;AnimatedVideo 
              source=
              style={styles.videoSizing}
              rate={1}
              paused={false}
              volume={1}
              resizeMode={'stretch'}
              repeat={true} 
          /&gt;
        &lt;AnimatedScrollView style={styles.container}&gt;
          &lt;View style={styles.comment}&gt;
            &lt;Text&gt;Video Comment&lt;/Text&gt;
          &lt;/View&gt;
        &lt;/AnimatedScrollView&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
});</p>

<p>var styles = StyleSheet.create({
  container: {</p>

<pre><code>flex: 1
</code></pre>

<p>  },
  videoSizing: {</p>

<pre><code>width: videoWidth,
height: videoHeight
</code></pre>

<p>  },
  comment: {</p>

<pre><code>height: 100
</code></pre>

<p>  }
});</p>

<p>```</p>

<p>We setup <code>flex:1</code> on the <code>View</code> so that the <code>ScrollView</code> will size correctly. We set the <code>width</code> and <code>height</code> on the <code>AnimatedVideo</code> to our <code>16:9</code> ratio. In the state we setup the initial scale to <code>1</code>, and an <code>X,Y</code> position for the moving video.</p>

<h1>Setup the PanResponder</h1>

<p>```</p>

<pre><code>this._panResponder = PanResponder.create({
  onStartShouldSetPanResponder: (evt, gestureState) =&gt; true,
  onStartShouldSetPanResponderCapture: (evt, gestureState) =&gt; true,
  onMoveShouldSetPanResponder: (evt, gestureState) =&gt; true,
  onMoveShouldSetPanResponderCapture: (evt, gestureState) =&gt; true,
  onPanResponderMove: Animated.event([
      null, 
      {
          dy: this.state.position.y
      }
  ])
});
</code></pre>

<p>```</p>

<p>We&rsquo;ll do the normal &ldquo;say yes to allowing us to touch things&rdquo;, and then we&rsquo;ll setup an <code>Animated.event</code>. This is a helper function to traverse the arguments from <code>onPanResponderMove</code> and update an Animated value.</p>

<p><code>onPanResponderMove</code> gets called with an <code>event</code> as the first argument, and <code>gestureState</code> as the second. The <code>null</code> tells <code>Animated.event</code> to ignore the first argument, but to grab the <code>dy</code> from the <code>gestureState</code> and update the <code>y</code> value on our <code>Animated.ValueXY</code> we created.</p>

<h1>Interpolate and Animate</h1>

<p>```</p>

<pre><code>this._scale = this.state.position.y.interpolate({
  inputRange: [0, deviceHeight ],
  outputRange: [1, .71],
  extrapolate: 'clamp'
});

this._translateY = this.state.position.y.interpolate({
  inputRange: [0, deviceHeight],
  outputRange: [0, deviceHeight],
  extrapolate: 'clamp'
});

this.state.position.y.addListener((value) =&gt; {
  this._y = value.value;
  var scaleValue = this._scale.getAnimatedValue();
  var currentVideoWidth = scaleValue * videoWidth;
  var buffer = ((videoWidth - currentVideoWidth)/2);
  this.state.position.x.setValue(buffer);
}.bind(this));

this._opacity = this.state.position.y.interpolate({
  inputRange: [0, deviceHeight ],
  outputRange: [1, .1]
});
</code></pre>

<p>```</p>

<p>Now we need to setup a few more things in the <code>componentWillMount</code>. The <code>this._scale</code> will be set on a scale transform. This is directly tied to the <code>y</code> position of us dragging. So we setup an interpolate, which goes from <code>0</code> to the <code>deviceHeight</code> and map that to an output range of <code>1</code> to <code>.71</code>. The <code>.71</code> was a trial and error number, I&rsquo;m sure there is math to calculate this but I guessed till I got it right.</p>

<p>The <code>clamp</code> is to say that this value cannot go above or below these values.</p>

<p>You may be wondering why we setup <code>translateY</code> when the <code>inputRange</code> and <code>outputRange</code> are exactly the same. The <code>clamp</code> is the key part. This means that if a user tries to slide the video up it will not grow in scale, or slide the video upwards. It can only go down.</p>

<p>We setup the listener so we can keep track of our <code>y</code> value, we&rsquo;ll get into that later. We&rsquo;ll use <code>getAnimatedValue</code> to get the current scale. <strong>THIS WILL NOT WORK IN .11-rc</strong> and above. You cannot currently listen on interpolated values, and we need the interpolated value for our math.</p>

<p>We get the original <code>videoWidth</code> and multiply it times the scale value so we can get the current <code>videoWidth</code>. We subtract the <code>currentVideoWidth</code> from the <code>videoWidth</code> and divide it by <code>2</code> to get the current buffer. That buffer is the space between the right side of the video and the current scaled video. If we don&rsquo;t do this then the X/Y scaling on the video will just squish it to the middle of the screen. What we want to do is have it slide down the right side of the screen.</p>

<p>Finally we setup the opacity, this is for the <code>scrollView</code> to slowly fade as we swipe down.</p>

<h1>Setup the styling</h1>

<p>```
  getScalePosition: function() {</p>

<pre><code>return {
  transform: [
    {scale: this._scale},
    {translateX: this.state.position.x},
    {translateY: this._translateY}
  ]
}
</code></pre>

<p>  },
  getScrollOffset: function() {</p>

<pre><code>return {
  transform: [
    {translateY: this._translateY},
  ],
  opacity: this._opacity
}
</code></pre>

<p>  },</p>

<pre><code>&lt;AnimatedVideo 
  {...this._panResponder.panHandlers}
  source=
  style={[styles.videoSizing, this.getScalePosition()]}
  rate={this.state.rate}
  paused={this.state.paused}
  volume={this.state.volume}
  muted={this.state.muted}
  resizeMode={this.state.resizeMode}
  repeat={true}
/&gt;
&lt;AnimatedScrollView style={[styles.container, this.getScrollOffset()]}&gt;
&lt;/AnimatedScrollView&gt;
</code></pre>

<p>```</p>

<p>Here we set default styling, and then make our calls to get the style objects with our animated values. For our video scale position we pass our <code>this._scale</code> to <code>scale</code> to transform both <code>scaleX</code>, and <code>scaleY</code>. We pass in our position x, and our <code>this._translateY</code> that is clamped.</p>

<p>For our <code>ScrollView</code> , we setup <code>translateY</code>, and pass in the opacity we created.</p>

<h1>Set Offset and Animate the Release</h1>

<p>```</p>

<pre><code>this._panResponder = PanResponder.create({
  onStartShouldSetPanResponder: (evt, gestureState) =&gt; true,
  onStartShouldSetPanResponderCapture: (evt, gestureState) =&gt; true,
  onMoveShouldSetPanResponder: (evt, gestureState) =&gt; true,
  onMoveShouldSetPanResponderCapture: (evt, gestureState) =&gt; true,
  onPanResponderGrant: function() {
    this.state.position.y.setOffset(this._y)
  }.bind(this),
  onPanResponderMove: Animated.event([
      null, 
      {
          dy: this.state.position.y
      }
  ]),
  onPanResponderRelease: (e, gestureState) =&gt; {
    this.state.position.flattenOffset();

    if (gestureState.dy &gt;= 40) {
      Animated.timing(this.state.position.y, {
        duration: 200,
        toValue: deviceHeight
      }).start();
    } else {
      Animated.timing(this.state.position.y, {
        duration: 200,
        toValue: 0
      }).start();
    }

  }.bind(this)
});
</code></pre>

<p>```</p>

<p>When I said we&rsquo;d get to why we kept track of the <code>y</code> this is why. This is so we can set the offset of the initial press and prevent the video from jumping. It will work for sliding down, but with <code>dy</code> it is always the delta. So on the slide up from the bottom it would immediately jump to the top, and we don&rsquo;t want that.</p>

<p>```</p>

<pre><code>  onPanResponderGrant: function() {
    this.state.position.y.setOffset(this._y)
  }.bind(this),
</code></pre>

<p>```
This code sets the initial offset when you first touch to whatever the current y value is.</p>

<p>```</p>

<pre><code>  onPanResponderRelease: (e, gestureState) =&gt; {
    this.state.position.flattenOffset();

    if (gestureState.dy &gt;= 100) {
      Animated.timing(this.state.position.y, {
        duration: 200,
        toValue: deviceHeight
      }).start();
    } else {
      Animated.timing(this.state.position.y, {
        duration: 200,
        toValue: 0
      }).start();
    }

  }.bind(this)
</code></pre>

<p>```</p>

<p>On release we flatten the offset. Which just squashes the current value and offset together.
If the user has moved greater than <code>100</code> pixels then we&rsquo;ll animate the video to the bottom of the screen. If not we&rsquo;ll animate it back to the top.</p>

<h1>Final</h1>

<p>As always check it out on RNPlay at <a href="https://rnplay.org/apps/Cp_SSA">https://rnplay.org/apps/Cp_SSA</a>.
The video source comes from <a href="http://camendesign.com/code/video_for_everybody/test.html">http://camendesign.com/code/video_for_everybody/test.html</a>. It&rsquo;s a wonderfully open sourced mp4 video that we can link to test out.</p>

<h1>Full Code</h1>

<p>```
var React = require(&lsquo;react-native&rsquo;);
var Dimensions = require(&lsquo;Dimensions&rsquo;);
var {width: deviceWidth, height: deviceHeight} = Dimensions.get(&lsquo;window&rsquo;);
var Video = require(&lsquo;react-native-video&rsquo;);</p>

<p>var videoWidth = deviceWidth,</p>

<pre><code>videoHeight = Math.round((deviceWidth/16)*9);
</code></pre>

<p>var {
  AppRegistry,
  StyleSheet,
  View,
  Text,
  Animated,
  PanResponder,
  ScrollView
} = React;</p>

<p>var AnimatedVideo = Animated.createAnimatedComponent(Video);
var AnimatedScrollView = Animated.createAnimatedComponent(ScrollView);</p>

<p>var YoutubeVideoSlide = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
  rate: 1,
  volume: 1,
  muted: true,
  resizeMode: 'stretch',
  duration: 0.0,
  currentTime: 0.0,
  scale: new Animated.Value(1),
  position: new Animated.ValueXY(),

};
</code></pre>

<p>  },
  _y: 0,
  componentWillMount: function() {</p>

<pre><code>this._panResponder = PanResponder.create({
  onStartShouldSetPanResponder: (evt, gestureState) =&gt; true,
  onStartShouldSetPanResponderCapture: (evt, gestureState) =&gt; true,
  onMoveShouldSetPanResponder: (evt, gestureState) =&gt; true,
  onMoveShouldSetPanResponderCapture: (evt, gestureState) =&gt; true,
  onPanResponderGrant: function() {
    this.state.position.y.setOffset(this._y)
  }.bind(this),
  onPanResponderMove: Animated.event([
      null, 
      {
          dy: this.state.position.y
      }
  ]),
  onPanResponderRelease: (e, gestureState) =&gt; {
    this.state.position.flattenOffset();

    if (gestureState.dy &gt;= 100) {
      Animated.timing(this.state.position.y, {
        duration: 200,
        toValue: deviceHeight
      }).start();
    } else {
      Animated.timing(this.state.position.y, {
        duration: 200,
        toValue: 0
      }).start();
    }

  }.bind(this)
});

this._scale = this.state.position.y.interpolate({
  inputRange: [0, deviceHeight ],
  outputRange: [1, .71],
  extrapolate: 'clamp'
});

this._translateY = this.state.position.y.interpolate({
  inputRange: [0, deviceHeight],
  outputRange: [0, deviceHeight],
  extrapolate: 'clamp'
});

this.state.position.y.addListener((value) =&gt; {
  this._y = value.value;
  var scaleValue = this._scale.getAnimatedValue();
  var currentVideoWidth = scaleValue * videoWidth;
  var buffer = ((videoWidth - currentVideoWidth)/2);
  this.state.position.x.setValue(buffer);
}.bind(this));

this._opacity = this.state.position.y.interpolate({
  inputRange: [0, deviceHeight ],
  outputRange: [1, .1]
});
</code></pre>

<p>  },
  getScalePosition: function() {</p>

<pre><code>return {
  transform: [
    {scale: this._scale},
    {translateX: this.state.position.x},
    {translateY: this._translateY}
  ]
}
</code></pre>

<p>  },
  getScrollOffset: function() {</p>

<pre><code>return {
  transform: [
    {translateY: this._translateY},
  ],
  opacity: this._opacity
}
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
          &lt;AnimatedVideo 
              {...this._panResponder.panHandlers}
              source=
              style={[styles.videoSizing, this.getScalePosition()]}
              rate={this.state.rate}
              paused={this.state.paused}
              volume={this.state.volume}
              muted={this.state.muted}
              resizeMode={this.state.resizeMode}
              repeat={true} 
          /&gt;
        &lt;AnimatedScrollView style={[styles.container, this.getScrollOffset()]}&gt;
          &lt;View style={styles.comment}&gt;
            &lt;Text&gt;Video Comment&lt;/Text&gt;
          &lt;/View&gt;
          &lt;View style={styles.comment}&gt;
            &lt;Text&gt;Video Comment&lt;/Text&gt;
          &lt;/View&gt;
          &lt;View style={styles.comment}&gt;
            &lt;Text&gt;Video Comment&lt;/Text&gt;
          &lt;/View&gt;
          &lt;View style={styles.comment}&gt;
            &lt;Text&gt;Video Comment&lt;/Text&gt;
          &lt;/View&gt;
          &lt;View style={styles.comment}&gt;
            &lt;Text&gt;Video Comment&lt;/Text&gt;
          &lt;/View&gt;
          &lt;View style={styles.comment}&gt;
            &lt;Text&gt;Video Comment&lt;/Text&gt;
          &lt;/View&gt;
          &lt;View style={styles.comment}&gt;
            &lt;Text&gt;Video Comment&lt;/Text&gt;
          &lt;/View&gt;
        &lt;/AnimatedScrollView&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
});</p>

<p>var styles = StyleSheet.create({
  container: {</p>

<pre><code>flex: 1
</code></pre>

<p>  },
  videoSizing: {</p>

<pre><code>width: videoWidth,
height: videoHeight
</code></pre>

<p>  },
  comment: {</p>

<pre><code>height: 100
</code></pre>

<p>  }
});</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React-Native Animated with React-Art - Firework Tap To Shoot]]></title>
    <link href="http://browniefed.com/blog/2015/08/29/react-native-animated-with-react-art-firework-show/"/>
    <updated>2015-08-29T22:12:00-07:00</updated>
    <id>http://browniefed.com/blog/2015/08/29/react-native-animated-with-react-art-firework-show</id>
    <content type="html"><![CDATA[<h1>Introduction</h1>

<p>This actually could be built with out react-art, but we&rsquo;ll use react-art just for good measure.
What are we building? A firework show. Nothing fancy. Just tap on the screen and a firework will be shot to that point and explode.</p>

<h1>What?</h1>

<p>This is what we&rsquo;re building</p>

<p><img class="<a" src="href="http://i.imgur.com/Dj60a6e.gif">http://i.imgur.com/Dj60a6e.gif</a>" title="Firework Shooter" ></p>

<!-- more -->


<h1>Setup</h1>

<p>Just like normal, lets set the scene. A blank app with everything imported, etc.</p>

<p>```
var React = require(&lsquo;react-native&rsquo;);
var Dimensions = require(&lsquo;Dimensions&rsquo;);
var ReactNativeART = require(&lsquo;ReactNativeART&rsquo;);</p>

<p>var {
  width,
  height
} = Dimensions.get(&lsquo;window&rsquo;);</p>

<p>var {
  AppRegistry,
  StyleSheet,
  Animated,
  View,
  TouchableWithoutFeedback
} = React;</p>

<p>var {</p>

<pre><code>Surface,
Shape,
Path,
Group,
Transform
</code></pre>

<p>} = ReactNativeART;</p>

<p>var AnimatedShape = Animated.createAnimatedComponent(Shape);
var AnimatedGroup = Animated.createAnimatedComponent(Group);
```</p>

<p>We bring in the <code>Animated</code> API, <code>ReactNativeART</code>, some components from <code>ART</code>.
The thing that we have done before is creating <code>AnimatedShape</code>, and <code>AnimatedGroup</code>. What these do is allow us to set props like <code>fill</code>, <code>opacity</code>, <code>x</code>, <code>y</code>, that are Animated values. This will cause updates in our native world correctly and efficiently.</p>

<p>Now our styles</p>

<p>```
var styles = StyleSheet.create({
  container: {</p>

<pre><code>flex: 1,
flexDirection: 'column'
</code></pre>

<p>  }
});
<code>``
Yep that is it. Most of our stuff will take place in the</code>react-art` world.</p>

<p>Now our basic class</p>

<p>```
var FireworkShooter = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
  fireworks: []
};
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
    &lt;TouchableWithoutFeedback&gt;
      &lt;View&gt;
        &lt;Surface width={width} height={height}&gt;
        &lt;/Surface&gt;
      &lt;/View&gt;
    &lt;/TouchableWithoutFeedback&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
});
```</p>

<p>So we have a simple setup. A full container view, with a <code>TouchableWithoutFeedback</code> so we can get the press coordinates. Then a wrapping <code>View</code> since <code>Touchable</code> stuff needs a native view below it. Then finally our <code>react-art</code> <code>Surface</code>. This takes a <code>width</code> and <code>height</code> prop. In our case we want the full screen, so we get the dimensions of the phone that we extracted up above and set it.</p>

<h1>Shoot a mortar</h1>

<p>Lets think about this.
We want a mortar (a small glowing ball) to shoot from the bottom center of the screen to where we&rsquo;ve tapped.</p>

<p>That means with <code>react-art</code> we&rsquo;ll have to create a closed <code>Path</code> that is a circle. It just so happens that <code>react-art</code> ships with a <code>Circle</code> shape for us to use.</p>

<p>Okay so our list of needs</p>

<ul>
<li>A press handler to get where we tapped</li>
<li>A <code>Circle</code> that can take Animated API props</li>
<li>A way to animate that <code>Circle</code> aka mortar to the tap</li>
<li>Render a mortar on the <code>Surface</code></li>
</ul>


<p><code>
&lt;TouchableWithoutFeedback onPress={this._handleAddFirework}&gt;
</code>
We&rsquo;ll use the <code>TouchableWithoutFeedback</code> to call out to a function to queue up adding a firework.
Check that off the list.</p>

<p>```
//React-Art ships with this component however not react-native-art implementation we&rsquo;ll just grab it and
//modify this to use the AnimatedShape we create up above. Thanks Facebook :)</p>

<p>/<em>*
 * Copyright 2013-2014 Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Circle.art
 * @typechecks
 *
 * Example usage:
 * <Circle
 *   radius={10}
 *   stroke="green"
 *   strokeWidth={3}
 *   fill="blue"
 * />
 *
 </em>/
var AnimatedCircle = React.createClass({displayName: &ldquo;Circle&rdquo;,
  render: function() {</p>

<pre><code>var radius = this.props.radius;

var path = Path().moveTo(0, -radius)
    .arc(0, radius * 2, radius)
    .arc(0, radius * -2, radius)
    .close();
return React.createElement(AnimatedShape, React.__spread({},  this.props, {d: path}));
</code></pre>

<p>  }
});
```</p>

<p>Hey look we just grabbed it and changed <code>Shape</code> to <code>AnimatedShape</code>. Yaye for React and reusable code.</p>

<p>```
var MORTAR_RADIUS = 5;
///&hellip;
_handleAddFirework: function(e) {</p>

<pre><code>var _shootingPosition = new Animated.ValueXY({x: width/2, y: height - MORTAR_RADIUS});

this.state.fireworks.push({
  shootingPosition: _shootingPosition,
});

Animated.timing(_shootingPosition, {
    duration: 300,
    toValue: {
      y: e.nativeEvent.locationY,
      x: e.nativeEvent.locationX
    }
}).start()

this.setState(this.state);
</code></pre>

<p>}
```
Alright. Pause and lets analyze this code.</p>

<p>First line <code>_shootingPosition</code>, we create a new <code>Animated.ValueXY</code> and set our defaults. These defaults are the starting position of the animation. Usually these would default to <code>x: 0, y:0</code> but we have other plans.</p>

<p>We set our <code>x</code> to <code>width/2</code> which is the middle of the phone. Then our <code>y</code> is going to the <code>height</code> of the device minus a <code>MORTAR_RADIUS</code>. We put a constant at the top of the code to say our mortar radius is going to be 5.</p>

<p>Next we add it to an array of fireworks we&rsquo;ll shoot later.</p>

<p>Then we create the animation.
We want the mortar to take <code>300</code> milliseconds to reach the spot the user pressed. We set the <code>toValue</code> to where our users pressed.
Then we start the animation. Yeah we haven&rsquo;t even rendered anything yet but it&rsquo;ll all be okay trust me.</p>

<p>Finally we set our state and thus it&rsquo;ll cause a re-render and we can render our firework.</p>

<p>```
<Surface width={width} height={height}>
{</p>

<pre><code>this.state.fireworks.map((firework) =&gt; {
    return &lt;AnimatedCircle 
                radius={MORTAR_RADIUS} 
                x={firework.shootingPosition.x} 
                y={firework.shootingPosition.y}
                fill="#000"
            /&gt;
})
</code></pre>

<p>}
</Surface>
<code>``
So we map over each firework, return the</code>AnimatedCircle<code>and set the appropriate properties, which 2 of those</code>x<code>, and</code>y` are animated properties. In our case we&rsquo;re going to fill the cirlcle with black to start.</p>

<p>So what does that all look like? Something like this</p>

<p><img class="<a" src="href="http://i.imgur.com/arIjyoz.gif">http://i.imgur.com/arIjyoz.gif</a>" title="Black Shooting Circles" ></p>

<h1>Shoot multiple mortars that disappear</h1>

<p>Well mortars don&rsquo;t stick like that. So lets make them disappear.
The <code>start()</code> function takes a callback that is called when the animation completes.</p>

<p>To identify the firework in the array we&rsquo;ll just use the <code>shootingPosition</code> animation to identify it and filter it out.</p>

<p>Something like this.</p>

<p>```
  removeSelf: function(_shootingPosition) {</p>

<pre><code>this.state.fireworks = this.state.fireworks.filter((firework) =&gt; firework.shootingPosition !== _shootingPosition);
this.setState(this.state);
</code></pre>

<p>  },</p>

<p>  ///</p>

<pre><code>Animated.timing(_shootingPosition, {
    duration: 300,
    toValue: {
      y: e.nativeEvent.locationY,
      x: e.nativeEvent.locationX
    }
]).start(this.removeSelf.bind(this, _shootingPosition));
</code></pre>

<p>```</p>

<p>Not the most elegant of solutions but hey it works. It runs through each firework, removes our _shootingPosition, and then refreshes the UI.</p>

<h1>Animate the color</h1>

<p>Lets make the mortar more than just a black dot. Lets pretend it&rsquo;s a fire ball, and we want it to alternate between yellow and orange.</p>

<p>We&rsquo;ll use these 2 colors and pop them at the top</p>

<p><code>
var SHOOTING_COLORS = [
  'rgb(234,238,112)', //Yellow
  'rgb(245,137,12)' //Orange
];
</code></p>

<p>The <code>interpolate</code> function we&rsquo;re going to call only works with <code>rgb</code> hence the use of <code>rgb</code> instead of hex.</p>

<p>Next we&rsquo;ll need to create another Animated value.</p>

<p>Our code will look like so</p>

<p>```</p>

<pre><code>var _shootingPosition = new Animated.ValueXY({x: width/2, y: height - MORTAR_RADIUS});
var _shootingColor = new Animated.Value(0);

this.state.fireworks.push({
  shootingPosition: _shootingPosition,
  shootingColor: _shootingColor,
});

//

_shootingPosition.addListener(this.adjustShootingFill.bind(null, _shootingColor));

adjustShootingFill: function(_shootingColor, value) {
    Animated.timing(_shootingColor, {
      duration: 16,
      toValue: _shootingColor.getAnimatedValue() == 0 ? 1 : 0
    }).start()
},
</code></pre>

<p><code>``
We start off by adding a new</code>Animated.Value`, and set it to 0. We add it to our firework object.</p>

<p>Then we add a listener to it. What <code>addListener</code> does is provides a callback that will be called each time the mortar position is updated.
The bind is just so it&rsquo;ll pass in our <code>_shootingColor</code> Animated value as the first argument.</p>

<p>We&rsquo;ll use the <code>Animated.timing</code> function again to transition it between colors over 16ms. We call <code>getAnimatedValue()</code> and do the inverse of it.</p>

<p>So every <code>16ms</code> the mortar will transition from yellow => orange => yellow => orange, etc.</p>

<p>Now what does that look like in our render?</p>

<p>```
<Surface width={width} height={height}>
{</p>

<pre><code>this.state.fireworks.map((firework) =&gt; {

    var _shootingFill = firework.shootingColor.interpolate({
      inputRange: [0,1],
      outputRange: SHOOTING_COLORS
    });


    return &lt;AnimatedCircle 
                radius={MORTAR_RADIUS} 
                x={firework.shootingPosition.x} 
                y={firework.shootingPosition.y}
                fill={_shootingFill}
            /&gt;
})
</code></pre>

<p>}
</Surface>
<code>``
We need to create an interpolator. This interpolate will encapsulate the logic that picks the color when we change the value of</code>shootingColor<code>up above in our</code>adjustShootingFill` function.</p>

<p>It maps to</p>

<p><code>
0 =&gt; yellow
1 =&gt; orange
</code>
Then we pass that into our fill property and we&rsquo;re done.</p>

<p><img class="<a" src="href="http://i.imgur.com/r69Ba6r.gif">http://i.imgur.com/r69Ba6r.gif</a>" title="Orange Yellow Moratrs" ></p>

<h1>Make those mortars explode</h1>

<p>Now for the fun part. Lets make our mortars explode.</p>

<p>Our mortar concept will be pretty simplistic, we&rsquo;ll create 20 circles that explode outwards and expand.
We could create all sorts of tails that fly around and do cool things but that is a tutorial for another time.</p>

<p>First lets setup some variables</p>

<p>```
var PARTICLE_RADIUS = 30; // How big should the explosions be
var PARTICLE_COUNT = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]; // How many particles per explosion, this is the lazy persons range call</p>

<p>var PARTICLE_COLORS = [</p>

<pre><code>'rgba(54, 17, 52, 100)',
'rgba(176, 34, 140, 100)',
'rgba(234, 55, 136, 100)',
'rgba(229, 107, 112, 100)',
'rgba(243, 145, 160, 100)'
</code></pre>

<p>]
```</p>

<p>We the <code>PARTICLE_RADIUS</code> which will determine how large each explosion is. We setup <code>PARTICLE_COUNT</code> which is the amount of particles we&rsquo;ll use.
Finally we want our firework show to be 5 different colors. So each explosion will change between each of these colors.</p>

<p>For the sake of simplicity we&rsquo;ll make each particle the same exact color meaning we only need 1 <code>Animated.Value</code> for it.</p>

<p>```</p>

<pre><code>var _particleColor = new Animated.Value(0);
var _particleRadius = new Animated.Value(0);
var _coreOpacity = new Animated.Value(1);
</code></pre>

<p><code>``
We also need an</code>Animated.Value<code>for our radius, we put it at 0 so it starts hidden. The other</code>Animated.Value` is our core opacity animation.
That is the value for hiding our core mortar once it explodes.</p>

<p>```</p>

<pre><code>var _particlePositions = PARTICLE_COUNT.map(() =&gt; new Animated.ValueXY({x: 0, y: 0}));
</code></pre>

<p><code>``
Each particle will have to go to a different position so in this case we'll need 20</code>Animated.ValueXY`.</p>

<p>```
this.state.fireworks.push({</p>

<pre><code>  shootingPosition: _shootingPosition,
  shootingColor: _shootingColor,
  particleColor: _particleColor,
  particleRadius: _particleRadius,
  coreOpacity: _coreOpacity,
  particlePositions: _particlePositions
});
</code></pre>

<p>```</p>

<p>Add them to our firework so we can access them later in our render.</p>

<p>```</p>

<pre><code>var _animatedParticles = [
    Animated.timing(_particleRadius, {
      duration: 700,
      toValue: 1
    }),
    Animated.timing(_coreOpacity, {
      duration: 200,
      toValue: 0
    })
]

_movingParticles = _particlePositions.map((particle, i) =&gt; {
  var _xy = getXYParticle(PARTICLE_COUNT.length, i, PARTICLE_RADIUS);
  return Animated.timing(particle, {
    duration: 250,
    toValue: _xy
  })
})

//At the bottom of the file
function getXYParticle(total, i, radius) {
  var angle = 360/total*i;

  var x = Math.round((radius*2) * Math.cos(angle - (Math.PI/2)));
  var y = Math.round((radius*2) * Math.sin(angle - (Math.PI/2)));

  return {
    x: x,
    y: y
  }
}

_animatedParticles = _animatedParticles.concat(_movingParticles);
</code></pre>

<p>```</p>

<p>This whole animation mapping is setting us up for what we are going to do next. Which is queue up our animations.</p>

<p>We create an array of animations that need to happen. The first is expanding each <code>_particleRadius</code>. We have determine that it will take 700 milliseconds to fully expand the explosion. The <code>_particleRadius</code> will actually be the particle scale. We&rsquo;ll just scale up the circle so it looks like it&rsquo;s exploding outwards, but that will be shown off in our render function.</p>

<p>We set our <code>_coreOpacity</code> aka our mortar ball to fade out and disappear over 200 milliseconds.</p>

<p>We need to create the animations for each particle. It needs to shoot out from our current mortar location to different points on the circle.
After googling around I found a function below, and deleted a bunch of stuff to basically get down to a rough position algorithim to return <code>x,y</code> positions.</p>

<p>We once again use <code>Animated.timing</code> to say that the particle should take 250 milliseconds to get into it&rsquo;s position.</p>

<p>```</p>

<pre><code>Animated.sequence([
  Animated.timing(_shootingPosition, {
    duration: 300,
    toValue: {
      y: e.nativeEvent.locationY,
      x: e.nativeEvent.locationX
    }
  }),
  Animated.parallel(_animatedParticles)
]).start(this.removeSelf.bind(this, _shootingPosition));
</code></pre>

<p>```</p>

<p>Now to queue up our animations. We want our mortar shooting to happen first, then the explosion.
We do that using <code>Animated.sequence</code>.</p>

<p>We first have our mortar go up to the location of the users touch.
The next piece is wrapping all of our explosion animations in an <code>Animated.parallel</code>. This is the opposite of sequence, which it says execute all of these animations at the same time.</p>

<p>So our mortar fading out and disappearing, our particles expanding, changing color, and exploding outward will all happen at the same time.</p>

<p>```</p>

<pre><code>_shootingPosition.addListener(this.adjustShootingFill.bind(null, _shootingColor));
_particleRadius.addListener(this.adjustParticleFill.bind(null, _particleColor));

///
  adjustParticleFill: function(_particleColor, value) {
    var _currentFill = _particleColor.getAnimatedValue(),
        _particleFill = _currentFill === 5 ? 0 : _currentFill + 1;

    Animated.timing(_particleColor, {
      duration: 16,
      toValue: _particleFill
    }).start()
  },
</code></pre>

<p>```</p>

<p>Finally we need to change our color of our particle. So like before we&rsquo;ll attach to the expanding of our particle and make it call a function to change the fill color.
In our new case we have five colors to choose from so the logic is a little different but mostly the same.</p>

<p>Now for our rendering of this all. We&rsquo;ll move it out to a different function to deal with.</p>

<p>```
  <Surface width={width} height={height}></p>

<pre><code>{this.getFireworks()}
</code></pre>

<p>  </Surface>
```</p>

<p>```
getFireworks: function() {</p>

<pre><code>return this.state.fireworks.map((firework, i) =&gt; {

  var _shootingFill = firework.shootingColor.interpolate({
    inputRange: [0,1],
    outputRange: SHOOTING_COLORS
  });

  var _particleFill = firework.particleColor.interpolate({
    inputRange: [0,1,2,3,4],
    outputRange: PARTICLE_COLORS
  });

  return (
      &lt;AnimatedGroup 
        x={firework.shootingPosition.x}
        y={firework.shootingPosition.y}
      &gt;
            &lt;AnimatedCircle
              opacity={firework.coreOpacity}
              radius={MORTAR_RADIUS}
              fill={_shootingFill}
            /&gt;
            &lt;Group&gt;
            {
              PARTICLE_COUNT.map((v, j) =&gt; {
                return &lt;AnimatedCircle
                  x={firework.particlePositions[j].x}
                  y={firework.particlePositions[j].y}
                  scaleX={firework.particleRadius}
                  scaleY={firework.particleRadius}
                  radius={PARTICLE_RADIUS}
                  fill={_particleFill}
                /&gt;
              })
            }
            &lt;/Group&gt;
      &lt;/AnimatedGroup&gt;
  );
})
</code></pre>

<p>  },
<code>``
There is a lot going on here. We have our same</code><em>shootingFill<code>like we did before, that causes the yellow =&gt; orange interpolation.
We add another interpolation for the particleFill. Same concept as the</code></em>shootingFill` just with 5 colors now.</p>

<p>What is much different here is the <code>AnimatedGroup</code>. We have moved our <code>x,y</code> from the <code>AnimatedCircle</code> to the <code>AnimatedGroup</code>.</p>

<p>This will bundle our mortar, and our particles all in the same coordinate area. That way we can have our particles start at <code>0,0</code> and move outwards and the <code>AnimatedGroup</code> will make sure all the coordinates are handled correctly.</p>

<p><code>
&lt;AnimatedCircle
  opacity={firework.coreOpacity}
  radius={MORTAR_RADIUS}
  fill={_shootingFill}
/&gt;
</code>
You can see here we put out <code>coreOpacity</code> animation in there. So it&rsquo;ll fade from <code>1</code> opacity down to <code>0</code> over that 200 milliseconds we setup.</p>

<p>```
  <Group></p>

<pre><code>{
  PARTICLE_COUNT.map((v, j) =&gt; {
    return &lt;AnimatedCircle
      x={firework.particlePositions[j].x}
      y={firework.particlePositions[j].y}
      scaleX={firework.particleRadius}
      scaleY={firework.particleRadius}
      radius={PARTICLE_RADIUS}
      fill={_particleFill}
    /&gt;
  })
}
</code></pre>

<p>  </Group>
<code>``
We group the Particles with a</code>Group` component but that&rsquo;s just arbitrary.</p>

<p>We map over our 20 particles, and set the <code>x</code> and <code>y</code> to the points we had determined with our <code>getXYParticle</code> function.</p>

<p>You&rsquo;ll notice we are passing in <code>particleRadius</code> to the <code>scaleX</code> and <code>scaleY</code> properties.
This is because while writing this I realized that the <code>AnimatedCircle</code> takes the radius property and creates a path out of it. That is not animateable in this particular way, so the solution I came up was to scale each particle to 0. Basically making it completely hidden.</p>

<p>That then allows us to expand it out to it&rsquo;s full scale and make it look like an explosion. It actually works better.</p>

<p>Finally we add in our <code>PARTICLE_RADIUS</code> we defined at the top, aka size of each explosion, and put in our <code>_particleFill</code> which is the color interpolation between those 5 colors.</p>

<h1>Play with it</h1>

<p>That is all! We have a firework shooter!</p>

<p>Check it out on RNPlay as per usual <a href="https://rnplay.org/apps/ysm12A">https://rnplay.org/apps/ysm12A</a>.</p>

<p>Tap to your hearts content and watch all the explosive animation goodness appear on screen.</p>

<p><img class="<a" src="href="http://i.imgur.com/Dj60a6e.gif">http://i.imgur.com/Dj60a6e.gif</a>" title="Firework Shooter" ></p>

<h1>Final Code</h1>

<p>```
var React = require(&lsquo;react-native&rsquo;);
var Dimensions = require(&lsquo;Dimensions&rsquo;);
var ReactNativeART = require(&lsquo;ReactNativeART&rsquo;);</p>

<p>var {
  width,
  height
} = Dimensions.get(&lsquo;window&rsquo;);</p>

<p>var MORTAR_RADIUS = 5;
var PARTICLE_RADIUS = 30;
var PARTICLE_COUNT = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20];</p>

<p>var {
  AppRegistry,
  StyleSheet,
  Animated,
  View,
  TouchableWithoutFeedback
} = React;</p>

<p>var {</p>

<pre><code>Surface,
Shape,
Path,
Group,
Transform
</code></pre>

<p>} = ReactNativeART;</p>

<p>var SHOOTING_COLORS = [
  &lsquo;rgb(234,238,112)&rsquo;,
  &lsquo;rgb(245,137,12)&rsquo;
];</p>

<p>var PARTICLE_COLORS = [</p>

<pre><code>'rgba(54, 17, 52, 100)',
'rgba(176, 34, 140, 100)',
'rgba(234, 55, 136, 100)',
'rgba(229, 107, 112, 100)',
'rgba(243, 145, 160, 100)'
</code></pre>

<p>]</p>

<p>var AnimatedShape = Animated.createAnimatedComponent(Shape);
var AnimatedGroup = Animated.createAnimatedComponent(Group);</p>

<p>var FireworkShooter = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
  fireworks: []
};
</code></pre>

<p>  },
  adjustShootingFill: function(_shootingColor, value) {</p>

<pre><code>Animated.timing(_shootingColor, {
  duration: 16,
  toValue: _shootingColor.getAnimatedValue() == 0 ? 1 : 0
}).start()
</code></pre>

<p>  },
  adjustParticleFill: function(_particleColor, value) {</p>

<pre><code>var _currentFill = _particleColor.getAnimatedValue(),
    _particleFill = _currentFill === 5 ? 0 : _currentFill + 1;

Animated.timing(_particleColor, {
  duration: 16,
  toValue: _particleFill
}).start()
</code></pre>

<p>  },
  removeSelf: function(_shootingPosition) {</p>

<pre><code>this.state.fireworks = this.state.fireworks.filter((firework) =&gt; firework.shootingPosition !== _shootingPosition);
this.setState(this.state);
</code></pre>

<p>  },
  _handleAddFirework: function(e) {</p>

<pre><code>var _shootingPosition = new Animated.ValueXY({x: width/2, y: height - MORTAR_RADIUS});
var _shootingColor = new Animated.Value(0);

var _particleColor = new Animated.Value(0);
var _particleRadius = new Animated.Value(0);
var _coreOpacity = new Animated.Value(1);

var _particlePositions = PARTICLE_COUNT.map(() =&gt; new Animated.ValueXY({x: 0, y: 0}));

this.state.fireworks.push({
  shootingPosition: _shootingPosition,
  shootingColor: _shootingColor,
  particleColor: _particleColor,
  particleRadius: _particleRadius,
  coreOpacity: _coreOpacity,
  particlePositions: _particlePositions
});

var _animatedParticles = [
    Animated.timing(_particleRadius, {
      duration: 700,
      toValue: 1
    }),
    Animated.timing(_coreOpacity, {
      duration: 200,
      toValue: 0
    })
]

_movingParticles = _particlePositions.map((particle, i) =&gt; {
  var _xy = getXYParticle(PARTICLE_COUNT.length, i, PARTICLE_RADIUS);
  return Animated.timing(particle, {
    duration: 250,
    toValue: _xy
  })
})

_animatedParticles = _animatedParticles.concat(_movingParticles);

Animated.sequence([
  Animated.timing(_shootingPosition, {
    duration: 300,
    toValue: {
      y: e.nativeEvent.locationY,
      x: e.nativeEvent.locationX
    }
  }),
  Animated.parallel(_animatedParticles)
]).start(this.removeSelf.bind(this, _shootingPosition));

_shootingPosition.addListener(this.adjustShootingFill.bind(null, _shootingColor));
_particleRadius.addListener(this.adjustParticleFill.bind(null, _particleColor));

this.setState(this.state);
</code></pre>

<p>  },</p>

<p>  getFireworks: function() {</p>

<pre><code>return this.state.fireworks.map((firework, i) =&gt; {

  var _shootingFill = firework.shootingColor.interpolate({
    inputRange: [0,1],
    outputRange: SHOOTING_COLORS
  });

  var _particleFill = firework.particleColor.interpolate({
    inputRange: [0,1,2,3,4],
    outputRange: PARTICLE_COLORS
  });

  return (
      &lt;AnimatedGroup 
        x={firework.shootingPosition.x}
        y={firework.shootingPosition.y}
      &gt;
            &lt;AnimatedCircle
              key={i}
              opacity={firework.coreOpacity}
              radius={MORTAR_RADIUS}
              fill={_shootingFill}
            /&gt;
            &lt;Group&gt;
            {
              PARTICLE_COUNT.map((v, j) =&gt; {
                return &lt;AnimatedCircle
                  x={firework.particlePositions[j].x}
                  y={firework.particlePositions[j].y}
                  scaleX={firework.particleRadius}
                  scaleY={firework.particleRadius}
                  radius={PARTICLE_RADIUS}
                  fill={_particleFill}
                /&gt;
              })
            }
            &lt;/Group&gt;
      &lt;/AnimatedGroup&gt;
  );
})
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
    &lt;TouchableWithoutFeedback onPress={this._handleAddFirework}&gt;
      &lt;View&gt;
        &lt;Surface width={width} height={height}&gt;
          {this.getFireworks()}
        &lt;/Surface&gt;
      &lt;/View&gt;
    &lt;/TouchableWithoutFeedback&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
});</p>

<p>var styles = StyleSheet.create({
  container: {</p>

<pre><code>flex: 1,
flexDirection: 'column'
</code></pre>

<p>  }
});</p>

<p>function getXYParticle(total, i, radius) {
  var angle = 360/total*i;</p>

<p>  var x = Math.round((radius<em>2) * Math.cos(angle &ndash; (Math.PI/2)));
  var y = Math.round((radius</em>2) * Math.sin(angle &ndash; (Math.PI/2)));</p>

<p>  return {</p>

<pre><code>x: x,
y: y
</code></pre>

<p>  }
}</p>

<p>//Modified this to use the AnimatedShape we create up above. Thanks Facebook :)</p>

<p>/<em>*
 * Copyright 2013-2014 Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Circle.art
 * @typechecks
 *
 * Example usage:
 * <Circle
 *   radius={10}
 *   stroke="green"
 *   strokeWidth={3}
 *   fill="blue"
 * />
 *
 </em>/
var AnimatedCircle = React.createClass({displayName: &ldquo;Circle&rdquo;,
  render: function() {</p>

<pre><code>var radius = this.props.radius;

var path = Path().moveTo(0, -radius)
    .arc(0, radius * 2, radius)
    .arc(0, radius * -2, radius)
    .close();
return React.createElement(AnimatedShape, React.__spread({},  this.props, {d: path}));
</code></pre>

<p>  }
});</p>

<p>AppRegistry.registerComponent(&lsquo;FireworkShooter&rsquo;, () => FireworkShooter);
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React-native press and hold button actions]]></title>
    <link href="http://browniefed.com/blog/2015/08/22/react-native-press-and-hold-button-actions/"/>
    <updated>2015-08-22T11:55:00-07:00</updated>
    <id>http://browniefed.com/blog/2015/08/22/react-native-press-and-hold-button-actions</id>
    <content type="html"><![CDATA[<h1>Introduction</h1>

<p>Another common interaction is the press and hold to fire an action. Sometimes it&rsquo;s delete, sometimes it&rsquo;s save, but whatever it is you want to provide feedback to your user. React Native ships with a few Touchable components like <code>TouchableOpacity</code>, <code>TouchableHighlight</code> and also <code>TouchableBounce</code> that provide feedback to users but we&rsquo;ll build a button that fills up over a set period of time then triggers an action.</p>

<p><img class="<a" src="href="http://i.imgur.com/aVeaXMc.gif">http://i.imgur.com/aVeaXMc.gif</a>" title="Final Press And Hold" ></p>

<!-- more -->


<h1>Setup</h1>

<p>Lets do some code setup.</p>

<p>```
var React = require(&lsquo;react-native&rsquo;);</p>

<p>var {
  AppRegistry,
  StyleSheet,
  Animated,
  View,
  Text,
  TouchableWithoutFeedback
} = React;</p>

<p>var ACTION_TIMER = 400;
var COLORS = [&lsquo;rgb(255,255,255)&rsquo;, &lsquo;rgb(111,235,62)&rsquo;];
```</p>

<p>We&rsquo;ll pull in the normal components from React Native and additionally setup some variables to use later. <code>ACTION_TIMER</code> will be how long the animation will take before it fires the action, the <code>COLORS</code> will be the start and end colors. This animtion will transition from white to a brightish green. Remember that animated interpolations do not work with hex.</p>

<h1>Base Component With StyleSheet</h1>

<p>```
var AnimatedButtonPress = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
    textComplete: ''
};
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
   &lt;View style={styles.container}&gt;
        &lt;TouchableWithoutFeedback&gt;
            &lt;View style={styles.button} &gt;
                &lt;Animated.View style={styles.bgFill} /&gt;
                &lt;Text style={styles.text}&gt;Press And Hold Me&lt;/Text&gt;
            &lt;/View&gt;
        &lt;/TouchableWithoutFeedback&gt;
        &lt;View&gt;
            &lt;Text&gt;{this.state.textComplete}&lt;/Text&gt;
        &lt;/View&gt;
   &lt;/View&gt;
);
</code></pre>

<p>  }
});</p>

<p>var styles = StyleSheet.create({
  container: {</p>

<pre><code>flex: 1,
flexDirection: 'column',
alignItems: 'center',
justifyContent: 'center'
</code></pre>

<p>  },
  button: {</p>

<pre><code>padding: 10,
borderWidth: 3,
borderColor: '#111'
</code></pre>

<p>  },
  text: {</p>

<pre><code>backgroundColor: 'transparent',
color: '#111'
</code></pre>

<p>  },
  bgFill: {</p>

<pre><code>position: 'absolute',
top: 0,
left: 0
</code></pre>

<p>  }
});
```</p>

<p>To start out, for this to work we obviously don&rsquo;t need the <code>textComplete</code> but that&rsquo;s just going to be our visual feedback to let us know when the action completes.</p>

<p>We setup a <code>TouchableWithoutFeedback</code> so we can get access to a few press handlers without directly using the <code>PanResponder</code>. Next we create a wrapping button view, add some text, and most importantly we create an <code>Animated.View</code>.</p>

<p>We set it to be position absolute so it doesn&rsquo;t effect layout and sits behind the text, and set it to the <code>top: 0</code> and <code>left: 0</code> so it is position at the furthest top and left of the component. I&rsquo;ll explain later why we don&rsquo;t set <code>bottom:0</code> here as well.</p>

<h1>Create The Animated</h1>

<p>```
  getInitialState: function() {</p>

<pre><code>return {
    pressAction: new Animated.Value(0),
    textComplete: ''
};
</code></pre>

<p>  },
```</p>

<h1>Handle The Presses</h1>

<p>```
handlePressIn: function() {</p>

<pre><code>Animated.timing(this.state.pressAction, {
    duration: ACTION_TIMER,
    toValue: 1
}).start(this.animationActionComplete);
</code></pre>

<p>},
handlePressOut: function() {</p>

<pre><code>Animated.timing(this.state.pressAction, {
    duration: this.state.pressAction.getAnimatedValue() * ACTION_TIMER,
    toValue: 0
}).start();
</code></pre>

<p>},
animationActionComplete: function() {</p>

<pre><code>var message = '';
if (this.state.pressAction.getAnimatedValue() === 1) {
    message = 'You held it long enough to fire the action!';
}
this.setState({
    textComplete: message
});
</code></pre>

<p>},
render: function() {</p>

<pre><code>return (
   &lt;View style={styles.container}&gt;
        &lt;TouchableWithoutFeedback 
            onPressIn={this.handlePressIn} 
            onPressOut={this.handlePressOut}
        &gt;
            &lt;View style={styles.button} &gt;
                &lt;Animated.View style={styles.bgFill} /&gt;
                &lt;Text style={styles.text}&gt;Press And Hold Me&lt;/Text&gt;
            &lt;/View&gt;
        &lt;/TouchableWithoutFeedback&gt;
        &lt;View&gt;
            &lt;Text&gt;{this.state.textComplete}&lt;/Text&gt;
        &lt;/View&gt;
   &lt;/View&gt;
);
</code></pre>

<p>  }
```</p>

<p>Here we use the <code>onPressIn</code> and <code>onPressOut</code> callbacks. These will trigger timed animations. We&rsquo;ll use the <code>ACTION_TIMER</code> variable we setup at the top, and <code>onPressIn</code> we&rsquo;ll animate our <code>pressAction</code> animated value to <code>1</code> over <code>400ms</code>.</p>

<p><code>onPressOut</code> we&rsquo;ll animate it from <code>1</code> back down to <code>0</code>. However if a user lifts their finger before the <code>400ms</code> threshold is reached then it will animated down from that value. For example holding it down for <code>200ms</code> would mean our <code>pressAction</code> animated value was at <code>.5</code> so it would then animated down from <code>.5</code> to <code>0</code> over <code>400ms</code>.</p>

<p>Animating down over the full <code>400ms</code> is not ideal, so what we&rsquo;ll do is get the current animated value with <code>this.state.pressAction.getAnimatedValue()</code> and multiply it times the full <code>ACTION_TIMER</code> which means out <code>.5</code> animated value would yield us the correct <code>200ms</code> to transition back to <code>0</code>.</p>

<p>Finally we pass in a callback to our <code>start</code> of <code>handlePressIn</code> which if our <code>pressAction</code> animated value gets to <code>1</code> aka being compelte then we will tell the user their action happened.</p>

<h1>Measure the button</h1>

<p>Due to absolute layout we&rsquo;ll need to use specific widths and heights. That means we&rsquo;ll have to get the layout of the button so we know how much to fill.</p>

<p>```
  getInitialState: function() {</p>

<pre><code>return {
    pressAction: new Animated.Value(0),
    textComplete: '',
    buttonWidth: 0,
    buttonHeight: 0
};
</code></pre>

<p>  },
```</p>

<p>We&rsquo;ll setup the <code>buttonWidth</code> and <code>buttonHeight</code> on our initial state.</p>

<p>```
  getButtonWidthLayout: function(e) {</p>

<pre><code>this.setState({
    buttonWidth: e.nativeEvent.layout.width - 6,
    buttonHeight: e.nativeEvent.layout.height - 6
});
</code></pre>

<p>  },</p>

<p>  render: function() {</p>

<pre><code>return (
   &lt;View style={styles.container}&gt;
        &lt;TouchableWithoutFeedback 
            onPressIn={this.handlePressIn} 
            onPressOut={this.handlePressOut}
        &gt;
            &lt;View style={styles.button} onLayout={this.getButtonWidthLayout}&gt;
                &lt;Animated.View style={styles.bgFill} /&gt;
                &lt;Text style={styles.text}&gt;Press And Hold Me&lt;/Text&gt;
            &lt;/View&gt;
        &lt;/TouchableWithoutFeedback&gt;
        &lt;View&gt;
            &lt;Text&gt;{this.state.textComplete}&lt;/Text&gt;
        &lt;/View&gt;
   &lt;/View&gt;
);
</code></pre>

<p>  }
```</p>

<p>We&rsquo;ll use the <code>onLayout</code> callback for views and set the state of our buttons width and height. Why can&rsquo;t we use <code>bottom: 0</code>? Well because of the padding we set on the button it would only show the animated background where the text ends, so we&rsquo;ll explicitily set the height.</p>

<p>Why the <code>-6</code>? Well the same things happens for <code>top: 0</code> and <code>left: 0</code>. It will sit inside the border, so if we animated to the full width and set the full height then it would extend the progress bar past the borders which we don&rsquo;t want.</p>

<h1>Aniamte The Background and Width of our Fill</h1>

<p>```
  getProgressStyles: function() {</p>

<pre><code>var width = this.state.pressAction.interpolate({
    inputRange: [0, 1],
    outputRange: [0, this.state.buttonWidth]
});
var bgColor = this.state.pressAction.interpolate({
    inputRange: [0, 1],
    outputRange: COLORS
})
return {
    width: width,
    height: this.state.buttonHeight,
    backgroundColor: bgColor
}
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
   &lt;View style={styles.container}&gt;
        &lt;TouchableWithoutFeedback 
            onPressIn={this.handlePressIn} 
            onPressOut={this.handlePressOut}
        &gt;
            &lt;View style={styles.button} onLayout={this.getButtonWidthLayout}&gt;
                &lt;Animated.View style={[styles.bgFill, this.getProgressStyles()]} /&gt;
                &lt;Text style={styles.text}&gt;Press And Hold Me&lt;/Text&gt;
            &lt;/View&gt;
        &lt;/TouchableWithoutFeedback&gt;
        &lt;View&gt;
            &lt;Text&gt;{this.state.textComplete}&lt;/Text&gt;
        &lt;/View&gt;
   &lt;/View&gt;
);
</code></pre>

<p>  }
<code>``
We use the array syntax for style to combine our pre-set styles and our generated styles. We call</code>getProgressStyles<code>to return a new object with our dynamic styling. In our</code>getProgressStyles<code>we'll use the</code>interpolate<code>function on our</code>pressAction` animated value to setup animated values.</p>

<p>So for the width we&rsquo;ll take an input of <code>[0,1]</code> and it will interpolate from <code>0</code> to the width of our button that we set in the <code>getButtonWidthLayout</code>.</p>

<p>Same thing goes for the <code>bgColor</code> interpolation. It takes the same <code>[0,1]</code> inputRange and interpolates to the <code>rgb</code> colors we setup in the top.</p>

<p>Finally we return our new style object with our animated values, and also the heigth of the button (minus the 6 border pixels).</p>

<h1>Final</h1>

<p>And just like that you have the ability to press and hold a button and execute an action when it&rsquo;s done, all while providing feedback to the user.</p>

<p>As always checkout the live code <a href="https://rnplay.org/apps/umzv6g">https://rnplay.org/apps/umzv6g</a>.</p>

<p><img class="<a" src="href="http://i.imgur.com/aVeaXMc.gif">http://i.imgur.com/aVeaXMc.gif</a>" title="Final Press And Hold" ></p>

<h1>Final Code</h1>

<p>```
var React = require(&lsquo;react-native&rsquo;);</p>

<p>var {
  AppRegistry,
  StyleSheet,
  Animated,
  View,
  Text,
  TouchableWithoutFeedback
} = React;</p>

<p>var ACTION_TIMER = 400;
var COLORS = [&lsquo;rgb(255,255,255)&rsquo;, &lsquo;rgb(111,235,62)&rsquo;];</p>

<p>var AnimatedButtonPress = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
    pressAction: new Animated.Value(0),
    textComplete: '',
    buttonWidth: 0,
    buttonHeight: 0
};
</code></pre>

<p>  },
  handlePressIn: function() {</p>

<pre><code>Animated.timing(this.state.pressAction, {
    duration: ACTION_TIMER,
    toValue: 1
}).start(this.animationActionComplete);
</code></pre>

<p>  },
  handlePressOut: function() {</p>

<pre><code>Animated.timing(this.state.pressAction, {
        duration: this.state.pressAction.getAnimatedValue() * ACTION_TIMER,
        toValue: 0
}).start();
</code></pre>

<p>  },
  animationActionComplete: function() {</p>

<pre><code>var message = '';
if (this.state.pressAction.getAnimatedValue() === 1) {
    message = 'You held it long enough to fire the action!';
}
this.setState({
    textComplete: message
});
</code></pre>

<p>  },
  getButtonWidthLayout: function(e) {</p>

<pre><code>this.setState({
    buttonWidth: e.nativeEvent.layout.width - 6,
    buttonHeight: e.nativeEvent.layout.height - 6
});
</code></pre>

<p>  },
  getProgressStyles: function() {</p>

<pre><code>var width = this.state.pressAction.interpolate({
    inputRange: [0, 1],
    outputRange: [0, this.state.buttonWidth]
});
var bgColor = this.state.pressAction.interpolate({
    inputRange: [0, 1],
    outputRange: COLORS
})
return {
    width: width,
    height: this.state.buttonHeight,
    backgroundColor: bgColor
}
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
   &lt;View style={styles.container}&gt;
        &lt;TouchableWithoutFeedback 
            onPressIn={this.handlePressIn} 
            onPressOut={this.handlePressOut}
        &gt;
            &lt;View style={styles.button} onLayout={this.getButtonWidthLayout}&gt;
                &lt;Animated.View style={[styles.bgFill, this.getProgressStyles()]} /&gt;
                &lt;Text style={styles.text}&gt;Press And Hold Me&lt;/Text&gt;
            &lt;/View&gt;
        &lt;/TouchableWithoutFeedback&gt;
        &lt;View&gt;
            &lt;Text&gt;{this.state.textComplete}&lt;/Text&gt;
        &lt;/View&gt;
   &lt;/View&gt;
);
</code></pre>

<p>  }
});</p>

<p>var styles = StyleSheet.create({
  container: {</p>

<pre><code>flex: 1,
flexDirection: 'column',
alignItems: 'center',
justifyContent: 'center'
</code></pre>

<p>  },
  button: {</p>

<pre><code>padding: 10,
borderWidth: 3,
borderColor: '#111'
</code></pre>

<p>  },
  text: {</p>

<pre><code>backgroundColor: 'transparent',
color: '#111'
</code></pre>

<p>  },
  bgFill: {</p>

<pre><code>position: 'absolute',
top: 0,
left: 0
</code></pre>

<p>  }
});</p>

<p>AppRegistry.registerComponent(&lsquo;AnimatedButtonPress&rsquo;, () => AnimatedButtonPress);
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React-native Animated API with PanResponder]]></title>
    <link href="http://browniefed.com/blog/2015/08/15/react-native-animated-api-with-panresponder/"/>
    <updated>2015-08-15T14:17:00-07:00</updated>
    <id>http://browniefed.com/blog/2015/08/15/react-native-animated-api-with-panresponder</id>
    <content type="html"><![CDATA[<h1>Introduction</h1>

<p>The previous example was a very basic one, just moving a box around the screen. But you&rsquo;ll likely want to do something by touch. Dragging, dropping, flicking, all those good mobile interactions. I previously covered how to make Tinder cards but I didn&rsquo;t add any true animations in. With the new Animated API you can make an even better Tinder card demo. And that&rsquo;s what <a href="https://twitter.com/notbrent">Brent</a> did.</p>

<p>This blog post was inspired by <a href="https://github.com/brentvatne/react-native-animated-demo-tinder">https://github.com/brentvatne/react-native-animated-demo-tinder</a>. I decide to break it apart, simplify it and explain the bits as we re-build it.</p>

<p>We will not fully reimplement it since you can learn the full ins and outs by checking out the code.</p>

<p><img class="<a" src="href="http://i.imgur.com/b5K2fcx.gif">http://i.imgur.com/b5K2fcx.gif</a>" title="Final with rotation and opacity" ></p>

<!-- more -->


<h1>Setup</h1>

<p>Just like before we&rsquo;ll get a pretty basic setup going</p>

<p>Imports/Variables</p>

<p>```
var React = require(&lsquo;react-native&rsquo;);</p>

<p>var {
  AppRegistry,
  StyleSheet,
  View,
  Animated,
  PanResponder
} = React;</p>

<p>var SQUARE_DIMENSIONS = 100;</p>

<p>```</p>

<p>Styles</p>

<p>```
var styles = StyleSheet.create({
  container: {</p>

<pre><code>flex: 1,
alignItems: 'center',
justifyContent: 'center'
</code></pre>

<p>  },
  square: {</p>

<pre><code>width: SQUARE_DIMENSIONS,
height: SQUARE_DIMENSIONS,
backgroundColor: 'blue'
</code></pre>

<p>  }
});</p>

<p>```</p>

<p>Main Code</p>

<p>```
var AnimatedFlick = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
    pan: new Animated.ValueXY()
};
</code></pre>

<p>  },
  getStyle: function() {</p>

<pre><code>return [
          styles.square, 
          {
            transform: this.state.pan.getTranslateTransform()
          }
        ];
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
    &lt;Animated.View style={this.getStyle()} /&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
});
```</p>

<h1>Pan Responder</h1>

<p>The <code>PanResponder</code> is our touch handler. The great thing about the <code>PanResponder</code> and <code>Animated</code> API were that they were made to work together.</p>

<p>We need to create our PanResponder</p>

<p>```
  componentWillMount: function() {</p>

<pre><code>    this._panResponder = PanResponder.create({
      onMoveShouldSetResponderCapture: () =&gt; true, //Tell iOS that we are allowing the movement
      onMoveShouldSetPanResponderCapture: () =&gt; true, // Same here, tell iOS that we allow dragging
      onPanResponderGrant: (e, gestureState) =&gt; {
        this.state.pan.setOffset({x: this.state.pan.x.getAnimatedValue(), y: this.state.pan.y.getAnimatedValue()});
        this.state.pan.setValue({x: 0, y: 0}); //Initial value
      },
      onPanResponderMove: Animated.event([
        null, {dx: this.state.pan.x, dy: this.state.pan.y}
      ]), // Creates a function to handle the movement and set offsets
      onPanResponderRelease: () =&gt; {
        this.state.pan.flattenOffset(); // Flatten the offset so it resets the default positioning
      }
    });
</code></pre>

<p>  },</p>

<p><code>``
We need</code>onMoveShouldSetResponderCapture<code>and</code>onMoveShouldSetPanResponderCapture` to always return true. This tells iOS that we are allowing the user to make movements and we&rsquo;re going to track them.</p>

<p>The function <code>onPanResponderGrant</code> is called once when we approve the animation. This gives us all of our initial values. We set the start value, and then also the offset which is our current pan values. Then we set our animation start values to <code>0,0</code>. This basically resets our movement changes so our delta <code>x,y</code> will be applied from a 0 point. Hopefully that makes sense.</p>

<p>We give our <code>onPanResponderMove</code> an <code>Animated.event</code>. This creates a function that will automatically take the gestureState which has 2 keys on it <code>dx</code> and <code>dy</code> and put those changes on our <code>this.state.pan.x</code> and our <code>this.state.pan.y</code> respectively.</p>

<p>Finally <code>onPanResponderRelease</code> we call <code>flattenOffset</code>. This takes the current <code>x,y</code> and the current offset (aka how much you&rsquo;ve dragged it around). And combines them.</p>

<p>The internal code for flattenOffset looks like this</p>

<p>```
  flattenOffset(): void {</p>

<pre><code>this._value += this._offset;
this._offset = 0;
</code></pre>

<p>  }
```</p>

<p>```
  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
    &lt;Animated.View 
      style={this.getStyle()} 
      {...this._panResponder.panHandlers}
    /&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
<code>``
Here we spread the handlers onto the our</code>Animated.View` so it sets up all the calls correctly.</p>

<h1>We have a square that moves</h1>

<p>Great we have a square that moves and it stays where we left it, and also when we move it again it picks up from the same coordinates that we dropped it at.</p>

<p><img class="<a" src="href="http://i.imgur.com/vFYB4JY.gif">http://i.imgur.com/vFYB4JY.gif</a>" title="Moving Square" ></p>

<h1>Reset to 0 with a spring</h1>

<p>We just replace our <code>flattenOffset</code> call which would leave our square where we left it and instead create a spring that animates our <code>this.state.pan</code> back to 0. Which will correctly animate our <code>x,y</code> back to 0 and provide a nice little bounce.</p>

<p>Here is the code.</p>

<p>```
  onPanResponderRelease: () => {</p>

<pre><code>Animated.spring(this.state.pan, {
  toValue: 0
}).start();
</code></pre>

<p>  }
```
Yes it is really that simple.</p>

<p><img class="<a" src="href="http://i.imgur.com/PkNpyBH.gif">http://i.imgur.com/PkNpyBH.gif</a>" title="Springs back to center" ></p>

<h1>Opacity and rotation</h1>

<p>Because we want the opacity and the rotation to be tied to the movement position we can use the <code>interpolate</code> we created from <code>Animated.ValueXY</code> on <code>this.state.pan</code> .</p>

<p>We&rsquo;ll have to make some small adjustments but the only thing we need to change is our <code>getStyle</code> function.</p>

<p>```
  getStyle: function() {</p>

<pre><code>return [
          styles.square, 
          {
            transform: [
              {
                translateX: this.state.pan.x
              },
              {
                translateY: this.state.pan.y
              },
              {
                rotate: this.state.pan.x.interpolate({inputRange: [-200, 0, 200], outputRange: ["-30deg", "0deg", "30deg"]})
              }
            ]
          },
          {
            opacity: this.state.pan.x.interpolate({inputRange: [-200, 0, 200], outputRange: [0.5, 1, 0.5]})
          }
        ];
</code></pre>

<p>  },
<code>``
We create an interpolate that determines the correct value from an</code>inputRange<code>.
When our drag is</code>-200<code>or greater our rotate will be</code>-30 degrees<code>, at 0 it is 0, and if moved to the right at</code>200<code>or great then it's</code>30 degrees`.</p>

<p>Interpolate is smart enough to take an input range, and interpolate an inbetween degree. So as you slowly move the card the degrees will adjust, so an input value of <code>100</code> would translate to a <code>15 degree</code> rotation.</p>

<p>For opacity we want the same inputs, except our outputs will be <code>.5</code> for both sides and <code>1</code> at 0 movement.
The interpolation of the opacity operates the same as the degrees, as you rotate it&rsquo;ll adjust the opacity to a maximum/minimum of .5.</p>

<p><img class="<a" src="href="http://i.imgur.com/b5K2fcx.gif">http://i.imgur.com/b5K2fcx.gif</a>" title="Final with rotation and opacity" ></p>

<h1>Final</h1>

<p>This doesn&rsquo;t explain all the techniques used in the tinder card demo. One such thing is the flicking capabilities.
That uses <code>Animated.decay</code> and some physics (velocity,friction) to animate a value.</p>

<h3>Play with it here <a href="https://rnplay.org/apps/71CyoA">https://rnplay.org/apps/71CyoA</a>.</h3>

<h1>Full Code</h1>

<p>```
var React = require(&lsquo;react-native&rsquo;);</p>

<p>var {
  AppRegistry,
  StyleSheet,
  View,
  Animated,
  PanResponder
} = React;</p>

<p>var SQUARE_DIMENSIONS = 100;</p>

<p>var AnimatedFlick = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
    pan: new Animated.ValueXY()
};
</code></pre>

<p>  },
  componentWillMount: function() {</p>

<pre><code>    this._panResponder = PanResponder.create({
      onMoveShouldSetResponderCapture: () =&gt; true,
      onMoveShouldSetPanResponderCapture: () =&gt; true,
      onPanResponderGrant: (e, gestureState) =&gt; {
        this.state.pan.setOffset({x: this.state.pan.x.getAnimatedValue(), y: this.state.pan.y.getAnimatedValue()});
        this.state.pan.setValue({x: 0, y: 0});
      },
      onPanResponderMove: Animated.event([
            null, {dx: this.state.pan.x, dy: this.state.pan.y},
      ]),
      onPanResponderRelease: () =&gt; {
        Animated.spring(this.state.pan, {
          toValue: 0
        }).start();
      }
    });
</code></pre>

<p>  },<br/>
  getStyle: function() {</p>

<pre><code>return [
          styles.square, 
          {
            transform: [
              {
                translateX: this.state.pan.x
              },
              {
                translateY: this.state.pan.y
              },
              {
                rotate: this.state.pan.x.interpolate({inputRange: [-200, 0, 200], outputRange: ["-30deg", "0deg", "30deg"]})
              }
            ]
          },
          {
            opacity: this.state.pan.x.interpolate({inputRange: [-200, 0, 200], outputRange: [0.5, 1, 0.5]})
          }
        ];
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
    &lt;Animated.View 
      style={this.getStyle()} 
      {...this._panResponder.panHandlers}
    /&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
});</p>

<p>var styles = StyleSheet.create({
  container: {</p>

<pre><code>flex: 1,
alignItems: 'center',
justifyContent: 'center'
</code></pre>

<p>  },
  square: {</p>

<pre><code>width: SQUARE_DIMENSIONS,
height: SQUARE_DIMENSIONS,
backgroundColor: 'blue'
</code></pre>

<p>  }
});</p>

<p>AppRegistry.registerComponent(&lsquo;AnimatedFlick&rsquo;, () => AnimatedFlick);</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React-native Animated ScrollView Row Swipe Actions]]></title>
    <link href="http://browniefed.com/blog/2015/08/01/react-native-animated-listview-row-swipe/"/>
    <updated>2015-08-01T16:17:00-07:00</updated>
    <id>http://browniefed.com/blog/2015/08/01/react-native-animated-listview-row-swipe</id>
    <content type="html"><![CDATA[<h1>Introduction</h1>

<p>Have you ever wanted to swipe a row in a scroll view to take some sort of action. Swipe left to delete, swipe right to archive, swipe to do whatever. Well previously without the Animated API that wasn&rsquo;t necessarily hard it was just inefficient due to having to use <code>setState</code> causing a lot of diffs.</p>

<h1>What are we trying to accomplish</h1>

<p><img class="<a" src="href="http://i.imgur.com/z1tko0s.gif">http://i.imgur.com/z1tko0s.gif</a>" title="Swipe Action GIF from @dubert" ></p>

<p>This is not an orignal interaction I created, you can follow along with how I stumbled upon it and such here <a href="https://github.com/facebook/react-native/issues/2072">https://github.com/facebook/react-native/issues/2072</a>.</p>

<p>Swiping rows is also just a normal action in iOS. However there is an ongoing debate here about ListView/ScrollView being wrapped in a UITableView which would provide some of this interaction as default. You can read through it here <a href="https://github.com/facebook/react-native/issues/332">https://github.com/facebook/react-native/issues/332</a> but we&rsquo;ll forge ahead and implement it with what we have to work with.</p>

<!-- more -->


<h1>The Concept</h1>

<p>Previously I attempted, and successfully implemented this with the <code>PanResponder</code>. There is nothing particularly bad about that approach except you will run into issues being embedded in a <code>ScrollView</code>.</p>

<p>What issues? Well while swiping left/right the content direction locks won&rsquo;t be set, which means if you don&rsquo;t swipe perfectly left &lt;=> right and introduce some up/down your row will get stuck. That is not a good interaction.</p>

<p>So thanks to the solid recommendation by <a href="https://github.com/sahrens">sahrens</a> we will do a <code>ScrollView</code> with each row being a Horizontal <code>ScrollView</code>. This means iOS will negotiate content direction locks correctly. So when you scroll up and down the body content will scroll, left and right will cause each row to slide.</p>

<h1>Drawbacks</h1>

<p>There are some drawbacks.</p>

<ul>
<li>With the horizontal ScrollView you have to define the height (at least from what I could figure out).</li>
<li>The View in the horizontal ScrollView does not stretch completely regardless of what flex properties you add on it.</li>
<li>The PanResponder vs ContentOffset X values are opposites, so you have to multiply by -1.</li>
<li>The content offset is not as large as the PanResponder so I had to lower the RED threshold.</li>
</ul>


<p>Specifying the height is seemingly the largest drawback that I couldn&rsquo;t figure out. The width not auto-adjusting is also another drawback, however we have the dimensions to calculate the threshold so we could manually set the width if we wanted.</p>

<h1>Setup</h1>

<p>Variables we need</p>

<p>```
var React = require(&lsquo;react-native&rsquo;);
var Dimensions = require(&lsquo;Dimensions&rsquo;);</p>

<p>var {
  width,
  height
} = Dimensions.get(&lsquo;window&rsquo;);</p>

<p>var {
  AppRegistry,
  StyleSheet,
  ScrollView,
  View,
  Text,
  Animated
} = React;</p>

<p>var GREY = 0;
var GREEN = 1;
var RED = 2;</p>

<p>var values = [1,2,3,4];</p>

<p>var AnimatedScrollView = Animated.createAnimatedComponent(ScrollView);
```</p>

<p>We need the Device widths for calculating half the screen later for our events.
Also we setup color as integer steps, and then define arbitrary values for rows.</p>

<p>Finally we use the <code>createAnimatedComponent</code> supplied by <code>Animated</code> to create an Animated capable <code>ScrollView</code>.</p>

<p>What that means is that when you pass it interpolated values (like an interpolated background color) it&rsquo;ll correctly negotiate the values.</p>

<p>Styles</p>

<p>```</p>

<p>var styles = StyleSheet.create({
  container: {</p>

<pre><code>flex: 1,
flexDirection: 'column'
</code></pre>

<p>  },
  outerScroll: {</p>

<pre><code>flex: 1,
flexDirection: 'column'
</code></pre>

<p>  },
  row: {</p>

<pre><code>flex: 1
</code></pre>

<p>  }
});
```
Just some base styles, you&rsquo;ll see where they are used in a second.</p>

<h1>Basic ScrollView</h1>

<p>```
var AnimatedFlick = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
    values: values
};
</code></pre>

<p>  },</p>

<p>  _renderRow: function(value, index) {</p>

<pre><code>return (
    &lt;View 
      style={styles.row}
      key={index}
    &gt;
      &lt;Text&gt;{value + "  &lt;----- Slide the row that way and release"}&lt;/Text&gt;
    &lt;/View&gt;
)
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
    &lt;ScrollView style={styles.outerScroll}&gt;
      {this.state.values.map(this._renderRow, this)}
    &lt;/ScrollView&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
});
```</p>

<p>We setup some intial state the values we set in the setup section <code>var values = [1,2,3,4]</code>.
We map those values to the <code>_renderRow</code> function, which we just return a basic <code>View</code>, with some <code>Text</code>.</p>

<h1>ScrollView with Horizontal ScrollViews</h1>

<p>```
  _renderRow: function(value, index) {</p>

<pre><code>return (
    &lt;View 
      style={styles.row}
      key={index}
    &gt;
      &lt;ScrollView
        horizontal={true}
        directionalLockEnabled={true}
        style=
      &gt;
        &lt;View&gt;
          &lt;Text&gt;{value + "  &lt;----- Slide the row that way and release"}&lt;/Text&gt;
        &lt;/View&gt;
      &lt;/ScrollView&gt;
    &lt;/View&gt;
)
</code></pre>

<p>  }</p>

<p><code>``
We wrap our view content in</code>ScrollView<code>with</code>horizontal<code>true and</code>directionLockEnabeled`. This means when you start scroll one direction it will lock that direction and not let you scroll a different way. In our case once you start swiping left/right you can only swipe left/right.
Back to point 1, we have to set the height specifically here.</p>

<p>This is what we have now.</p>

<p><img class="<a" src="href="http://i.imgur.com/DTFHAvu.gif">http://i.imgur.com/DTFHAvu.gif</a>" title="Scroll In a Scroll" ></p>

<h1>Animate the Background Color</h1>

<p>```
  _renderRow: function(value, index) {</p>

<pre><code>var bgColor = this.state.colors[index].interpolate({
  inputRange: [
    GREY,
    GREEN,
    RED
  ],
  outputRange: [
    'rgb(180, 180, 180)', // GREY
    'rgb(63, 236, 35)', // GREEN
    'rgb(233, 19, 19)', // RED
  ],
});

return (
    &lt;View 
      style={styles.row}
      key={index}
    &gt;
      &lt;AnimatedScrollView
        horizontal={true}
        directionalLockEnabled={true}
        style={[{flex: 1, height: 100}, {backgroundColor: bgColor}]}
        onScroll={this._animateScroll.bind(this, index)}
        scrollEventThrottle={16}
      &gt;
        &lt;View style=&gt;
          &lt;Text&gt;{value + "  &lt;----- Slide the row that way and release"}&lt;/Text&gt;
        &lt;/View&gt;
      &lt;/AnimatedScrollView&gt;
    &lt;/View&gt;
)
</code></pre>

<p>  },
<code>``
We need to create an interpolation. How the interpolation works is given a value, in our case colors that are just an array of values</code>[0,1,2]<code>will return a new value which corresponds to the</code>outputRange<code>. So when the</code>this.state.colors[index]<code>value is</code>0<code>it will return</code>GREY<code>or</code>rgb(180, 180, 180)<code>, and so on and so forth. When it changes from</code>GREY<code>to</code>GREEN<code>it'll animate to the new color of</code>rgb(63, 236, 35)`.</p>

<p>This is where we use the <code>AnimatedScrollView</code> we created before. This will correctly take the animated value we pass in a grab the interpolatd background.</p>

<p>We pass in a function to onScroll and setup the <code>scrollEventThrottle</code> with the default value. This means our scroll event will be called every 16 millseconds.</p>

<p>```
  _animateScroll: function(index, e) {</p>

<pre><code>var threshold = width / 5;
var x = e.nativeEvent.contentOffset.x;
var target = null;

x = x * -1;

if (x &gt; -50 &amp;&amp; this._target != GREY) {
  target = GREY;
} else if (x &lt; -50 &amp;&amp; x &gt; -threshold &amp;&amp; this._target != GREEN) {
  target = GREEN;
} else if (x &lt; -threshold &amp;&amp; this._target != RED) {
  target = RED;
}

if (target !== null) {
  this._target = target;
  this._targetIndex = index;

  Animated.timing(this.state.colors[index], {
    toValue: target,
    duration: 180,
  }).start();
}
</code></pre>

<p>  },
```</p>

<p>We get the threshold of the <code>deviceWidth</code> we got at the creation of the app. We get the <code>x</code> offset of the scrollView. Finally depending on which direction you want users to swipes to take action we need to multiply ( or not ) by <code>-1</code>. The <code>-1</code> means swiping right to left will cause the actions to trigger.</p>

<p>We setup various thresholds to animate to. Start is <code>GREY</code>, middle threshold is <code>GREEN</code> and anything greater is <code>RED</code>.</p>

<p>Finally if target isn&rsquo;t null (aka someone did something), we trigger an <code>Animated.timing</code> on our color. This will say for the next 180 milliseconds transition to our target color. This will cause our color interpolation to kick in and transition the background.</p>

<p>Hopefully this all doesn&rsquo;t seem too complicated. We are essentially saying &ldquo;If someone swipes this far make the background color this one&rdquo;.</p>

<h1>Take an action</h1>

<p>```</p>

<pre><code>return (
    &lt;View 
      style={styles.row}
      key={index}
    &gt;
      &lt;AnimatedScrollView
        horizontal={true}
        directionalLockEnabled={true}
        style={[{flex: 1, height: 100}, {backgroundColor: bgColor}]}
        onScroll={this._animateScroll.bind(this, index)}
        scrollEventThrottle={16}
        onMomentumScrollBegin={this.takeAction}
      &gt;
        &lt;View style=&gt;
          &lt;Text&gt;{value + "  &lt;----- Slide the row that way and release"}&lt;/Text&gt;
        &lt;/View&gt;
      &lt;/AnimatedScrollView&gt;
    &lt;/View&gt;
)
</code></pre>

<p>  },
```</p>

<p>We do have to dig through the internal code a bit but a seemingly undocumented action of the <code>ScrollResponder</code> is the <code>onMomentumScrollBegin</code>. From the code comments this function is called when <code>When releasing the view starts bouncing back</code>. So the user has released, and the row is about to scroll back into the 0 position.</p>

<p>Why this action? Well we setup things to operate on the scroll actions. Any other event would cause the actions the user want to take to be wrong since the <code>onScroll</code> events will be fired when the user releases.</p>

<p>We should add some protection code and such, but you can implement that.</p>

<p>```
  takeAction: function() {</p>

<pre><code>this.setState({
  action: true
});
</code></pre>

<p>  },
```
Here we just are causing a re-render so our app updates with the state below. However in this particular method you would actually take an action based upon the offset the person swiped to.</p>

<p>```
  getActionText: function() {</p>

<pre><code>var actionText = '';

if (this.state.action) {
  if (this._target == GREEN) {
    actionText = 'Save Action';
  } else if (this._target == RED) {
    actionText = 'Delete Action'
  } else {
    actionText = 'No Action';
  }

  return 'You took "' + actionText + '" on the ' + this._targetIndex + ' row';
}

return 'You have not taken an action yet';
</code></pre>

<p>  },
```
Just determing text to show to the user.</p>

<h1>Final code</h1>

<p>This is a pretty nice technique, and some what simple to implement but as mentioned it has some drawbacks.</p>

<p>Check it out here live <a href="https://rnplay.org/apps/LDI42g">https://rnplay.org/apps/LDI42g</a>.</p>

<p>```
var React = require(&lsquo;react-native&rsquo;);
var Dimensions = require(&lsquo;Dimensions&rsquo;);</p>

<p>var {
  width,
  height
} = Dimensions.get(&lsquo;window&rsquo;);</p>

<p>var {
  AppRegistry,
  StyleSheet,
  ScrollView,
  ListView,
  View,
  Text,
  Animated
} = React;</p>

<p>var GREY = 0;
var GREEN = 1;
var RED = 2;</p>

<p>var values = [1,2,3,4];</p>

<p>var AnimatedScrollView = Animated.createAnimatedComponent(ScrollView);</p>

<p>var AnimatedFlick = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
    values: values,
    colors: values.map( () =&gt; new Animated.Value(GREY) )
};
</code></pre>

<p>  },
  _animateScroll: function(index, e) {</p>

<pre><code>var threshold = width / 5;
var x = e.nativeEvent.contentOffset.x;
var target = null;

x = x * -1;

if (x &gt; -50 &amp;&amp; this._target != GREY) {
  target = GREY;
} else if (x &lt; -50 &amp;&amp; x &gt; -threshold &amp;&amp; this._target != GREEN) {
  target = GREEN;
} else if (x &lt; -threshold &amp;&amp; this._target != RED) {
  target = RED;
}

if (target !== null) {
  this._target = target;
  this._targetIndex = index;

  Animated.timing(this.state.colors[index], {
    toValue: target,
    duration: 180,
  }).start();
}
</code></pre>

<p>  },
  takeAction: function() {</p>

<pre><code>this.setState({
  action: true
});
</code></pre>

<p>  },
  getActionText: function() {</p>

<pre><code>var actionText = '';

if (this.state.action) {
  if (this._target == GREEN) {
    actionText = 'Save Action';
  } else if (this._target == RED) {
    actionText = 'Delete Action'
  } else {
    actionText = 'No Action';
  }

  return 'You took "' + actionText + '" on the ' + this._targetIndex + ' row';
}

return 'You have not taken an action yet';
</code></pre>

<p>  },
  _renderRow: function(value, index) {</p>

<pre><code>var bgColor = this.state.colors[index].interpolate({
  inputRange: [
    GREY,
    GREEN,
    RED
  ],
  outputRange: [
    'rgb(180, 180, 180)',
    'rgb(63, 236, 35)',
    'rgb(233, 19, 19)',
  ],
});

return (
    &lt;View 
      style={styles.row}
      key={index}
    &gt;
      &lt;AnimatedScrollView
        horizontal={true}
        directionalLockEnabled={true}
        style={[{flex: 1, height: 100}, {backgroundColor: bgColor}]}
        onScroll={this._animateScroll.bind(this, index)}
        scrollEventThrottle={16}
        onMomentumScrollBegin={this.takeAction}
      &gt;
        &lt;View style=&gt;
          &lt;Text&gt;{value + "  &lt;----- Slide the row that way and release"}&lt;/Text&gt;
        &lt;/View&gt;
      &lt;/AnimatedScrollView&gt;
    &lt;/View&gt;
)
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
    &lt;ScrollView style={styles.outerScroll}&gt;
      {this.state.values.map(this._renderRow, this)}
    &lt;/ScrollView&gt;
    &lt;Text&gt;{this.getActionText()}&lt;/Text&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
});</p>

<p>var styles = StyleSheet.create({
  container: {</p>

<pre><code>flex: 1,
flexDirection: 'column'
</code></pre>

<p>  },
  outerScroll: {</p>

<pre><code>flex: 1,
flexDirection: 'column'
</code></pre>

<p>  },
  row: {</p>

<pre><code>flex: 1
</code></pre>

<p>  }
});</p>

<p>AppRegistry.registerComponent(&lsquo;AnimatedFlick&rsquo;, () => AnimatedFlick);
```</p>
]]></content>
  </entry>
  
</feed>
