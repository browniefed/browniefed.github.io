<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: react-native | JavaScript Without Grammar]]></title>
  <link href="http://browniefed.com/blog/categories/react-native/atom.xml" rel="self"/>
  <link href="http://browniefed.com/"/>
  <updated>2015-07-17T13:26:18-07:00</updated>
  <id>http://browniefed.com/</id>
  <author>
    <name><![CDATA[Jason Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[React-Native layout examples]]></title>
    <link href="http://browniefed.com/blog/2015/06/07/react-native-layout-examples/"/>
    <updated>2015-06-07T21:37:00-07:00</updated>
    <id>http://browniefed.com/blog/2015/06/07/react-native-layout-examples</id>
    <content type="html"><![CDATA[<p>Flexbox layout takes a bit getting used to. It&rsquo;s surprisngly simple but after so many years of box model css layout it throws you for a loop.</p>

<p>Some examples</p>

<h2>Percentage height sections</h2>

<p>These are seemingly simple to do in CSS. Specify <code>height: 50%</code> and you get a magical 50% height. Yeah I&rsquo;m over simplifying it but in general that&rsquo;s what you get. In flex it&rsquo;s different.</p>

<p>This percentage based layout question was asked here <a href="https://github.com/facebook/react-native/issues/364">https://github.com/facebook/react-native/issues/364</a>.</p>

<p>Laying out login screens may require significant white space. To accomplish % based layout we can use the <code>flex</code> property along with <code>flexDirection</code>.</p>

<p>Say you want 3 sections. Top <code>50%</code>, then two <code>25%</code> sections.</p>

<p>Our code would look something like this</p>

<p>```
var SampleApp = React.createClass({
  render: function() {</p>

<pre><code>  return (
      &lt;View style={styles.container}&gt;
          &lt;View style={styles.halfHeight} /&gt;
          &lt;View style={styles.quarterHeight} /&gt;
          &lt;View style={[styles.quarterHeight, {backgroundColor: '#CCC'}]} /&gt;
      &lt;/View&gt;
  )
</code></pre>

<p>  }
});</p>

<p>var styles = StyleSheet.create({</p>

<pre><code>container: {
    flex: 1,
    flexDirection: 'column'
},
halfHeight: {
    flex: .5,
    backgroundColor: '#FF3366'
},
quarterHeight: {
    flex: .25,
    backgroundColor: '#000'
}
</code></pre>

<p>});</p>

<p>```</p>

<p>This makes it look like percentages, however what actually is happening is just ratios.</p>

<p>The ratios are easier to represent with non-decimals. Equivalent code to the above would look like.</p>

<p>```
var styles = StyleSheet.create({</p>

<pre><code>container: {
    flex: 1,
    flexDirection: 'column'
},
halfHeight: {
    flex: 2,
    backgroundColor: '#FF3366'
},
quarterHeight: {
    flex: 1,
    backgroundColor: '#000'
}
</code></pre>

<p>});</p>

<p>```</p>

<p>That&rsquo;s saying that the <code>halfHeight</code> container should take up twice as much space, and the <code>quarterHeight</code> should take up one amount of space.
The actual numbers depend on screen size, and/or also derived from parent containers. So we can&rsquo;t attach specific heights.</p>

<p>It just means &ldquo; <code>halfHeight</code> should take up 2 units of height where <code>quarterHeight</code> takes up 1 unit/half as much height as the <code>halfHeight</code> container&rdquo;.</p>

<p><img class="<a" src="href="http://i.imgur.com/k4RI8Og.png">http://i.imgur.com/k4RI8Og.png</a>" title="Percentage based layout" ></p>

<p>You can check out a live demo here <a href="https://rnplay.org/apps/MbQEbQ">https://rnplay.org/apps/MbQEbQ</a></p>

<h2>React-Native Example Screens</h2>

<p>Not being very good at flexbox I figured what better way than to create a bunch of layout examples to practice.
That&rsquo;s when I saw <a href="http://www.invisionapp.com/do">http://www.invisionapp.com/do</a>. It has a bunch of beautiful layouts, so I am attempting to recreate some.</p>

<p>You can check out the repo here <a href="https://github.com/browniefed/react-native-screens">https://github.com/browniefed/react-native-screens</a></p>

<p>I&rsquo;ve made them all runnable on <code>rnplay.org</code>.</p>

<h4>Example: Login1</h4>

<p><a href="https://rnplay.org/apps/x7HRCA">https://rnplay.org/apps/x7HRCA</a></p>

<p><img class="<a" src="href="https://i.imgur.com/ceB0t2Z.png">https://i.imgur.com/ceB0t2Z.png</a>" title="Login1 Example" ></p>

<p>If you like this, feel free to contribute and download the screens from <a href="http://www.invisionapp.com/do">http://www.invisionapp.com/do</a>. I found the Sketch ones were the easiest to handle and export individual assets from.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React-Native Tinder like cards]]></title>
    <link href="http://browniefed.com/blog/2015/06/06/react-native-tinder-like-cards/"/>
    <updated>2015-06-06T19:33:00-07:00</updated>
    <id>http://browniefed.com/blog/2015/06/06/react-native-tinder-like-cards</id>
    <content type="html"><![CDATA[<h1>CHECK OUT ====> <a href="https://github.com/brentvatne/react-native-animated-demo-tinder">https://github.com/brentvatne/react-native-animated-demo-tinder</a> for a better demo with the new Animated API!!!</h1>

<h2>Intro</h2>

<p>The test of all good frameworks is how easy it is to implement Tinder right? Well with <code>react-native</code> we do get the benefits of flex box as well as some transforms which we&rsquo;ll take advantage of.</p>

<p>We don&rsquo;t have access to an easy physics, even though they were added in IOS7. If you&rsquo;d like physics you can use some JavaScript libraries like <code>rebound</code> <a href="https://github.com/facebook/rebound-js">https://github.com/facebook/rebound-js</a> from Facebook, or any others that don&rsquo;t require a DOM.</p>

<p>What we&rsquo;ll make</p>

<p><img class="<a" src="href="http://i.imgur.com/tTcT7xJ.png">http://i.imgur.com/tTcT7xJ.png</a>" title="End Result" ></p>

<h2>Concept</h2>

<p>We&rsquo;ll create a card. On touch press/grant we&rsquo;ll figure out the offset of the card to the touch and start generating the transform to move/rotate the card.</p>

<p>Well use the <code>style</code> <code>transform</code> property which we can find documentation here <a href="https://facebook.github.io/react-native/docs/transforms.html#proptypes">https://facebook.github.io/react-native/docs/transforms.html#proptypes</a>. However documentation is a little skimpy.</p>

<p>It&rsquo;s mostly straight forward once you dive in though.</p>

<h2>What we won&rsquo;t do.</h2>

<p>Physics. You can implement a bouncy spring system, but we&rsquo;ll keep it simple with a drag concept.</p>

<h2>Create a basic card</h2>

<p>We&rsquo;ll create a basic wrapper container and then create a card View.
We&rsquo;ll center everyting inside of our container using <code>alignItems</code> and <code>justifyContent</code> both <code>center</code>
Our card will just be <code>300</code> by <code>300</code>, with a little padding, and border.</p>

<p>```
render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
      &lt;View
        style={styles.card}
      &gt;
      &lt;/View&gt;
  &lt;/View&gt;
);
</code></pre>

<p>}</p>

<p>var styles = StyleSheet.create({
  container: {</p>

<pre><code>flex: 1,
alignItems: 'center',
justifyContent: 'center'
</code></pre>

<p>  },
  card: {</p>

<pre><code>borderWidth: 3,
borderRadius: 3,
borderColor: '#000',
width: 300,
height: 300,
padding: 10
</code></pre>

<p>  }
  });</p>

<p>```</p>

<p>Now that we have a generic card we can make it look a little nicer with an image, and some text.</p>

<h2>Add an Image/Text to card</h2>

<p>We&rsquo;ll add an image and set to a particular height. There is a current issue in <code>react-native</code> that doesn&rsquo;t maintain aspect ratio but that will be taken care of eventually.</p>

<p>We wrap our <code>Text</code> elements in <code>View</code> and position each <code>Text</code> item on the left and right.
There is a way to do this with flexbox but positioning like this is a little more explicit.</p>

<p>```
render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
      &lt;View
        style={styles.card}
      &gt;
        &lt;Image source= style={styles.cardImage} /&gt;
        &lt;View&gt;
          &lt;Text style={styles.textLeft}&gt;Rabbit, 10&lt;/Text&gt;
          &lt;Text style={styles.textRight}&gt;1 Connection&lt;/Text&gt;
        &lt;/View&gt;
      &lt;/View&gt;
  &lt;/View&gt;
);
</code></pre>

<p>}</p>

<p>var styles = StyleSheet.create({
  container: {</p>

<pre><code>flex: 1,
alignItems: 'center',
justifyContent: 'center'
</code></pre>

<p>  },
  card: {</p>

<pre><code>borderWidth: 3,
borderRadius: 3,
borderColor: '#000',
width: 300,
height: 300,
padding: 10
</code></pre>

<p>  },
  cardImage: {</p>

<pre><code>height: 260,
</code></pre>

<p>  },
  textLeft: {</p>

<pre><code>position: 'absolute',
left:0,
top:0
</code></pre>

<p>  },
  textRight: {</p>

<pre><code>position: 'absolute',
right: 0,
top: 0
</code></pre>

<p>  }
});</p>

<p>```</p>

<h2>Things to know about style</h2>

<p>Alright so there seems to be a lack of documentation around style in general. But <code>style</code> actually can receive an array.</p>

<p>You are capable of specifying a default layout, however doing overrides. For example take our card layout.</p>

<p>```
  card: {</p>

<pre><code>borderWidth: 3,
borderRadius: 3,
borderColor: '#000',
width: 300,
height: 300,
padding: 10
</code></pre>

<p>  }</p>

<p>```</p>

<p>This gets applied, but what if at some point in time we wanted to change the <code>borderColor</code> based on <code>state</code>.
Well we just override it on the style attribute like so</p>

<p>```</p>

<pre><code>&lt;View style={[styles.card, {borderColor: '#CCC'}]} /&gt;
</code></pre>

<p>```
So now the borderColor has a default but can be changed by just passing in an object.</p>

<p>This goes for <code>transform</code> as well which will set us up for the next challenge, actually dragging.</p>

<h2>Add in Drag</h2>

<p>We&rsquo;ll use the gesture responder system. The robustness is great, however I was expecting a little more information like deltas over the course of each drag update. We aren&rsquo;t given that to my knowledge so we&rsquo;ll computer it ourselves.</p>

<p>How the gesture system works is it must ask each element that has a gesture responder if it should be allowed to drag or not. In our case we have one element and minimal logic so we&rsquo;ll just return true. However at any point you can cancel a gesture by returning false.</p>

<p>In our case you need to respond <code>true</code> to <code>onStartShouldSetResponder</code> and then each subsequent move <code>onMoveShouldSetResponder</code>. If those return true then it will call <code>onResponderMove</code> each time with the new event.</p>

<p>We&rsquo;ll use <code>_onStartShouldSetResponder</code> function to setup our initial drag. Each subsequent move we subtract and get the delta of the move.</p>

<p>```
  getInitialState: function() {</p>

<pre><code>return {
  x: 0,
  y: 0
}
</code></pre>

<p>  },
  setPosition: function(e) {</p>

<pre><code>//Update our state with the deltaX/deltaY of the movement
this.setState({
  x: this.state.x + (e.nativeEvent.pageX - this.drag.x),
  y: this.state.y + (e.nativeEvent.pageY - this.drag.y)
});
//Set our drag to be the new position so our delta can be calculated next time correctly
this.drag.x = e.nativeEvent.pageX;
this.drag.y = e.nativeEvent.pageY;
</code></pre>

<p>  },
  resetPosition: function(e) {</p>

<pre><code>this.dragging = false;
//Reset on release
this.setState({
  x: 0,
  y: 0,
})
</code></pre>

<p>  },
  _onStartShouldSetResponder: function(e) {</p>

<pre><code>this.dragging = true;
//Setup initial drag coordinates
this.drag = {
  x: e.nativeEvent.pageX,
  y: e.nativeEvent.pageY
}
return true;
</code></pre>

<p>  },
  _onMoveShouldSetResponder: function(e) {</p>

<pre><code>return true;
</code></pre>

<p>  },
  getCardStyle: function() {</p>

<pre><code>var transform = [{translateX: this.state.x}, {translateY: this.state.y}];
return {transform: transform};
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
      &lt;View
        onResponderMove={this.setPosition}
        onResponderRelease={this.resetPosition}
        onStartShouldSetResponder={this._onStartShouldSetResponder}
        onMoveShouldSetResponder={this._onMoveShouldSetResponder}
        style={[styles.card, this.getCardStyle()]}
      &gt;
        &lt;Image source= style={styles.cardImage} /&gt;
        &lt;View style={styles.cardTextContainer}&gt;
          &lt;Text style={styles.textLeft}&gt;Rabbit, 10&lt;/Text&gt;
          &lt;Text style={styles.textRight}&gt;1 Connection&lt;/Text&gt;
        &lt;/View&gt;
      &lt;/View&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
});
```</p>

<p>So now when a user press down on our card and starts dragging it&rsquo;ll move around. On release it&rsquo;ll snap back to position <code>0,0</code>.</p>

<p>You can see we use the <code>translateX</code> and <code>translateY</code> transform properties. These will cause the ability for the card to be dragged around but not have to make it position absolute.</p>

<h2>Add in Rotate</h2>

<p>With Tinder and other card style systems as you drag the card left or right it will slightly rotate. It also rotates differently depending on the position you grab the card from (generally top or bottom).</p>

<p>The <code>transform</code> property on style also has a <code>rotate</code> option. This seems weird but it takes a string. That string can be something like <code>30deg</code> or <code>.05rad</code>. So it offers some flexibility. We&rsquo;ll use <code>degrees</code> since it&rsquo;s the easiest to comprehend.</p>

<p>We don&rsquo;t need to add anything to the view, just determine if we grabbed the card on the <code>top</code> or the <code>bottom</code>. Then depending on the offset drag make it rotate more as we move.</p>

<p>```
//Top of file
var Dimensions = require(&lsquo;Dimensions&rsquo;);
var windowSize = Dimensions.get(&lsquo;window&rsquo;);</p>

<p>//&hellip;
  _onStartShouldSetResponder: function(e) {</p>

<pre><code>this.dragging = true;

this.rotateTop = e.nativeEvent.locationY &lt;= 150;

this.drag = {
  x: e.nativeEvent.pageX,
  y: e.nativeEvent.pageY
}

return true;
</code></pre>

<p>  },
  getRotationDegree: function(rotateTop, x) {</p>

<pre><code>var rotation = ( (x/windowSize.width) * 100)/3;

var rotate = rotateTop ? 1 : -1,
    rotateString = (rotation * rotate) + 'deg';

return rotateString;
</code></pre>

<p>  },
  getCardStyle: function() {</p>

<pre><code>var transform = [{translateX: this.state.x}, {translateY: this.state.y}];

if (this.dragging) {
    transform.push({rotate: this.getRotationDegree(this.rotateTop, this.state.x)})
}

return {transform: transform};
</code></pre>

<p>  }
```</p>

<p>So we modify <code>_onStartShouldSetResponder</code> to determine wheter we grabbed top or bottom. We use the <code>locationY</code> property which is the point on the card that was touched. Since the card dimensions are <code>300x300</code> that means if the card was touched anywhere between <code>0 to 150</code> then it was touched on top.</p>

<p>Our <code>getCardStyle</code> will push a <code>rotate</code> object on if we are dragging.</p>

<p>We need to know how far around the screen you have dragged it from the center point.
So we get the screen dimensions, divide the width by the <code>pageX</code> coordinate which is just position of the element relative to the entire screen. To convert to degrees we multiply by <code>100</code> and divide by <code>3</code> to reduce the rotation.</p>

<p>If we touched on the bottom then we want to do a reverse rotation so we multiply by <code>-1</code>  and return a string that would return a value like <code>20.123deg</code> or <code>-20.123deg</code>.</p>

<h2>Add in Release Text</h2>

<p>Great we have dragging, we have rotating. Now how do we know which way they let go?
Well we can use those window dimensions and the <code>pageX</code> movement to determine if the card was released on the left or right.</p>

<p>```
  resetPosition: function(e) {</p>

<pre><code>this.dragging = false;
var left = e.nativeEvent.pageX &lt; (windowSize.width/2),
    displayText = left ? 'Released left' : 'Released right';

this.setState({
  x: 0,
  y: 0,
  lastDragDirectio: displayText
})
</code></pre>

<p>  },
```</p>

<h2>Final Code</h2>

<p>```
&lsquo;use strict&rsquo;;</p>

<p>var React = require(&lsquo;react-native&rsquo;);
var Dimensions = require(&lsquo;Dimensions&rsquo;);
var windowSize = Dimensions.get(&lsquo;window&rsquo;);</p>

<p>var {
  StyleSheet,
  AppRegistry,
  Text,
  View,
  ActivityIndicatorIOS,
  Image,
  Navigator,
  TouchableOpacity,
  Animation
} = React;</p>

<p>var Application = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
  x: 0,
  y: 0,
  lastDragDirectio: 'Drag and Release'
}
</code></pre>

<p>  },
  setPosition: function(e) {</p>

<pre><code>this.setState({
  x: this.state.x + (e.nativeEvent.pageX - this.drag.x),
  y: this.state.y + (e.nativeEvent.pageY - this.drag.y)
});
this.drag.x = e.nativeEvent.pageX;
this.drag.y = e.nativeEvent.pageY;
</code></pre>

<p>  },
  resetPosition: function(e) {</p>

<pre><code>this.dragging = false;
var left = e.nativeEvent.pageX &lt; (windowSize.width/2),
    displayText = left ? 'Released left' : 'Released right';

this.setState({
  x: 0,
  y: 0,
  lastDragDirectio: displayText
})
</code></pre>

<p>  },
  getRotationDegree: function(rotateTop, x) {</p>

<pre><code>var rotation = ( (x/windowSize.width) * 100)/3;

var rotate = rotateTop ? 1 : -1,
    rotateString = (rotation * rotate) + 'deg';

return rotateString;
</code></pre>

<p>  },
  getCardStyle: function() {</p>

<pre><code>var transform = [{translateX: this.state.x}, {translateY: this.state.y}];

if (this.dragging) {
    transform.push({rotate: this.getRotationDegree(this.rotateTop, this.state.x)})
}

return {transform: transform};
</code></pre>

<p>  },
  _onStartShouldSetResponder: function(e) {</p>

<pre><code>this.dragging = true;

this.rotateTop = e.nativeEvent.locationY &lt;= 150;

this.drag = {
  x: e.nativeEvent.pageX,
  y: e.nativeEvent.pageY
}

return true;
</code></pre>

<p>  },
  _onMoveShouldSetResponder: function(e) {</p>

<pre><code>return true;
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
      &lt;View
        onResponderMove={this.setPosition}
        onResponderRelease={this.resetPosition}
        onStartShouldSetResponder={this._onStartShouldSetResponder}
        onMoveShouldSetResponder={this._onMoveShouldSetResponder}
        style={[styles.card, this.getCardStyle()]}
      &gt;
        &lt;Image source= style={styles.cardImage} /&gt;
        &lt;View style={styles.cardTextContainer}&gt;
          &lt;Text style={styles.textLeft}&gt;Rabbit, 10&lt;/Text&gt;
          &lt;Text style={styles.textRight}&gt;1 Connection&lt;/Text&gt;
        &lt;/View&gt;
      &lt;/View&gt;
      &lt;View style={styles.dragText}&gt;
        &lt;Text&gt;{this.state.lastDragDirectio}&lt;/Text&gt;
      &lt;/View&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
});</p>

<p>var styles = StyleSheet.create({
  container: {</p>

<pre><code>flex: 1,
alignItems: 'center',
justifyContent: 'center'
</code></pre>

<p>  },
  dragText: {</p>

<pre><code>position: 'absolute',
bottom: 0,
left: 0
</code></pre>

<p>  },
  card: {</p>

<pre><code>borderWidth: 3,
borderRadius: 3,
borderColor: '#000',
width: 300,
height: 300,
padding: 10
</code></pre>

<p>  },
  cardImage: {</p>

<pre><code>height: 260,
</code></pre>

<p>  },
  textLeft: {</p>

<pre><code>position: 'absolute',
left:0,
top:0
</code></pre>

<p>  },
  textRight: {</p>

<pre><code>position: 'absolute',
right: 0,
top: 0
</code></pre>

<p>  }
});</p>

<p>module.exports = Application;
```</p>

<h2>Result</h2>

<p><img class="<a" src="href="http://i.imgur.com/q7siPyO.gif">http://i.imgur.com/q7siPyO.gif</a>" title="End Result" ></p>

<p>You can check out and play with the end result here.</p>

<h2>Preview Online!</h2>

<p>Thanks to React Native Playground you can play with this code live online.</p>

<p><a href="https://rnplay.org/apps/6uPJug">https://rnplay.org/apps/6uPJug</a></p>

<p>Your homework can be to add a bounce when the card is released.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CSS-Layout and React-Art]]></title>
    <link href="http://browniefed.com/blog/2015/06/01/css-layout-and-react-art/"/>
    <updated>2015-06-01T10:29:00-07:00</updated>
    <id>http://browniefed.com/blog/2015/06/01/css-layout-and-react-art</id>
    <content type="html"><![CDATA[<h3>Intro</h3>

<p>If you&rsquo;ve used <code>react-native</code> before then you may know that &ldquo;css&rdquo; you&rsquo;re writing isn&rsquo;t actually CSS. It&rsquo;s a descriptor for a layout engine. That layout engine is <a href="https://github.com/facebook/css-layout">css-layout</a> which was created by <a href="https://twitter.com/Vjeux">@vjeux</a> and compiled to Java/Objective-C.</p>

<p>Layout is difficult. There have been attempts at various constraint based layouts in JavaScript, <a href="http://gridstylesheets.org/">GSS</a> is one of those. Which is a port of Apples <code>Cassowary</code> constraint solver which was also ported to JavaScript <a href="https://github.com/slightlyoff/cassowary.js">https://github.com/slightlyoff/cassowary.js</a>.</p>

<p>Now this is all fine and well but from the bit I&rsquo;ve read constraints fall down sometimes. This usually happens when you don&rsquo;t specify enough constraints based on the current layout.</p>

<h3>Layout is hard!</h3>

<p>Parent layouts get effected by their child layouts. CSS is weird in that you can remove items from layout with <code>position: absolute</code> but ultimately the top parent <code>width/height</code> is directly effected by it&rsquo;s children.</p>

<p>This is an over simplification but many times in <code>React</code> you have to hook into <code>componentDidMount</code> get the child width and take action.</p>

<p>An example would be even width labels in a form. We could measure the text but depending on <code>font</code>, <code>font-size</code> it could measure each value differently. So we hide the form on initial render, get the max label width and set it on state.</p>

<h3>CSS-Layout Basics</h3>

<p>It takes a subset of flexbox and some other styling parameters and returns <code>width</code>, and the <code>left/top</code> offsets for each item and it&rsquo;s children.</p>

<p>This example is taken directly from the <code>css-layout</code> git repo.</p>

<p>```
computeLayout(
  {style: {padding: 50}, children: [</p>

<pre><code>{style: {padding: 10, alignSelf: 'stretch'}}
</code></pre>

<p>  ]}
);
// =>
{</p>

<pre><code>width: 120,
height: 120,
top: 0,
left: 0,
children: [{
    width: 20,
    height: 20,
    top: 50,
    left: 50
}]
</code></pre>

<p>}
```</p>

<p>So explaining this. We have an item with a padding of <code>50</code>, so <code>50px</code> around the entire item.</p>

<p>It&rsquo;s child item has a padding of <code>10</code>, so <code>10px</code> all the way around.</p>

<p>Therefore the parent has <code>50*2 = 100</code> initial width/height. Now we take into account the children.</p>

<p>Width/Height:</p>

<p><code>
Parent: `50*2 = 100` +  `10*2 = 20` = `100 + 120`
Child: `10*2 = 20`
</code></p>

<p>Position:</p>

<p><code>
Parent: `x = 0, y = 0` since we are starting there.
Child: Parent padding `50` so our child is inset at `x = 50, y = 50`
</code></p>

<p>Lets change the child width and see what happens
```
computeLayout(</p>

<pre><code>{
    style: {
        padding: 50
    },
    children: [{
        style: {
            padding: 10,
            width: 1000,
            alignSelf: 'stretch'
        }
    }]
}
</code></pre>

<p>);
// =>
{</p>

<pre><code>"width": 1100,
"height": 120,
"top": 0,
"left": 0,
"children": [{
    "width": 1000,
    "height": 20,
    "top": 50,
    "left": 50
}]
</code></pre>

<p>}
<code>``
Because our child defined a width of</code>1000<code>we then add on our</code>50*2<code>of padding on both sides and now the parent has a width of</code>1100`.</p>

<p>There are some other nuances that you can read about in the <code>css-layout</code> repo.</p>

<h3>Basic Example</h3>

<p>First off we&rsquo;ll need a component tree. Now in React they transpile JSX, and build the component tree for us. However in our case we can just create a JSON tree.</p>

<p>```
var componentTree = {</p>

<pre><code>style: {
    padding: 10
},
component: Rectangle,
children: [{
    style: {
        padding: 10,
        flexDirection: 'column',
        alignItems: 'center'
    },
    component: Rectangle,
    children: [
        {
            style: {
                width: 30,
                height: 30
            },
            component: Rectangle
        },
        {
            style: {
                margin: 10,
                width: 50,
                height: 50,
                alignItems: 'center',
                justifyContent: 'center'
            },
            component: Circle,
            children: [
                {
                    style: {
                        width: 10,
                        height: 10
                    },
                    component: Circle
                }
            ]
        }
    ]
}]
</code></pre>

<p>};</p>

<p>```</p>

<p>We add a <code>component</code> parameter to the tree. This is the thing that will be rendered.
We could add additional properties here, maybe create custom renderers but we&rsquo;ll keep it simple.</p>

<p>The break down is like so</p>

<ul>
<li>A surrounding rectangle w/ <code>10px</code> of padding all around</li>
<li>1 child that is a rectangle with another <code>10px</code> of padding, and it&rsquo;s children in a <code>column</code> based layout.</li>
<li>We align each of the items in the <code>center</code></li>
<li>2 children one a Rectangle, one a Cirlce.</li>
<li>Rectangle = <code>width = 30, height = 30</code></li>
<li>Circle = <code>width = 50, height = 50</code> and a surrounding <code>10px</code> margin and it&rsquo;s children centered vertically and horizontally</li>
<li>That cirlce has a circle inside that is <code>width = 10</code> and `height = 10
We&rsquo;ll have to do some basic math on the Circle to compute the radius, and center it correctly.</li>
</ul>


<p>Now we&rsquo;ll need to traverse the layout.
We&rsquo;ll do that with a function that calls itself</p>

<p>```
function traverseLayout(componentTree, layout) {</p>

<pre><code>var Component = componentTree.component;
return (
    &lt;Group x={layout.left} y={layout.top}&gt;
        &lt;Component
            {...getProps(Component, layout)}
         /&gt;
         &lt;Group x={0} y={0}&gt;
            {
                !componentTree.children ? null : componentTree.children.map(function(child, index) {
                    return traverseLayout(child, layout.children[index]);
                })

            }
         &lt;/Group&gt;
    &lt;/Group&gt;
)
</code></pre>

<p>}
```
This is a super crude layout renderer but it works for our purposes.</p>

<p>It creates a group and we pass in our <code>top/left</code> to <code>x/y</code> of the group. This is necessary to make our children <code>top/left</code> work correctly.
Then renders the component with selected props. We&rsquo;ll just render <code>stroke="#000"</code> and a stroke={1}.</p>

<p>Then if we have children we will call ourself with the child component and layout.</p>

<p>To process the props we need to render different props for specific components.</p>

<p><code>Rectangle</code> needs <code>width/height</code> which we have.
<code>Circle</code> needs the radius computed, and to then be ofset by the radius. So we just divide the <code>width/2</code> and for positioning <code>y</code> we divide the <code>height/2</code>.</p>

<p>```
function getProps(component, layout) {</p>

<pre><code>var props = {
    x: 0,
    y: 0
};

if (Rectangle === component) {
    props.width = layout.width;
    props.height = layout.height;

} else if (Circle === component) {
    props.radius = layout.width/2;
    props.x += (layout.width/2)
    props.y += (layout.height/2);
}

props.stroke = "#000"; // Just to visualize
props.strokeWidth = 1; // Just to visualize
return props;
</code></pre>

<p>}
```</p>

<p>That is it, now we can render a tree of <code>Rectangles</code> and <code>Circles</code>. The complete code is below.</p>

<p>```
var React = require(&lsquo;react&rsquo;);
var ReactArt = require(&lsquo;react-art&rsquo;),</p>

<pre><code>Surface = ReactArt.Surface,
Group = ReactArt.Group,
computeLayout = require('css-layout'),
Circle = require('react-art/shapes/circle'),
Rectangle = require('react-art/shapes/rectangle');
</code></pre>

<p>var Surface = ReactArt.Surface;</p>

<p>var viewportWidth = function() {</p>

<pre><code>return  window.innerWidth - 100;
</code></pre>

<p>}
var viewportHeight = function() {</p>

<pre><code>return window.innerHeight - 100;
</code></pre>

<p>}</p>

<p>var componentTree = {</p>

<pre><code>style: {
    padding: 10
},
component: Rectangle,
children: [{
    style: {
        padding: 10,
        flexDirection: 'column',
        alignItems: 'center'
    },
    component: Rectangle,
    children: [
        {
            style: {
                width: 30,
                height: 30
            },
            component: Rectangle
        },
        {
            style: {
                margin: 10,
                width: 50,
                height: 50,
                alignItems: 'center',
                justifyContent: 'center'
            },
            component: Circle,
            children: [
                {
                    style: {
                        width: 10,
                        height: 10
                    },
                    component: Circle
                }
            ]
        }
    ]
}]
</code></pre>

<p>};</p>

<p>var layout = computeLayout(componentTree);</p>

<p>function traverseLayout(componentTree, layout) {</p>

<pre><code>var Component = componentTree.component;
return (
    &lt;Group x={layout.left} y={layout.top}&gt;
        &lt;Component
            {...getProps(Component, layout)}
         /&gt;
         &lt;Group x={0} y={0}&gt;
            {
                !componentTree.children ? null : componentTree.children.map(function(child, index) {
                    return traverseLayout(child, layout.children[index]);
                })

            }
         &lt;/Group&gt;
    &lt;/Group&gt;
)
</code></pre>

<p>}</p>

<p>function getProps(component, layout) {</p>

<pre><code>var props = {
    x: 0,
    y: 0
};

if (Rectangle === component) {
    props.width = layout.width;
    props.height = layout.height;

} else if (Circle === component) {
    props.radius = layout.width/2;
    props.x += (layout.width/2)
    props.y += (layout.height/2);
}

props.stroke = "#000";
props.strokeWidth = 1;
return props;
</code></pre>

<p>}</p>

<p>var Demo = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {

}
</code></pre>

<p>  },
  getRenderLayout: function() {</p>

<pre><code>return traverseLayout(componentTree, layout);
</code></pre>

<p>  },
  render: function () {</p>

<pre><code>return (
  &lt;div&gt;
    &lt;Surface
        width={viewportWidth()}
        height={viewportHeight()}
    &gt;
        {this.getRenderLayout()}
    &lt;/Surface&gt;
  &lt;/div&gt;
);
</code></pre>

<p>  }
});</p>

<p>module.exports = Demo;
```</p>

<h3>Possibilities</h3>

<p>Tic-tac-toe? Heh.</p>

<p>This could be made to layout components arbitrarily much like we do with <code>react-native</code>. It&rsquo;s not perfect and could only be used in specific scenarios but it&rsquo;s still a fun prototype.</p>

<h3>Demo</h3>

<p data-height="624" data-theme-id="0" data-slug-hash="zGZOMN" data-default-tab="result" data-user="browniefed" class='codepen'>See the Pen <a href='http://codepen.io/browniefed/pen/zGZOMN/'>zGZOMN</a> by Jason Brown (<a href='http://codepen.io/browniefed'>@browniefed</a>) on <a href='http://codepen.io'>CodePen</a>.</p>


<script async src="http://browniefed.com//assets.codepen.io/assets/embed/ei.js"></script>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Create a map with React-Art]]></title>
    <link href="http://browniefed.com/blog/2015/05/30/create-a-map-with-react-art/"/>
    <updated>2015-05-30T10:15:00-07:00</updated>
    <id>http://browniefed.com/blog/2015/05/30/create-a-map-with-react-art</id>
    <content type="html"><![CDATA[<h3>Intro</h3>

<p>Just Like the title states, we&rsquo;re going to make a map with <code>react-art</code>. When you think of maps many people jump straight to <code>leaflet</code>, <code>google maps</code>, or <code>mapbox</code>. Well one of the key things they are doing is just plotting map tiles.</p>

<p>Map tiles are just images that can be stitched together and form a map. That is why whenever you drag on a map portions of it pop in in squares.</p>

<p>Don&rsquo;t worry, I won&rsquo;t get deep into mapping terminology because I don&rsquo;t know it. If you want to learn checkout this post <a href="http://www.macwright.org/2012/05/15/how-web-maps-work.html">http://www.macwright.org/2012/05/15/how-web-maps-work.html</a></p>

<p>All you&rsquo;ll need to know is <code>Latitude</code>, <code>Longitude</code>, and <code>Tile</code> aka (an image of a piece of a map).</p>

<p>Our tilemap source will be the fabulous <a href="https://www.openstreetmap.org/">OpenStreetMap</a>. It&rsquo;s a community driven mapping solution. Check it out and contribute if you can!</p>

<p>This was going to be a blog post about creating a map but I ended up turning it into a library.</p>

<h3>What I Built</h3>

<p>I ended up writing up a library to show it off.</p>

<p>Checkout <a href="https://github.com/browniefed/react-art-map">https://github.com/browniefed/react-art-map</a> for the library and examples.</p>

<p>We use <a href="https://github.com/zacbarton/node-googlemaps-utils">https://github.com/zacbarton/node-googlemaps-utils</a> and
<a href="https://github.com/gagan-bansal/map-the-tiles">https://github.com/gagan-bansal/map-the-tiles</a>.</p>

<p>These 2 libraries are helper libraries.</p>

<p><code>googlemaps-utils</code> takes a <code>width/height</code> and a central <code>lat/long</code> and gives us a bounding box which is just the <code>top/left</code> coordinate and the <code>bottom/right</code> coordinate.</p>

<p>We then take that bounding box and convert it to meter points so we can generate a <a href="http://en.wikipedia.org/wiki/Mercator_projection">mercator projection</a>.</p>

<p>The <code>map-the-tiles</code> takes those meter points and returns <code>x,y,z</code> points;</p>

<p>Those <code>x,y,z</code> points get fed into the OSM url <code>http://{s}.tile.osm.org/{z}/{x}/{y}.png</code> and we get our tile images.</p>

<p>We can then render them at their given <code>top/left</code> points w/ <code>react-art</code>.</p>

<p>Ultimately this library was built with A LOT of googling and assembling some tools people already constructed.</p>

<h3>Some Internals</h3>

<p>Most of the logic is just in the <code>TileUtil</code>. There are likely much more efficient ways to do this however this is my first stab at it with my limited geo knowledge.</p>

<p>Converts <code>lat/long</code> to meter points
```</p>

<pre><code>degrees2meters(lon,lat) {
    var x = lon * 20037508.34 / 180;
    var y = Math.log(Math.tan((90 + lat) * Math.PI / 360)) / (Math.PI / 180);
    y = y * 20037508.34 / 180;
    return [x, y]
}
</code></pre>

<p>```</p>

<p>Converts meters to coordinates
```</p>

<pre><code>meters2degress(x,y) {
    var lon = x *  180 / 20037508.34 ;
    var lat = Number(180 / Math.PI * (2 * Math.atan(Math.exp(y * Math.PI / 180)) - Math.PI / 2));
    return [lon, lat]
}
</code></pre>

<p>```</p>

<p>The main layout generator.</p>

<p>```</p>

<pre><code>getTileLayout(options) {
    var layout = [];
    var bounds = gmu.calcBounds(options.center[1], options.center[0], options.zoom, options.width, options.height); // GET COORDINATE BOUNDS

    var topLeftMeters = TileUtil.degrees2meters(bounds.left, bounds.top),
        bottomRightMeters = TileUtil.degrees2meters(bounds.right, bounds.bottom);

    //Conver the coordinates each to meters

    var tiler = new MapTheTiles(null, options.tileWidth); // Create a generic tiler based on our tile width

    var layoutForBounds = {
        top: topLeftMeters[1],
        left: topLeftMeters[0],
        right: bottomRightMeters[0],
        bottom: bottomRightMeters[1]
    };
    //Pass in the meters for each point

    var tiles = tiler.getTiles(layoutForBounds, options.zoom) // Get the x,y,z points for our zoom level

    tiles.forEach(function(tile) {
        var coordPoint = {
            x: tile.X,
            y: tile.Y,
            z: tile.Z
        },
        coord = {
            x: tile.left,
            y: tile.top,
            img: TileUtil.getTileUrl(options.tileSource, coordPoint, options.subdomains) //Just format the OSM tile resource
        };

        layout.push(coord);
    }, this);

    return layout;
}
</code></pre>

<p>```</p>

<p>This is how we render each tile.
We have the <code>x/y</code> coordinates thanks to our tiler.</p>

<p>We use <code>Paths.js</code> to create a generic rectangular path.
This is so we can support <code>react-native</code> in the future since the shapes have yet to be created.</p>

<p>Then we create a new fill with the tile image and set it to the width/height of the generic tile at <code>0,0</code> of the shape.</p>

<p>This technically is a pattern for the background but because we set it to the exact <code>width/height</code> of the image it just renders the image once.</p>

<p>```
var rectanglePath = Rectangle({
  top: 0,
  left: 0,
  right: 256,
  bottom: 256
}).path.print();
///UP ABOVE</p>

<pre><code>    return layout.map(function(tile) {
        return (
            &lt;Shape
                d={rectanglePath}
                x={tile.x}
                y={tile.y}
                fill={new Pattern(tile.img, this.props.tileWidth , this.props.tileWidth, 0, 0)}
            /&gt;
        )
    }, this);
</code></pre>

<p>```</p>

<h3>The Code</h3>

<p>```
var React = require(&lsquo;react&rsquo;);
var ReactMap = require(&lsquo;react-art-map&rsquo;);
var ReactArt = require(&lsquo;react-art&rsquo;),</p>

<pre><code>Circle = require('react-art/shapes/circle');
</code></pre>

<p>var Map = ReactMap.Map;</p>

<p>var viewportWidth = function() {</p>

<pre><code>return  window.innerWidth - 100;
</code></pre>

<p>}
var viewportHeight = function() {</p>

<pre><code>return window.innerHeight - 100;
</code></pre>

<p>}</p>

<p>var center = [</p>

<pre><code>-122.668197,45.525292
</code></pre>

<p>],
offset = 3;</p>

<p>var Demo = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
  center: center,
  zoom: 15,
  x: 100
}
</code></pre>

<p>  },
  componentDidMount: function() {</p>

<pre><code>requestAnimationFrame(this.updateCircle);
</code></pre>

<p>  },
  updateCircle: function() {</p>

<pre><code>if (this.state.x &gt;= viewportWidth()) {
    offset = -3;
} else if ( this.state.x &lt;= 99) {
    offset = 3;
}

this.state.x += offset;
this.setState(this.state, function() {
    requestAnimationFrame(this.updateCircle);
});
</code></pre>

<p>  },
  handleDrag: function(newCenter) {</p>

<pre><code>this.setState({
  center: newCenter
});
</code></pre>

<p>  },
  render: function () {</p>

<pre><code>return (
  &lt;div&gt;
    &lt;Map
        width={viewportWidth()}
        height={viewportHeight()}
        center={this.state.center}
        zoom={this.state.zoom}
        tileSource="http://{s}.tile.osm.org/{z}/{x}/{y}.png"
        onDrag={this.handleDrag}
    &gt;
        &lt;Circle 
            x={this.state.x}
            y={100}
            radius={30}
            stroke="#000"
            strokeWidth={5}
        /&gt;
    &lt;/Map&gt;
  &lt;/div&gt;
);
</code></pre>

<p>  }
});</p>

<p>module.exports = Demo;
```</p>

<h3>React Native?!?!?!</h3>

<p>React Native has a map implementation but it doesn&rsquo;t allow for much flexibility. You can render pins but that is about it.</p>

<p>With this library once the Pattern fill gets implemented you can render any map tile based service + any cool visualiztions on the map that you want.</p>

<p>I&rsquo;ve logged an issue here <a href="https://github.com/facebook/react-native/issues/1462">https://github.com/facebook/react-native/issues/1462</a> so follow along for when it gets implemented.</p>

<h3>Results</h3>

<p data-height="624" data-theme-id="0" data-slug-hash="PqWRvz" data-default-tab="result" data-user="browniefed" class='codepen'>See the Pen <a href='http://codepen.io/browniefed/pen/PqWRvz/'>PqWRvz</a> by Jason Brown (<a href='http://codepen.io/browniefed'>@browniefed</a>) on <a href='http://codepen.io'>CodePen</a>.</p>


<script async src="http://browniefed.com//assets.codepen.io/assets/embed/ei.js"></script>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting react-art running on react-native]]></title>
    <link href="http://browniefed.com/blog/2015/05/03/getting-react-art-running-on-react-native/"/>
    <updated>2015-05-03T20:33:00-07:00</updated>
    <id>http://browniefed.com/blog/2015/05/03/getting-react-art-running-on-react-native</id>
    <content type="html"><![CDATA[<p>I hadn&rsquo;t realized that the react-art native rendering stuff had landed in into the react-native core.
So I figured I&rsquo;d try and get in running. I am an XCode noob so I&rsquo;ll be sure and be descriptive.</p>

<p>First off lets set up a react-native project. (Assuming you have react-native cli installed);</p>

<p><code>react-native init react_art_demo</code></p>

<p>The current released version of <code>react-native</code> doesn&rsquo;t have the ART libs in it so in our <code>node_modules</code> folder we can delete the <code>react-native</code> in there and do a git clone of master <code>git clone https://github.com/facebook/react-native.git</code></p>

<p>We will also need the <code>art</code> lib itself installed. So <code>cd</code> to the root of <code>react_art_demo</code>.
Then run <code>npm install art</code></p>

<p>Once we have the master repo of <code>react-native</code>, and <code>art</code> installed we can open up our <code>react_art_demo</code> project in XCode.</p>

<p>We will need to do 2 things.</p>

<ul>
<li>Add the <code>ART.xcodeproj</code> to XCode</li>
<li>Link the binary</li>
</ul>


<p>To add ART.xcodeproj find the file located in <code>react-native/Libraries/ART/ART.xcodeproj</code> and just drag it over to the <code>Libraries</code> section in XCode.
That should look like so</p>

<p><img class="<a" src="href="http://i.imgur.com/TWeDUTa.png">http://i.imgur.com/TWeDUTa.png</a>" title="Add ART.xcodeproj to Libraries" ></p>

<p>Next we&rsquo;ll link the binary.</p>

<p>With the root <code>react_art_demo</code> project selected on the left, select <code>Build Phases</code> from the center view.
There will be a section called &ldquo;Link Binary With Libraries&rdquo;, expand it, press the + and select <code>libART.a</code></p>

<p>Like so</p>

<p><img class="<a" src="href="http://i.imgur.com/lIMZkfh.png">http://i.imgur.com/lIMZkfh.png</a>" title="Link binary" ></p>

<p>Just as a warning, I didn&rsquo;t link the binary and got a few &ldquo;No manager class found for view with module name&rdquo; errors.</p>

<p>Now go forth and write your <code>react-art</code>. I always like to get the <code>vector-widget</code> example running so to do that here is the code.</p>

<p><code>index.ios.js</code></p>

<p>```
/<em>*
 * Sample React Native App
 * <a href="https://github.com/facebook/react-native">https://github.com/facebook/react-native</a>
 </em>/
&lsquo;use strict&rsquo;;</p>

<p>var React = require(&lsquo;react-native&rsquo;);
var {
  AppRegistry,
  StyleSheet,
  Text,
  View,
} = React;</p>

<p>var VectorWidget = require(&lsquo;./VectorWidget&rsquo;);</p>

<p>var react_art_demo = React.createClass({</p>

<p>  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
    &lt;VectorWidget style={styles.vector}/&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
});</p>

<p>var styles = StyleSheet.create({
  container: {</p>

<pre><code>flex: 1,
alignItems: 'center',
backgroundColor: '#FFF',
</code></pre>

<p>  },
  vector: {</p>

<pre><code>width: 100,
height: 100
</code></pre>

<p>  },
  welcome: {</p>

<pre><code>fontSize: 20,
textAlign: 'center',
margin: 10,
</code></pre>

<p>  },
  instructions: {</p>

<pre><code>color: '#333333',
marginBottom: 5,
marginTop: 100
</code></pre>

<p>  },
});</p>

<p>AppRegistry.registerComponent(&lsquo;react_art_demo&rsquo;, () => react_art_demo);
```</p>

<p>And your <code>VectorWidget.js</code> file</p>

<p>```
/<em>*
 * Copyright 2013 Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 </em>/
&ldquo;use strict&rdquo;;</p>

<p>var React = require(&lsquo;react-native&rsquo;);
var ReactART = require(&lsquo;ReactNativeART&rsquo;);
var {</p>

<pre><code>Art,
TouchableWithoutFeedback
</code></pre>

<p>} = React;</p>

<p>var {</p>

<pre><code>Group,
Shape,
Surface,
Transform
</code></pre>

<p>} = ReactArt;</p>

<p>var MOUSE_UP_DRAG = 0.978;
var MOUSE_DOWN_DRAG = 0.9;
var MAX_VEL = 11;
var CLICK_ACCEL = 3;
var BASE_VEL = 0.15;</p>

<p>/<strong>
 * An animated SVG component.
 */
var VectorWidget = React.createClass({
  /</strong>
   * Initialize state members.
   */
  getInitialState: function() {</p>

<pre><code>return {degrees: 0, velocity: 0, drag: MOUSE_UP_DRAG};
</code></pre>

<p>  },</p>

<p>  /<em>*
   * When the component is mounted into the document &ndash; this is similar to a
   * constructor, but invoked when the instance is actually mounted into the
   * document. Here&rsquo;s, we&rsquo;ll just set up an animation loop that invokes our
   * method. Binding of <code>this.onTick</code> is not needed because all React methods
   * are automatically bound before being mounted.
   </em>/
  componentDidMount: function() {</p>

<pre><code>this._interval = window.setInterval(this.onTick, 20);
</code></pre>

<p>  },</p>

<p>  componentWillUnmount: function() {</p>

<pre><code>window.clearInterval(this._interval);
</code></pre>

<p>  },</p>

<p>  onTick: function() {</p>

<pre><code>var nextDegrees = this.state.degrees + BASE_VEL + this.state.velocity;
var nextVelocity = this.state.velocity * this.state.drag;
this.setState({degrees: nextDegrees, velocity: nextVelocity});
</code></pre>

<p>  },</p>

<p>  /<em><em>
   * This is the &ldquo;main&rdquo; method for any component. The React API allows you to
   * describe the structure of your UI component at </em>any</em> point in time.
   */
  render: function() {</p>

<pre><code>return (
  &lt;Surface
    width={700}
    height={700}
    {this.renderGraphic(this.state.degrees)}
  &lt;/Surface&gt;
);
</code></pre>

<p>  },</p>

<p>  /<em>*
   * Better SVG support for React coming soon.
   </em>/
  renderGraphic: function(rotation) {</p>

<pre><code>return (
  &lt;Group
  &gt;
    &lt;Group x={210} y={135}&gt;
      &lt;Shape fill="rgba(0,0,0,0.1)" d={BORDER_PATH} /&gt;
      &lt;Shape fill="#7BC7BA" d={BG_PATH} /&gt;
      &lt;Shape fill="#DCDCDC" d={BAR_PATH} /&gt;
      &lt;Shape fill="#D97B76" d={RED_DOT_PATH} /&gt;
      &lt;Shape fill="#DBBB79" d={YELLOW_DOT_PATH} /&gt;
      &lt;Shape fill="#A6BD8A" d={GREEN_DOT_PATH} /&gt;
      &lt;Group x={55} y={29}&gt;
        &lt;Group rotation={rotation} originX={84} originY={89}&gt;
          &lt;Shape fill="#FFFFFF" d={CENTER_DOT_PATH} /&gt;
          &lt;Group&gt;
            &lt;Shape d={RING_ONE_PATH} stroke="#FFFFFF" strokeWidth={8} /&gt;
            &lt;Shape d={RING_TWO_PATH} transform={RING_TWO_ROTATE} stroke="#FFFFFF" strokeWidth={8} /&gt;
            &lt;Shape d={RING_THREE_PATH} transform={RING_THREE_ROTATE} stroke="#FFFFFF" strokeWidth={8} /&gt;
          &lt;/Group&gt;
        &lt;/Group&gt;
      &lt;/Group&gt;
    &lt;/Group&gt;
  &lt;/Group&gt;
);
</code></pre>

<p>  }
});</p>

<p>var BORDER_PATH = &ldquo;M3.00191459,4 C1.34400294,4 0,5.34785514 0,7.00550479 L0,220.994495 C0,222.65439 1.34239483,224 3.00191459,224 L276.998085,224 C278.655997,224 280,222.652145 280,220.994495 L280,7.00550479 C280,5.34561033 278.657605,4 276.998085,4 L3.00191459,4 Z M3.00191459,4&rdquo;;
var BG_PATH = &ldquo;M3.00191459,1 C1.34400294,1 0,2.34785514 0,4.00550479 L0,217.994495 C0,219.65439 1.34239483,221 3.00191459,221 L276.998085,221 C278.655997,221 280,219.652145 280,217.994495 L280,4.00550479 C280,2.34561033 278.657605,1 276.998085,1 L3.00191459,1 Z M3.00191459,1&rdquo;;
var BAR_PATH = &ldquo;M3.00191459,0 C1.34400294,0 0,1.34559019 0,3.00878799 L0,21 C0,21 0,21 0,21 L280,21 C280,21 280,21 280,21 L280,3.00878799 C280,1.34708027 278.657605,0 276.998085,0 L3.00191459,0 Z M3.00191459,0&rdquo;;
var RED_DOT_PATH = &ldquo;M12.5,17 C16.0898511,17 19,14.0898511 19,10.5 C19,6.91014895 16.0898511,4 12.5,4 C8.91014895,4 6,6.91014895 6,10.5 C6,14.0898511 8.91014895,17 12.5,17 Z M12.5,17&rdquo;;
var YELLOW_DOT_PATH = &ldquo;M31.5,17 C35.0898511,17 38,14.0898511 38,10.5 C38,6.91014895 35.0898511,4 31.5,4 C27.9101489,4 25,6.91014895 25,10.5 C25,14.0898511 27.9101489,17 31.5,17 Z M31.5,17&rdquo;;
var GREEN_DOT_PATH = &ldquo;M50.5,17 C54.0898511,17 57,14.0898511 57,10.5 C57,6.91014895 54.0898511,4 50.5,4 C46.9101489,4 44,6.91014895 44,10.5 C44,14.0898511 46.9101489,17 50.5,17 Z M50.5,17&rdquo;;
var CENTER_DOT_PATH = &ldquo;M84,105 C92.8365564,105 100,97.8365564 100,89 C100,80.1634436 92.8365564,73 84,73 C75.1634436,73 68,80.1634436 68,89 C68,97.8365564 75.1634436,105 84,105 Z M84,105&rdquo;;
var RING_ONE_PATH = &ldquo;M84,121 C130.391921,121 168,106.673113 168,89 C168,71.3268871 130.391921,57 84,57 C37.6080787,57 0,71.3268871 0,89 C0,106.673113 37.6080787,121 84,121 Z M84,121&rdquo;;
var RING_TWO_PATH = &ldquo;M84,121 C130.391921,121 168,106.673113 168,89 C168,71.3268871 130.391921,57 84,57 C37.6080787,57 0,71.3268871 0,89 C0,106.673113 37.6080787,121 84,121 Z M84,121&rdquo;;
var RING_THREE_PATH = &ldquo;M84,121 C130.391921,121 168,106.673113 168,89 C168,71.3268871 130.391921,57 84,57 C37.6080787,57 0,71.3268871 0,89 C0,106.673113 37.6080787,121 84,121 Z M84,121&rdquo;;
var RING_TWO_ROTATE = new Transform().translate(84.000000, 89.000000).rotate(-240.000000).translate(-84.000000, -89.000000);
var RING_THREE_ROTATE = new Transform().translate(84.000000, 89.000000).rotate(-300.000000).translate(-84.000000, -89.000000);</p>

<p>module.exports = VectorWidget;
```</p>

<p>You may notice that I removed the <code>mouseDown/mouseUp</code> stuff.
I tried getting it work very briefly with <code>onPress</code> and <code>TouchableWithoutFeedback</code> but I couldn&rsquo;t get it working.
If you get it figured out let me know.</p>

<h2>Conclusion</h2>

<p>That&rsquo;s it, you can now render your react-art code natively. Enjoy</p>

<p><img class="<a" src="href="http://i.imgur.com/AXbsaTB.png">http://i.imgur.com/AXbsaTB.png</a>" title="Final result" ></p>
]]></content>
  </entry>
  
</feed>
