<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: react-art | JavaScript Without Grammar]]></title>
  <link href="http://browniefed.com/blog/categories/react-art/atom.xml" rel="self"/>
  <link href="http://browniefed.com/"/>
  <updated>2015-05-30T19:23:07-07:00</updated>
  <id>http://browniefed.com/</id>
  <author>
    <name><![CDATA[Jason Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Create a map with React-Art]]></title>
    <link href="http://browniefed.com/blog/2015/05/30/create-a-map-with-react-art/"/>
    <updated>2015-05-30T10:15:00-07:00</updated>
    <id>http://browniefed.com/blog/2015/05/30/create-a-map-with-react-art</id>
    <content type="html"><![CDATA[<h3>Intro</h3>

<p>Just Like the title states, we&rsquo;re going to make a map with <code>react-art</code>. When you think of maps many people jump straight to <code>leaflet</code>, <code>google maps</code>, or <code>mapbox</code>. Well one of the key things they are doing is just plotting map tiles.</p>

<p>Map tiles are just images that can be stitched together and form a map. That is why whenever you drag on a map portions of it pop in in squares.</p>

<p>Don&rsquo;t worry, I won&rsquo;t get deep into mapping terminology because I don&rsquo;t know it. If you want to learn checkout this post <a href="http://www.macwright.org/2012/05/15/how-web-maps-work.html">http://www.macwright.org/2012/05/15/how-web-maps-work.html</a></p>

<p>All you&rsquo;ll need to know is <code>Latitude</code>, <code>Longitude</code>, and <code>Tile</code> aka (an image of a piece of a map).</p>

<p>Our tilemap source will be the fabulous <a href="https://www.openstreetmap.org/">OpenStreetMap</a>. It&rsquo;s a community driven mapping solution. Check it out and contribute if you can!</p>

<p>This was going to be a blog post about creating a map but I ended up turning it into a library.</p>

<h3>What I Built</h3>

<p>I ended up writing up a library to show it off.</p>

<p>Checkout <a href="https://github.com/browniefed/react-art-map">https://github.com/browniefed/react-art-map</a> for the library and examples.</p>

<p>We use <a href="https://github.com/zacbarton/node-googlemaps-utils">https://github.com/zacbarton/node-googlemaps-utils</a> and
<a href="https://github.com/gagan-bansal/map-the-tiles">https://github.com/gagan-bansal/map-the-tiles</a>.</p>

<p>These 2 libraries are helper libraries.</p>

<p><code>googlemaps-utils</code> takes a <code>width/height</code> and a central <code>lat/long</code> and gives us a bounding box which is just the <code>top/left</code> coordinate and the <code>bottom/right</code> coordinate.</p>

<p>We then take that bounding box and convert it to meter points so we can generate a <a href="http://en.wikipedia.org/wiki/Mercator_projection">mercator projection</a>.</p>

<p>The <code>map-the-tiles</code> takes those meter points and returns <code>x,y,z</code> points;</p>

<p>Those <code>x,y,z</code> points get fed into the OSM url <code>http://{s}.tile.osm.org/{z}/{x}/{y}.png</code> and we get our tile images.</p>

<p>We can then render them at their given <code>top/left</code> points w/ <code>react-art</code>.</p>

<p>Ultimately this library was built with A LOT of googling and assembling some tools people already constructed.</p>

<h3>Some Internals</h3>

<p>Most of the login is just in the <code>TileUtil</code></p>

<p>Converts <code>lat/long</code> to meter points
```</p>

<pre><code>degrees2meters(lon,lat) {
    var x = lon * 20037508.34 / 180;
    var y = Math.log(Math.tan((90 + lat) * Math.PI / 360)) / (Math.PI / 180);
    y = y * 20037508.34 / 180;
    return [x, y]
}
</code></pre>

<p>```</p>

<p>Converts meters to coordinates
```</p>

<pre><code>meters2degress(x,y) {
    var lon = x *  180 / 20037508.34 ;
    var lat = Number(180 / Math.PI * (2 * Math.atan(Math.exp(y * Math.PI / 180)) - Math.PI / 2));
    return [lon, lat]
}
</code></pre>

<p>```</p>

<p>The main layout generator.</p>

<p>```</p>

<pre><code>getTileLayout(options) {
    var layout = [];
    var bounds = gmu.calcBounds(options.center[1], options.center[0], options.zoom, options.width, options.height); // GET COORDINATE BOUNDS

    var topLeftMeters = TileUtil.degrees2meters(bounds.left, bounds.top),
        bottomRightMeters = TileUtil.degrees2meters(bounds.right, bounds.bottom);

    //Conver the coordinates each to meters

    var tiler = new MapTheTiles(null, options.tileWidth); // Create a generic tiler based on our tile width

    var layoutForBounds = {
        top: topLeftMeters[1],
        left: topLeftMeters[0],
        right: bottomRightMeters[0],
        bottom: bottomRightMeters[1]
    };
    //Pass in the meters for each point

    var tiles = tiler.getTiles(layoutForBounds, options.zoom) // Get the x,y,z points for our zoom level

    tiles.forEach(function(tile) {
        var coordPoint = {
            x: tile.X,
            y: tile.Y,
            z: tile.Z
        },
        coord = {
            x: tile.left,
            y: tile.top,
            img: TileUtil.getTileUrl(options.tileSource, coordPoint, options.subdomains) //Just format the OSM tile resource
        };

        layout.push(coord);
    }, this);

    return layout;
}
</code></pre>

<p>```</p>

<p>This is how we render each tile.
We have the <code>x/y</code> coordinates thanks to our tiler.</p>

<p>We use <code>Paths.js</code> to create a generic rectangular path.
This is so we can support <code>react-native</code> in the future since the shapes have yet to be created.</p>

<p>Then we create a new fill with the tile image and set it to the width/height of the generic tile at <code>0,0</code> of the shape.</p>

<p>This technically is a pattern for the background but because we set it to the exact <code>width/height</code> of the image it just renders the image once.</p>

<p>```
var rectanglePath = Rectangle({
  top: 0,
  left: 0,
  right: 256,
  bottom: 256
}).path.print();
///UP ABOVE</p>

<pre><code>    return layout.map(function(tile) {
        return (
            &lt;Shape
                d={rectanglePath}
                x={tile.x}
                y={tile.y}
                fill={new Pattern(tile.img, this.props.tileWidth , this.props.tileWidth, 0, 0)}
            /&gt;
        )
    }, this);
</code></pre>

<p>```</p>

<h3>The Code</h3>

<p>```
var React = require(&lsquo;react&rsquo;);
var ReactMap = require(&lsquo;react-art-map&rsquo;);
var ReactArt = require(&lsquo;react-art&rsquo;),</p>

<pre><code>Circle = require('react-art/shapes/circle');
</code></pre>

<p>var Map = ReactMap.Map;</p>

<p>var viewportWidth = function() {</p>

<pre><code>return  window.innerWidth - 100;
</code></pre>

<p>}
var viewportHeight = function() {</p>

<pre><code>return window.innerHeight - 100;
</code></pre>

<p>}</p>

<p>var center = [</p>

<pre><code>-122.668197,45.525292
</code></pre>

<p>],
offset = 3;</p>

<p>var Demo = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
  center: center,
  zoom: 15,
  x: 100
}
</code></pre>

<p>  },
  componentDidMount: function() {</p>

<pre><code>requestAnimationFrame(this.updateCircle);
</code></pre>

<p>  },
  updateCircle: function() {</p>

<pre><code>if (this.state.x &gt;= viewportWidth()) {
    offset = -3;
} else if ( this.state.x &lt;= 99) {
    offset = 3;
}

this.state.x += offset;
this.setState(this.state, function() {
    requestAnimationFrame(this.updateCircle);
});
</code></pre>

<p>  },
  handleDrag: function(newCenter) {</p>

<pre><code>this.setState({
  center: newCenter
});
</code></pre>

<p>  },
  render: function () {</p>

<pre><code>return (
  &lt;div&gt;
    &lt;Map
        width={viewportWidth()}
        height={viewportHeight()}
        center={this.state.center}
        zoom={this.state.zoom}
        tileSource="http://{s}.tile.osm.org/{z}/{x}/{y}.png"
        onDrag={this.handleDrag}
    &gt;
        &lt;Circle 
            x={this.state.x}
            y={100}
            radius={30}
            stroke="#000"
            strokeWidth={5}
        /&gt;
    &lt;/Map&gt;
  &lt;/div&gt;
);
</code></pre>

<p>  }
});</p>

<p>module.exports = Demo;
```</p>

<h3>React Native?!?!?!</h3>

<p>React Native has a map implementation but it doesn&rsquo;t allow for much flexibility. You can render pins but that is about it.</p>

<p>With this library once the Pattern fill gets implemented you can render any map tile based service + any cool visualiztions on the map that you want.</p>

<p>I&rsquo;ve logged an issue here <a href="https://github.com/facebook/react-native/issues/1462">https://github.com/facebook/react-native/issues/1462</a> so follow along for when it gets implemented.</p>

<h3>Results</h3>

<p data-height="624" data-theme-id="0" data-slug-hash="PqWRvz" data-default-tab="result" data-user="browniefed" class='codepen'>See the Pen <a href='http://codepen.io/browniefed/pen/PqWRvz/'>PqWRvz</a> by Jason Brown (<a href='http://codepen.io/browniefed'>@browniefed</a>) on <a href='http://codepen.io'>CodePen</a>.</p>


<script async src="http://browniefed.com//assets.codepen.io/assets/embed/ei.js"></script>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React-Art and Bar Charts]]></title>
    <link href="http://browniefed.com/blog/2015/05/29/react-art-and-bar-charts/"/>
    <updated>2015-05-29T08:53:00-07:00</updated>
    <id>http://browniefed.com/blog/2015/05/29/react-art-and-bar-charts</id>
    <content type="html"><![CDATA[<h3>Introduction</h3>

<p>I&rsquo;ve shown in the past how to utilize <code>react-art</code> and other libraries to do animations, and render arbitrary things. So now lets bring it all together, lets render a simple bar chart.</p>

<p>I&rsquo;m going to leverage <a href="https://github.com/andreaferretti/paths-js">Paths.js</a> because it was made for this exact reason. Given data, generate an immutable set of paths. Ultimately that is what visualizations are, a data set converted to a set of paths.</p>

<p>The end result will look something
<img class="<a" src="href="http://i.imgur.com/DpChFtO.png">http://i.imgur.com/DpChFtO.png</a>" title="Bar Chart Result w/ Hover" ></p>

<h3>Boilerplate</h3>

<p>I like to setup a boilerplate templat that just renders an arbitrary surface that is the full width of the viewport. Also to make things response we&rsquo;ll hook up some event listeners to the window resize and trigger a re-render.</p>

<p>We will bring in each side <code>100px</code> and add a <code>margin</code> of <code>50px</code> to each side to give us some padding on each side. Also note we should totally debounce the resize event on the window if this was production!</p>

<p>```
var React = require(&lsquo;react&rsquo;),</p>

<pre><code>ReactArt = require('react-art'),
Surface = ReactArt.Surface;
</code></pre>

<p>var viewportWidth = function() {</p>

<pre><code>return  window.innerWidth - 100;
</code></pre>

<p>}
var viewportHeight = function() {</p>

<pre><code>return window.innerHeight - 100;
</code></pre>

<p>}</p>

<p>var Demo = React.createClass({</p>

<pre><code>getInitialState: function() {
    return {
        width: viewportWidth(),
        height: viewportHeight()
    }
},
componentDidMount: function() {
    window.addEventListener('resize', this.refresh, false); //This should be debounced
},
componentWillUnmount: function() {
    window.removeEventListener('resize', this.refresh, false);
},
refresh: function() {
    this.setState({
        width: viewportWidth(),
        height: viewportHeight()
    });
},

render: function() {
    var bar = this.getBar();

    return (
        &lt;div style= style=&gt;
            &lt;Surface
                width={this.state.width}
                height={this.state.height}
            &gt;

            &lt;/Surface&gt;
        &lt;/div&gt;
    );
}
</code></pre>

<p>});</p>

<p>module.exports = Demo;
```</p>

<h3>Data and the Chart</h3>

<p>We need some data, so I&rsquo;ll steal some from the <code>Paths.js</code> wiki, and also steal the colors.</p>

<p>We&rsquo;ll add a method that returns a Bar Chart generated by <code>Paths.js</code> that is dervied from width/height we set on state.
A new Bar Chart will get called every time we call <code>setState</code>.</p>

<p>```
var data = [</p>

<pre><code>[
  { name: 'Italy', population: 59859996 },
  { name: 'Spain', population: 46704314 },
  { name: 'France', population: 65806000 },
  { name: 'Romania', population: 20121641 },
  { name: 'Greece', population: 10815197 }
],
[
  { name: 'Zambia', population: 14580290 },
  { name: 'Cameroon', population: 20386799 },
  { name: 'Nigeria', population: 173615000 },
  { name: 'Ethiopia', population: 86613986 },
  { name: 'Ghana', population: 24658823 }
]
</code></pre>

<p>  ];</p>

<p>var colorPallete = [&ldquo;#FEE871&rdquo;, &ldquo;#E5FAAF&rdquo;];</p>

<p>getBar: function() {</p>

<pre><code>var bar = Bar({
  data: data,
  accessor: function(x) { return x.population; }, // Value to use
  compute: {
    color: function(i) { return colorPallete[i]; } //Color of the bar
  },
  width: this.state.width, //Set it to our surface width so it is responsive when our surface width changes
  height: this.state.height, //Set it to our surface height so it's repsponsive
  gutter: 10
});

return bar;
</code></pre>

<p>}</p>

<p>```</p>

<h3>Lets create the X/Y axis bars</h3>

<p>The X axis and Y axis can be generated with straight lines by once again <code>Paths.js</code> <code>Path</code> method.</p>

<p>The <code>X</code> axis starts at the bottom left corner, so <code>0,height</code>, and runs to the far right, so <code>width,height</code>.</p>

<p>The <code>Y</code> axis starts at the top right corner, so <code>0,0</code>, and runs along the left side to the bottom so <code>0,height</code></p>

<p>We merely stroke a 1px black line.</p>

<p>```
getXAxis: function() {</p>

<pre><code>var path = Path().moveto(0, this.state.height).lineto(this.state.width, this.state.height);
return (
    &lt;Shape d={path.print()} strokeWidth={1} stroke="#000" /&gt;
);   
</code></pre>

<p>},
getYAxis: function() {</p>

<pre><code>var path = Path().moveto(0,0).lineto(0, this.state.height);
return (
    &lt;Shape d={path.print()} strokeWidth={1} stroke="#000" /&gt;
); 
</code></pre>

<p>},
render: function() {</p>

<pre><code>    return (
        &lt;div style= style=&gt;
            &lt;Surface
                width={this.state.width}
                height={this.state.height}
            &gt;
                &lt;Group&gt;
                    {this.getXAxis()}
                    {this.getYAxis()}
                &lt;/Group&gt;
            &lt;/Surface&gt;
        &lt;/div&gt;
    );
}
</code></pre>

<p>```</p>

<h3>Render the Bar Graph</h3>

<p>We&rsquo;ll call <code>this.getBar()</code> to just generate one bar graph and then pipe it into each function that needs it.
To make this more testable we&rsquo;d probably just want to provide each function with absolutely necessary info but just keep that in mind if you implement this for real.</p>

<p>All we do is map over each <code>curve</code> that we have, in our case we have <code>10</code> data points so therefore we have <code>10</code> curves.
The color comes from the way we grouped our data and the pallette we provided in the first step.</p>

<p>```</p>

<pre><code>getBarChart: function(bar) {
    return bar.curves.map(function(bar) {
        return (
            &lt;Group&gt;
              &lt;Shape d={bar.line.path.print()} fill={bar.color}/&gt;
            &lt;/Group&gt;
        )
    }, this)
},
render: function() {
    var bar = this.getBar();

    return (
        &lt;div style= style=&gt;
            &lt;Surface
                width={this.state.width}
                height={this.state.height}
            &gt;
                &lt;Group&gt;
                    {this.getBarChart(bar)} 
                &lt;/Group&gt;
                &lt;Group&gt;
                    {this.getXAxis(bar)}
                    {this.getYAxis(bar)}
                &lt;/Group&gt;
            &lt;/Surface&gt;
        &lt;/div&gt;
    );
}
</code></pre>

<p>```</p>

<h3>Render the Bar Information</h3>

<p>Lets also display some text about the bars. We&rsquo;ll use <code>Text</code> from <code>react-art</code> to do that.
We need to calculate a few points, which <code>Paths.js</code> will help us with.</p>

<p>Since each bar is a rectangle it just has 4 points, we can get the <code>points</code> from the path.
The path will gives us 4 arrays, each with <code>x,y</code> coordinates of each corner point.</p>

<p>We need to do a little subtraction of the <code>x,y</code> coordinates to figure out the width of each bar, and height of each bar so we can place our text.</p>

<p>We&rsquo;ll use the <code>Group</code> element from <code>react-art</code> to adjust our coordinate system to start at the top left of each bar.
The name and population will be aligned to the center, and at the bottom of the bar. We can use <code>x,y</code> coordinates to derive our width/height.</p>

<p>```</p>

<pre><code>getBarChart: function(bar) {
    return bar.curves.map(function(bar) {

        var points = bar.line.path.points(),
            right = points[0][0],
            top = points[0][1],
            left = points[2][0],
            bottom = points[2][1],
            width = right - left,
            height = bottom - top;

        return (
            &lt;Group&gt;
              &lt;Shape d={bar.line.path.print()} fill={bar.color}/&gt;

              &lt;Group x={left} y={top}&gt;
                &lt;Text x={width/2} y={height - 24} alignment="middle" fill="#000" font='bold 10px "Arial"'&gt;{bar.item.name}&lt;/Text&gt;
                &lt;Text x={width/2} y={height - 12} alignment="middle" fill="#000" font='bold 10px "Arial"'&gt;{bar.item.population +''}&lt;/Text&gt;
              &lt;/Group&gt;
            &lt;/Group&gt;
        )
    }, this)
},
</code></pre>

<p>```</p>

<h3>Hover data for fun</h3>

<p>Just to show how to handle mouse events we can have a <code>mouseMove</code> on each bar.
We&rsquo;ll bind each hover event with the <code>item</code> object which has the name and population.</p>

<p>When a new bar is hovered or the mouse is moved it will set the <code>hoveredItem</code> object and coordinates on our state which will cause a re-render.
Each movement of the mouse will cause a re-render so be sure and debounce this as well.</p>

<p>The hovered data displayed will actually use HTML not <code>react-art</code> since we wrap the <code>Surface</code> in a <code>div</code> and give it <code>position:relative</code>. This will mean it has the same coordinates as our <code>Surface</code> mouse events which is why we can just use <code>x,y</code> on the event.</p>

<p>```</p>

<pre><code>handleMouseMove: function(item, e) {
    this.setState({
        hoveredItem: item,
        hoveredY: e.y,
        hoveredX: e.x
    });
},
getBarChart: function(bar) {
    return bar.curves.map(function(bar) {

        var points = bar.line.path.points(),
            right = points[0][0],
            top = points[0][1],
            left = points[2][0],
            bottom = points[2][1],
            width = right - left,
            height = bottom - top;

        return (
            &lt;Group 
              onMouseMove={this.handleMouseMove.bind(this, bar.item)}
            &gt;
              &lt;Shape d={bar.line.path.print()} fill={bar.color}/&gt;

              &lt;Group x={left} y={top}&gt;
                &lt;Text x={width/2} y={height - 24} alignment="middle" fill="#000" font='bold 10px "Arial"'&gt;{bar.item.name}&lt;/Text&gt;
                &lt;Text x={width/2} y={height - 12} alignment="middle" fill="#000" font='bold 10px "Arial"'&gt;{bar.item.population +''}&lt;/Text&gt;
              &lt;/Group&gt;
            &lt;/Group&gt;
        )
    }, this)
},
getHoveredData: function() {
    if (!this.state.hoveredItem) {
        return null;
    }
    return (
            &lt;div style=&gt;
                &lt;h2&gt;{this.state.hoveredItem.name}&lt;/h2&gt;
                &lt;h5&gt;{this.state.hoveredItem.population}&lt;/h5&gt;
            &lt;/div&gt;
        )
},
render: function() {
    var bar = this.getBar();

    return (
        &lt;div style= style=&gt;
            &lt;Surface
                width={this.state.width}
                height={this.state.height}
            &gt;
                &lt;Group&gt;
                    {this.getBarChart(bar)} 
                &lt;/Group&gt;
                &lt;Group&gt;
                    {this.getXAxis(bar)}
                    {this.getYAxis(bar)}
                &lt;/Group&gt;
            &lt;/Surface&gt;
            {this.getHoveredData()}

        &lt;/div&gt;
    );
}
</code></pre>

<p>```</p>

<h3>Final Code</h3>

<p>Finally all the code combined.</p>

<p>```
var React = require(&lsquo;react&rsquo;),</p>

<pre><code>ReactArt = require('react-art'),
Surface = ReactArt.Surface,
Group = ReactArt.Group,
Text = ReactArt.Text,
Shape = ReactArt.Shape,
Bar = require('paths-js/bar'),
Path = require('paths-js/path');
</code></pre>

<p>var viewportWidth = function() {</p>

<pre><code>return  window.innerWidth - 100;
</code></pre>

<p>}
var viewportHeight = function() {</p>

<pre><code>return window.innerHeight - 100;
</code></pre>

<p>}</p>

<p>var data = [</p>

<pre><code>[
  { name: 'Italy', population: 59859996 },
  { name: 'Spain', population: 46704314 },
  { name: 'France', population: 65806000 },
  { name: 'Romania', population: 20121641 },
  { name: 'Greece', population: 10815197 }
],
[
  { name: 'Zambia', population: 14580290 },
  { name: 'Cameroon', population: 20386799 },
  { name: 'Nigeria', population: 173615000 },
  { name: 'Ethiopia', population: 86613986 },
  { name: 'Ghana', population: 24658823 }
]
</code></pre>

<p>  ];</p>

<p>var colorPallete = [&ldquo;#FEE871&rdquo;, &ldquo;#E5FAAF&rdquo;, &ldquo;#B7E5F5&rdquo;];</p>

<p>var Demo = React.createClass({</p>

<pre><code>getInitialState: function() {
    return {
        width: viewportWidth(),
        height: viewportHeight()
    }
},
componentDidMount: function() {
    window.addEventListener('resize', this.refresh, false); //This should be debounced
},
componentWillUnmount: function() {
    window.removeEventListener('resize', this.refresh, false);
},
refresh: function() {
    this.setState({
        width: viewportWidth(),
        height: viewportHeight()
    });
},
getBar: function() {

    var bar = Bar({
      data: data,
      accessor: function(x) { return x.population; }, // Value to use
      compute: {
        color: function(i) { return colorPallete[i]; } //Color of the bar
      },
      width: this.state.width, //Set it to our surface width so it is responsive when our surface width changes
      height: this.state.height, //Set it to our surface height so it's repsponsive
      gutter: 10
    });

    return bar;
},
handleMouseMove: function(item, e) {
    this.setState({
        hoveredItem: item,
        hoveredY: e.y,
        hoveredX: e.x
    });
},
getBarChart: function(bar) {
    return bar.curves.map(function(bar) {

        var points = bar.line.path.points(),
            right = points[0][0],
            top = points[0][1],
            left = points[2][0],
            bottom = points[2][1],
            width = right - left,
            height = bottom - top;

        return (
            &lt;Group 
              onMouseMove={this.handleMouseMove.bind(this, bar.item)}
            &gt;
              &lt;Shape d={bar.line.path.print()} fill={bar.color}/&gt;

              &lt;Group x={left} y={top}&gt;
                &lt;Text x={width/2} y={height - 24} alignment="middle" fill="#000" font='bold 10px "Arial"'&gt;{bar.item.name}&lt;/Text&gt;
                &lt;Text x={width/2} y={height - 12} alignment="middle" fill="#000" font='bold 10px "Arial"'&gt;{bar.item.population +''}&lt;/Text&gt;
              &lt;/Group&gt;
            &lt;/Group&gt;
        )
    }, this)
},
getXAxis: function(bar) {
    var path = Path().moveto(0, this.state.height).lineto(this.state.width, this.state.height);
    return (
        &lt;Shape d={path.print()} strokeWidth={1} stroke="#000" /&gt;
    );   
},
getYAxis: function(bar) {
    var path = Path().moveto(0,0).lineto(0, this.state.height);
    return (
        &lt;Shape d={path.print()} strokeWidth={1} stroke="#000" /&gt;
    ); 
},
getHoveredData: function() {
    if (!this.state.hoveredItem) {
        return null;
    }
    return (
            &lt;div style=&gt;
                &lt;h2&gt;{this.state.hoveredItem.name}&lt;/h2&gt;
                &lt;h5&gt;{this.state.hoveredItem.population}&lt;/h5&gt;
            &lt;/div&gt;
        )
},
render: function() {
    var bar = this.getBar();

    return (
        &lt;div style= style=&gt;
            &lt;Surface
                width={this.state.width}
                height={this.state.height}
            &gt;
                &lt;Group&gt;
                    {this.getBarChart(bar)} 
                &lt;/Group&gt;
                &lt;Group&gt;
                    {this.getXAxis(bar)}
                    {this.getYAxis(bar)}
                &lt;/Group&gt;
            &lt;/Surface&gt;
            {this.getHoveredData()}

        &lt;/div&gt;
    );
}
</code></pre>

<p>});</p>

<p>module.exports = Demo;
```</p>

<h3>Results</h3>

<p data-height="624" data-theme-id="0" data-slug-hash="LVxjPw" data-default-tab="result" data-user="browniefed" class='codepen'>See the Pen <a href='http://codepen.io/browniefed/pen/LVxjPw/'>LVxjPw</a> by Jason Brown (<a href='http://codepen.io/browniefed'>@browniefed</a>) on <a href='http://codepen.io'>CodePen</a>.</p>


<script async src="http://browniefed.com//assets.codepen.io/assets/embed/ei.js"></script>


<h3>Conclusion</h3>

<p>Once again <a href="https://github.com/andreaferretti/paths-js">Paths.js</a> comes in handy for generating arbitrary path information, and providing access to a lot of valuable data to making laying out your graphs with <code>react-art</code> a breeze.</p>

<p>Some homework for you is to add some vertical labels at each particular step.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Art and Paths.js]]></title>
    <link href="http://browniefed.com/blog/2015/05/27/react-art-and-paths-dot-js/"/>
    <updated>2015-05-27T19:32:00-07:00</updated>
    <id>http://browniefed.com/blog/2015/05/27/react-art-and-paths-dot-js</id>
    <content type="html"><![CDATA[<h3>Intro</h3>

<p><a href="https://github.com/andreaferretti/paths-js">Paths.js</a> is a cool library. It comes with 3 levels of generating paths.</p>

<ul>
<li>Low level which helps you generate paths/lines.</li>
<li>Mid level which generates paths for shapes</li>
<li>High level which takes a set of data and generates graphs</li>
</ul>


<p>All of these are great when working with <code>react-art</code> because it&rsquo;s just returning data. I&rsquo;ll say it once, and a million more but libraries that just generate data make it easy to traverse and render with <code>react-art</code>.</p>

<h3>Paths</h3>

<p>Example:</p>

<p><code>
var path = Path()
  .moveto(10, 20)
  .lineto(30, 50)
  .lineto(25, 28)
  .qcurveto(27, 30, 32, 27)
  .closepath();
</code></p>

<p>This is can just be plugged right into <code>react-art</code> <code>Shape</code> element.</p>

<p>Like so</p>

<p>```
var React = require(&lsquo;react&rsquo;),</p>

<pre><code>ReactArt = require('react-art'),
Surface = ReactArt.Surface,
Shape = ReactArt.Shape,
Path = require('paths-js/path');
</code></pre>

<p>var Demo = React.createClass({</p>

<pre><code>getInitialState: function() {
    return {
        to: {
            x: 30,
            y: 50
        }
    }
},
getPath: function() {
    var path = Path()
                  .moveto(10, 20)
                  .lineto(this.state.to.x, this.state.to.y)
                  .lineto(25, 28)
                  .qcurveto(27, 30, 32, 27)
                  .closepath();

    return path.print();
},
startAnimating: function() {

    if (this.state.to.x === 100) {
        this.addToPosition = -1;
    } else if (this.state.to.x === 29) {
        this.addToPosition = 1;
    }

    this.state.to.x += this.addToPosition;
    this.state.to.y += this.addToPosition;

    this.setState(this.state);
},
componentDidMount: function() {
    this.addToPosition = 1;
    setInterval(this.startAnimating, 17)
},
render: function() {
    return (
        &lt;div&gt;
            &lt;Surface
                width={500}
                height={500}
            &gt;
                &lt;Shape d={this.getPath()} stroke="#000" strokeWidth={1} /&gt;
            &lt;/Surface&gt;
        &lt;/div&gt;
    )
}
</code></pre>

<p>});</p>

<p>module.exports = Demo;
```</p>

<p data-height="624" data-theme-id="0" data-slug-hash="VLmOOE" data-default-tab="result" data-user="browniefed" class='codepen'>See the Pen <a href='http://codepen.io/browniefed/pen/VLmOOE/'>VLmOOE</a> by Jason Brown (<a href='http://codepen.io/browniefed'>@browniefed</a>) on <a href='http://codepen.io'>CodePen</a>.</p>


<script async src="http://browniefed.com//assets.codepen.io/assets/embed/ei.js"></script>


<h3>Simple Shapes</h3>

<p>Now <code>react-art</code> already comes with a few different shapes but <code>paths.js</code> have a few built in as well, like <code>Rectangle</code> and <code>Bezier</code> curve.</p>

<p><code>
var rectangle = Rectangle({
  top: 10,
  bottom: 3,
  left: -2,
  right: 5
});
</code></p>

<p>And how that looks is very similar to the previous example</p>

<p>```
var React = require(&lsquo;react&rsquo;),</p>

<pre><code>ReactArt = require('react-art'),
Surface = ReactArt.Surface,
Group = ReactArt.Group,
Shape = ReactArt.Shape,
Rectangle = require('paths-js/rectangle'),
Bezier = require('paths-js/bezier');
</code></pre>

<p>var Demo = React.createClass({</p>

<pre><code>getPath: function() {
    var rectangle = Rectangle({
                  top: 10,
                  bottom: 3,
                  left: -2,
                  right: 5
                });

    return rectangle.path.print();
},
getBez: function() {
    var points = [[1, 50], [50, 100], [100, 3], [4, 0]];
    var curve = Bezier({
      points: points,
      tension: 0.2
    });

    return curve.path.print();
},
render: function() {
    return (
        &lt;div&gt;
            &lt;Surface
                width={500}
                height={500}
            &gt;
                &lt;Group x={100} y={100}&gt;
                    &lt;Shape d={this.getPath()} stroke="#000" strokeWidth={1} /&gt;
                &lt;/Group&gt;
                &lt;Group x={200} y={200}&gt;
                    &lt;Shape d={this.getBez()} stroke="#000" strokeWidth={1} /&gt;
                &lt;/Group&gt;
            &lt;/Surface&gt;
        &lt;/div&gt;
    )
}
</code></pre>

<p>});</p>

<p>module.exports = Demo;
```</p>

<p data-height="624" data-theme-id="0" data-slug-hash="xGRNvW" data-default-tab="result" data-user="browniefed" class='codepen'>See the Pen <a href='http://codepen.io/browniefed/pen/xGRNvW/'>xGRNvW</a> by Jason Brown (<a href='http://codepen.io/browniefed'>@browniefed</a>) on <a href='http://codepen.io'>CodePen</a>.</p>


<script async src="http://browniefed.com//assets.codepen.io/assets/embed/ei.js"></script>


<h3>Graphs</h3>

<p>```
var pie = Pie({
  data: [</p>

<pre><code>{ name: 'Italy', population: 59859996 },
{ name: 'Mexico', population: 118395054 },
{ name: 'France', population: 65806000 },
{ name: 'Argentina', population: 40117096 },
{ name: 'Japan', population: 127290000 }
</code></pre>

<p>  ],
  accessor: function(x) { return x.population; },
  compute: {</p>

<pre><code>color: function(i) { return somePalette[i]; }
</code></pre>

<p>  },
  center: [20, 15],
  r: 30,
  R: 50
});
```</p>

<p>Some code of it in action</p>

<p>```
var React = require(&lsquo;react&rsquo;),</p>

<pre><code>ReactArt = require('react-art'),
Surface = ReactArt.Surface,
Group = ReactArt.Group,
Shape = ReactArt.Shape,
Pie = require('paths-js/Pie');
</code></pre>

<p>var pie = Pie({
  data: [</p>

<pre><code>{ name: 'Italy', population: 59859996 },
{ name: 'Mexico', population: 118395054 },
{ name: 'France', population: 65806000 },
{ name: 'Argentina', population: 40117096 },
{ name: 'Japan', population: 127290000 }
</code></pre>

<p>  ],
  accessor: function(x) { return x.population; },
  compute: {</p>

<pre><code>color: function(i) { return '#000'; }
</code></pre>

<p>  },
  center: [20, 15],
  r: 30,
  R: 50
});</p>

<p>var Demo = React.createClass({</p>

<pre><code>getPie: function() {
    return pie.curves.map(function(shape) {
        return (
            &lt;Group&gt;
                &lt;Text fill="#A6BD8A" font='bold 12px "Arial"' x={shape.sector.centroid[0] - 12} y={shape.sector.centroid[1]}&gt;{shape.item.name}&lt;/Text&gt;
                &lt;Shape d={shape.sector.path.print()} stroke={shape.color} strokeWidth={1} /&gt;
            &lt;/Group&gt;
        )
    })
},
render: function() {
    return (
        &lt;div&gt;
            &lt;Surface
                width={500}
                height={500}
            &gt;
                &lt;Group x={50} y={45}&gt;
                    {this.getPie()}
                &lt;/Group&gt;
            &lt;/Surface&gt;
        &lt;/div&gt;
    )
}
</code></pre>

<p>});</p>

<p>module.exports = Demo;
```</p>

<p data-height="624" data-theme-id="0" data-slug-hash="waoLvB" data-default-tab="result" data-user="browniefed" class='codepen'>See the Pen <a href='http://codepen.io/browniefed/pen/waoLvB/'>waoLvB</a> by Jason Brown (<a href='http://codepen.io/browniefed'>@browniefed</a>) on <a href='http://codepen.io'>CodePen</a>.</p>


<script async src="http://browniefed.com//assets.codepen.io/assets/embed/ei.js"></script>


<h3>Conclusion</h3>

<p>These examples may look boring but they just show off a bit of the control you can have with <code>react-art</code> and a simple path generator.
Not only that but because we aren&rsquo;t depending on the DOM in any case these examples should also work on <code>react-native</code>.
Combined with some tweening you could make some very effective graphs that animate. That is a topic for another time.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Animating with React Art and Shifty.js]]></title>
    <link href="http://browniefed.com/blog/2015/05/26/animating-with-react-art-and-shifty-dot-js/"/>
    <updated>2015-05-26T10:38:00-07:00</updated>
    <id>http://browniefed.com/blog/2015/05/26/animating-with-react-art-and-shifty-dot-js</id>
    <content type="html"><![CDATA[<p>Having little experience with D3 animations I&rsquo;m not sure if it is easy to do animations with D3.
However the great thing about <code>react</code> and <code>react-art</code> is that in order to animate you follow the same pattern you do for any other rendering, just <code>setState</code>.</p>

<p>Animations in CSS3 are different in that a particular element has a defined location and you tell the browser the new location. The inbetween animation state from point a => b over a period of time is automatically handled for you.</p>

<p>In our canvas/svg world we need to <code>tween</code> between states. That just means based on a defined time frame (500ms? 1s? 2s?) we need to move an item form <code>x/y</code> to a new <code>x/y</code>.</p>

<p><a href="https://github.com/jeremyckahn/shifty">Shifty.js</a> helps do that in an efficient manner on the web. The reason <code>shifty.js</code> works well with React is that it doesn&rsquo;t mutate DOM but just provides you the ability to modify numbers across a space of time. Additionally it provides out of the box easing effects like <code>elastic</code>, <code>bounce</code>, <code>linear</code>, <code>cubic</code> and other movements.</p>

<p>This article is less about <code>react-art</code> and more about just how to use <code>shifty.js</code> since <code>react-art</code> is just an extension of <code>react</code>, and if you know the fundamental concepts of <code>react</code> then you can do just about anything.</p>

<p>Example of a basic tween movement</p>

<p>```
var tweenable = new Shifty();</p>

<pre><code>    tweenable.tween({
      from:     { x: 50, y: 50},
      to:       { x: 200, y: 200 },
      duration: 1000,
      step: function (state) {
        this.setState({
            x: state.x,
            y: state.y
        })
      }.bind(this)
    });
</code></pre>

<p>```</p>

<p>We are saying move from <code>0,0</code> to <code>100,100</code> over <code>1000ms (1 second)</code>.</p>

<p><code>Shifty.js</code> will chunk each step from <code>0</code> to <code>100</code> over <code>1000ms</code> and provide us which each step.</p>

<p>Yes this looks very much like <code>jQuery</code> and it&rsquo;s animate function. They are essentially doing the same thing except <code>jQuery</code> modifies the DOM for you and we are just adjusting a number.</p>

<p>Shifty is just one that I happened to pull up, but there are many other tweening libraries that could be used easily.</p>

<p data-height="624" data-theme-id="0" data-slug-hash="bdByVz" data-default-tab="result" data-user="browniefed" class='codepen'>See the Pen <a href='http://codepen.io/browniefed/pen/bdByVz/'>bdByVz</a> by Jason Brown (<a href='http://codepen.io/browniefed'>@browniefed</a>) on <a href='http://codepen.io'>CodePen</a>.</p>


<script async src="http://browniefed.com//assets.codepen.io/assets/embed/ei.js"></script>


<p>That&rsquo;s the basics, in a later blog post I&rsquo;ll get into some more complex animations. However any tweening library/phsyics engine that is divorced from the DOM will allow you to maniuplate your data and make your <code>react-art</code> very versatile.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Art Zooming and Dragging]]></title>
    <link href="http://browniefed.com/blog/2015/05/20/react-art-zooming-and-dragging/"/>
    <updated>2015-05-20T15:32:00-07:00</updated>
    <id>http://browniefed.com/blog/2015/05/20/react-art-zooming-and-dragging</id>
    <content type="html"><![CDATA[<p>React-art is awesome, you can easily embody the same concepts in React and your visualizations magically work.</p>

<p>I personally have not done a ton of visualization, and the little I have done is mostly rendering graphs with D3.</p>

<p>I&rsquo;ve been tasked with doing a dive for a difficult visualization. We ran into a scenario where we needed the ability to zoom and drag the canvas. D3 conveniently comes with zoom/drag behaviors. D3 integrates pretty well with react-art for doing a lot of the math/generating paths, however after watching <a href="https://www.youtube.com/watch?v=2ii1lEkIv1s">React.js Conf &ndash; Scalable Data Visualization</a> the things immediatley called out that D3 doesn&rsquo;t integrate with react-art are transitions and behaviors (zoom/drag).</p>

<p>So immediately I&rsquo;m thinking about how to accomplish this. Do I need a global scaler that scales all of my coordinates for zooming? Do I need to manage a coordinate system and adjust all of my coordinates with the dragged X/Y offsets.</p>

<p>I googled around, and a few people recommended using <code>canvasEl.getContext('2d').translate(x,y)</code>. I gave this a try with refs, that didn&rsquo;t work.</p>

<p>It did lead me down the right path though. What if I was able to just utilize one global wrapper, and all of my other code could remain unchanged. The great thing about <code>Group</code> is that the coordinate system of the children gets reset, so <code>0,0</code> is now the <code>x,y</code> of the <code>Group</code></p>

<p>Example:
```
<Group x={100} y={100}></p>

<pre><code>&lt;Circle radius={10} stroke="#000" strokeWidth={3} x={20} y={20}/&gt;
</code></pre>

<p></Group>
```</p>

<p>The coordinates of the circle on the whole canvas would actually be <code>120,120</code> but because of the group at <code>x = 100, y = 100</code> we just need to say <code>x = 20, y = 20</code>.</p>

<p>Now that we know that our parent coordinate system effects our child coordinate systems lets prove our final theory that we can have one master parent to control zoom/drag.</p>

<p>Lets start with a base renderer</p>

<p>```
//Assuming React, and react-art are included
var ZoomDragCircle = React.createClass({</p>

<pre><code>render: function() {
    return (
        &lt;Surface
            width={viewportWidth}
            height={viewportHeight}
        &gt;
        &lt;/Surface&gt; 
    );
}
</code></pre>

<p>})</p>

<p>```</p>

<p>We have a surface so the next lets get something rendering</p>

<p>```
var ZoomDragCircle = React.createClass({</p>

<pre><code>render: function() {
    return (
        &lt;Surface
            width={viewportWidth}
            height={viewportHeight}
        &gt;
            &lt;Circle x={10} y={10} radius={5} fill="#000" /&gt;
        &lt;/Surface&gt; 
    );
}
</code></pre>

<p>})</p>

<p>```</p>

<p>Lets add in our drag concept.</p>

<p>```
var ZoomDragCircle = React.createClass({</p>

<pre><code>getInitialState: function() {
    return {
        x: 0,
        y: 0
    }
},
handleMouseDown: function() {
    this.dragging = true;
},
handleMouseUp: function() {
    this.dragging = false;
},
render: function() {
    return (
        &lt;div 
                onMouseDown={this.handleMouseDown}
                onMouseUp={this.handleMouseUp}
        &gt;
            &lt;Surface
                width={viewportWidth}
                height={viewportHeight}

            &gt;
                &lt;Group x={this.state.x} y={this.state.y}&gt;
                    &lt;Circle x={10} y={10} radius={5} fill="#000" /&gt;
                &lt;/Group&gt;
            &lt;/Surface&gt; 
        &lt;/div&gt;
    );
}
</code></pre>

<p>})</p>

<p>```</p>

<p>One thing you&rsquo;ll notice here is the wrapping div. The <code>react-art</code> <code>Surface</code> element doesn&rsquo;t have the <code>EventMixin</code> so it will not register mouse events. We could wrap our <code>Group</code> with another <code>Group</code> for dragging/zoom however an outer <code>div</code> is much easier for now.</p>

<p>You also may notice that we have a slight issue. <code>onMouseUp</code> should be globally on the <code>document</code> since the <code>mouseup</code> event will only be fired if the <code>mouseup</code> happens on our wrapping div. For simplicity sake we&rsquo;ll keep it on the div.</p>

<p>So we have a way to toggle whether we are dragging or not, and have the ability to adjust the <code>x,y</code> coords of a parent group. Lets actually implement drag.</p>

<p>```
var ZoomDragCircle = React.createClass({</p>

<pre><code>getInitialState: function() {
    return {
        x: 0,
        y: 0
    }
},
componentDidMount: function() {
    document.addEventListener('mousemove', this.handleMouseMove, false);
},
componentWillUnmount: function() {
    //Don't forget to unlisten!
    document.removeEventListener('mousemove', this.handleMouseMove, false);
},
handleMouseDown: function(e) {
    this.dragging = true;
    //Set coords
      this.coords = {
        x: e.pageX,
        y: e.pageY
      }
},
handleMouseUp: function() {
    this.dragging = false;
    this.coords = {};
},
handleMouseMove: function(e) {
//If we are dragging
  if (this.dragging) {
      e.preventDefault();

    //Get mouse change differential
    var xDiff = this.coords.x - e.pageX,
        yDiff = this.coords.y - e.pageY;

    //Update to our new coordinates
        this.coords.x = e.pageX;
        this.coords.y = e.pageY;
    //Adjust our x,y based upon the x/y diff from before
    var x = this.state.x - xDiff,       
        y = this.state.y - yDiff;

    //Re-render
    this.setState(this.state);  
  }

},
render: function() {
    return (
        &lt;div 
                onMouseDown={this.handleMouseDown}
                onMouseUp={this.handleMouseUp}
        &gt;
            &lt;Surface
                width={viewportWidth}
                height={viewportHeight}

            &gt;
                &lt;Group x={this.state.x} y={this.state.y}&gt;
                    &lt;Circle x={10} y={10} radius={5} fill="#000" /&gt;
                &lt;/Group&gt;
            &lt;/Surface&gt; 
        &lt;/div&gt;
    );
}
</code></pre>

<p>})</p>

<p>```</p>

<p>Now if you spin this up you&rsquo;ll see we can drag around the canvas and our <code>Circle</code> will stay the same place.
Lets do zoom now.</p>

<p>To understand what we&rsquo;re about to do the Art library will translate our <code>x,y</code> coords to a <code>matrix</code> that is set on the <code>transform</code> attribute of the svg <code>g</code> element or in the canvas case translated to the appropriate coordinates.</p>

<p>The <code>matrix</code> system can be read about here on <a href="https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix">MDN</a>. Ultimately it allows us to modify the coordinate system (<code>x,y</code>) and additionally the scale.</p>

<p>Think of scale as a default multiplier times the size of stuff.</p>

<p>So a scale of <code>1</code> means if something is a width of <code>10</code> then it would still be 10.
But If we set our scale to <code>2</code> and the same width of <code>10</code> then <code>10*2 = 20</code>. The item would appear larger at 20 pixels.</p>

<p>This is the rough idea behind scale, however we aren&rsquo;t adjusting widths the scale is actually effecting the <code>x,y</code> coordinates you are setting. You can define <code>scaleX</code> and <code>scaleY</code> to be different numbers causing your visual elements to appear blurred/skewed.</p>

<p>```
var ZoomDragCircle = React.createClass({</p>

<pre><code>getInitialState: function() {
    return {
        x: 0,
        y: 0,
        scale: 1
    }
},
componentDidMount: function() {
    document.addEventListener('mousemove', this.handleMouseMove, false);
},
componentWillUnmount: function() {
    //Don't forget to unlisten!
    document.removeEventListener('mousemove', this.handleMouseMove, false);
},
handleMouseDown: function(e) {
    this.dragging = true;
    //Set coords
      this.coords = {
        x: e.pageX,
        y: e.pageY
      }
},
handleMouseUp: function() {
    this.dragging = false;
    this.coords = {};
},
handleMouseMove: function(e) {
//If we are dragging
  if (!this.dragging) {
    return;
  }
      e.preventDefault();

    //Get mouse change differential
    var xDiff = this.coords.x - e.pageX,
        yDiff = this.coords.y - e.pageY;

    //Update to our new coordinates
        this.coords.x = e.pageX;
        this.coords.y = e.pageY;
    //Adjust our x,y based upon the x/y diff from before
    var x = this.state.x - xDiff,       
        y = this.state.y - yDiff;

    //Re-render
    this.setState(this.state);  

},
//So we can handle the mousewheel returning -0 or 0
isNegative: function (n) {
  return ((n = +n) || 1 / n) &lt; 0;
},
handleMouseWheel: function(e) {
  var ZOOM_STEP = .03;

    //require the shift key to be pressed to scroll
    if (!e.shiftKey) {
        return;
    }
  e.preventDefault();
  var direction = (this.isNegative(e.deltaX) &amp;&amp;  this.isNegative(e.deltaY) ) ? 'down' : 'up';

  if (direction == 'up') {
    this.state.scale += ZOOM_STEP;
  } else {
    this.state.scale -= ZOOM_STEP;
  }

  this.state.scale = this.state.scale &lt; 0 ? 0 : this.state.scale;

  this.setState(this.state);
},
render: function() {
    return (
        &lt;div 
            onMouseDown={this.handleMouseDown}
            onMouseUp={this.handleMouseUp}
            onWheel={this.handleMouseWheel}
        &gt;
            &lt;Surface
                width={viewportWidth}
                height={viewportHeight}

            &gt;
                &lt;Group 
                    x={this.state.x} 
                    y={this.state.y}
                    scaleX={this.state.scale}
                    scaleY={this.state.scale}
                &gt;
                    &lt;Circle x={10} y={10} radius={5} fill="#000" /&gt;
                &lt;/Group&gt;
            &lt;/Surface&gt; 
        &lt;/div&gt;
    );
}
</code></pre>

<p>})</p>

<p>```</p>

<p>Full working demo, hold shift and use your mouse wheel/track pad to zoom or just grab and drag around.</p>

<p data-height="624" data-theme-id="0" data-slug-hash="jPMMao" data-default-tab="result" data-user="browniefed" class='codepen'>See the Pen <a href='http://codepen.io/browniefed/pen/jPMMao/'>jPMMao</a> by Jason Brown (<a href='http://codepen.io/browniefed'>@browniefed</a>) on <a href='http://codepen.io'>CodePen</a>.</p>


<script async src="http://browniefed.com//assets.codepen.io/assets/embed/ei.js"></script>


<p>Now we should be able to zoom in/zoom out while holding shift key + using your scroll wheel.
If you want a predictable scale you can add some <code>+</code> and <code>-</code> buttons somwhere and just increment <code>this.state.scale</code></p>

<p>I&rsquo;m hoping to do more write ups and examples with react-art. The great thing is that you can render react-art with react-native. With appropriate abstractions you could possibly have the same visualizations on the web as you do on native.</p>
]]></content>
  </entry>
  
</feed>
