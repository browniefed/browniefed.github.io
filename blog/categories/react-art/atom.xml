<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: react-art | JavaScript Without Grammar]]></title>
  <link href="http://browniefed.com/blog/categories/react-art/atom.xml" rel="self"/>
  <link href="http://browniefed.com/"/>
  <updated>2015-05-27T17:20:40-07:00</updated>
  <id>http://browniefed.com/</id>
  <author>
    <name><![CDATA[Jason Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Animating with React Art and Shifty.js]]></title>
    <link href="http://browniefed.com/blog/2015/05/26/animating-with-react-art-and-shifty-dot-js/"/>
    <updated>2015-05-26T10:38:00-07:00</updated>
    <id>http://browniefed.com/blog/2015/05/26/animating-with-react-art-and-shifty-dot-js</id>
    <content type="html"><![CDATA[<p>Having little experience with D3 animations I&rsquo;m not sure if it is easy to do animations with D3.
However the great thing about <code>react</code> and <code>react-art</code> is that in order to animate you follow the same pattern you do for any other rendering, just <code>setState</code>.</p>

<p>Animations in CSS3 are different in that a particular element has a defined location and you tell the browser the new location. The inbetween animation state from point a => b over a period of time is automatically handled for you.</p>

<p>In our canvas/svg world we need to <code>tween</code> between states. That just means based on a defined time frame (500ms? 1s? 2s?) we need to move an item form <code>x/y</code> to a new <code>x/y</code>.</p>

<p><a href="https://github.com/jeremyckahn/shifty">Shifty.js</a> helps do that in an efficient manner on the web. The reason <code>shifty.js</code> works well with React is that it doesn&rsquo;t mutate DOM but just provides you the ability to modify numbers across a space of time. Additionally it provides out of the box easing effects like <code>elastic</code>, <code>bounce</code>, <code>linear</code>, <code>cubic</code> and other movements.</p>

<p>This article is less about <code>react-art</code> and more about just how to use <code>shifty.js</code> since <code>react-art</code> is just an extension of <code>react</code>, and if you know the fundamental concepts of <code>react</code> then you can do just about anything.</p>

<p>Example of a basic tween movement</p>

<p>```
var tweenable = new Shifty();</p>

<pre><code>    tweenable.tween({
      from:     { x: 50, y: 50},
      to:       { x: 200, y: 200 },
      duration: 1000,
      step: function (state) {
        this.setState({
            x: state.x,
            y: state.y
        })
      }.bind(this)
    });
</code></pre>

<p>```</p>

<p>We are saying move from <code>0,0</code> to <code>100,100</code> over <code>1000ms (1 second)</code>.</p>

<p><code>Shifty.js</code> will chunk each step from <code>0</code> to <code>100</code> over <code>1000ms</code> and provide us which each step.</p>

<p>Yes this looks very much like <code>jQuery</code> and it&rsquo;s animate function. They are essentially doing the same thing except <code>jQuery</code> modifies the DOM for you and we are just adjusting a number.</p>

<p>Shifty is just one that I happened to pull up, but there are many other tweening libraries that could be used easily.</p>

<p data-height="624" data-theme-id="0" data-slug-hash="bdByVz" data-default-tab="result" data-user="browniefed" class='codepen'>See the Pen <a href='http://codepen.io/browniefed/pen/bdByVz/'>bdByVz</a> by Jason Brown (<a href='http://codepen.io/browniefed'>@browniefed</a>) on <a href='http://codepen.io'>CodePen</a>.</p>


<script async src="http://browniefed.com//assets.codepen.io/assets/embed/ei.js"></script>


<p>That&rsquo;s the basics, in a later blog post I&rsquo;ll get into some more complex animations. However any tweening library/phsyics engine that is divorced from the DOM will allow you to maniuplate your data and make your <code>react-art</code> very versatile.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Art Zooming and Dragging]]></title>
    <link href="http://browniefed.com/blog/2015/05/20/react-art-zooming-and-dragging/"/>
    <updated>2015-05-20T15:32:00-07:00</updated>
    <id>http://browniefed.com/blog/2015/05/20/react-art-zooming-and-dragging</id>
    <content type="html"><![CDATA[<p>React-art is awesome, you can easily embody the same concepts in React and your visualizations magically work.</p>

<p>I personally have not done a ton of visualization, and the little I have done is mostly rendering graphs with D3.</p>

<p>I&rsquo;ve been tasked with doing a dive for a difficult visualization. We ran into a scenario where we needed the ability to zoom and drag the canvas. D3 conveniently comes with zoom/drag behaviors. D3 integrates pretty well with react-art for doing a lot of the math/generating paths, however after watching <a href="https://www.youtube.com/watch?v=2ii1lEkIv1s">React.js Conf &ndash; Scalable Data Visualization</a> the things immediatley called out that D3 doesn&rsquo;t integrate with react-art are transitions and behaviors (zoom/drag).</p>

<p>So immediately I&rsquo;m thinking about how to accomplish this. Do I need a global scaler that scales all of my coordinates for zooming? Do I need to manage a coordinate system and adjust all of my coordinates with the dragged X/Y offsets.</p>

<p>I googled around, and a few people recommended using <code>canvasEl.getContext('2d').translate(x,y)</code>. I gave this a try with refs, that didn&rsquo;t work.</p>

<p>It did lead me down the right path though. What if I was able to just utilize one global wrapper, and all of my other code could remain unchanged. The great thing about <code>Group</code> is that the coordinate system of the children gets reset, so <code>0,0</code> is now the <code>x,y</code> of the <code>Group</code></p>

<p>Example:
```
<Group x={100} y={100}></p>

<pre><code>&lt;Circle radius={10} stroke="#000" strokeWidth={3} x={20} y={20}/&gt;
</code></pre>

<p></Group>
```</p>

<p>The coordinates of the circle on the whole canvas would actually be <code>120,120</code> but because of the group at <code>x = 100, y = 100</code> we just need to say <code>x = 20, y = 20</code>.</p>

<p>Now that we know that our parent coordinate system effects our child coordinate systems lets prove our final theory that we can have one master parent to control zoom/drag.</p>

<p>Lets start with a base renderer</p>

<p>```
//Assuming React, and react-art are included
var ZoomDragCircle = React.createClass({</p>

<pre><code>render: function() {
    return (
        &lt;Surface
            width={viewportWidth}
            height={viewportHeight}
        &gt;
        &lt;/Surface&gt; 
    );
}
</code></pre>

<p>})</p>

<p>```</p>

<p>We have a surface so the next lets get something rendering</p>

<p>```
var ZoomDragCircle = React.createClass({</p>

<pre><code>render: function() {
    return (
        &lt;Surface
            width={viewportWidth}
            height={viewportHeight}
        &gt;
            &lt;Circle x={10} y={10} radius={5} fill="#000" /&gt;
        &lt;/Surface&gt; 
    );
}
</code></pre>

<p>})</p>

<p>```</p>

<p>Lets add in our drag concept.</p>

<p>```
var ZoomDragCircle = React.createClass({</p>

<pre><code>getInitialState: function() {
    return {
        x: 0,
        y: 0
    }
},
handleMouseDown: function() {
    this.dragging = true;
},
handleMouseUp: function() {
    this.dragging = false;
},
render: function() {
    return (
        &lt;div 
                onMouseDown={this.handleMouseDown}
                onMouseUp={this.handleMouseUp}
        &gt;
            &lt;Surface
                width={viewportWidth}
                height={viewportHeight}

            &gt;
                &lt;Group x={this.state.x} y={this.state.y}&gt;
                    &lt;Circle x={10} y={10} radius={5} fill="#000" /&gt;
                &lt;/Group&gt;
            &lt;/Surface&gt; 
        &lt;/div&gt;
    );
}
</code></pre>

<p>})</p>

<p>```</p>

<p>One thing you&rsquo;ll notice here is the wrapping div. The <code>react-art</code> <code>Surface</code> element doesn&rsquo;t have the <code>EventMixin</code> so it will not register mouse events. We could wrap our <code>Group</code> with another <code>Group</code> for dragging/zoom however an outer <code>div</code> is much easier for now.</p>

<p>You also may notice that we have a slight issue. <code>onMouseUp</code> should be globally on the <code>document</code> since the <code>mouseup</code> event will only be fired if the <code>mouseup</code> happens on our wrapping div. For simplicity sake we&rsquo;ll keep it on the div.</p>

<p>So we have a way to toggle whether we are dragging or not, and have the ability to adjust the <code>x,y</code> coords of a parent group. Lets actually implement drag.</p>

<p>```
var ZoomDragCircle = React.createClass({</p>

<pre><code>getInitialState: function() {
    return {
        x: 0,
        y: 0
    }
},
componentDidMount: function() {
    document.addEventListener('mousemove', this.handleMouseMove, false);
},
componentWillUnmount: function() {
    //Don't forget to unlisten!
    document.removeEventListener('mousemove', this.handleMouseMove, false);
},
handleMouseDown: function(e) {
    this.dragging = true;
    //Set coords
      this.coords = {
        x: e.pageX,
        y: e.pageY
      }
},
handleMouseUp: function() {
    this.dragging = false;
    this.coords = {};
},
handleMouseMove: function(e) {
//If we are dragging
  if (this.dragging) {
      e.preventDefault();

    //Get mouse change differential
    var xDiff = this.coords.x - e.pageX,
        yDiff = this.coords.y - e.pageY;

    //Update to our new coordinates
        this.coords.x = e.pageX;
        this.coords.y = e.pageY;
    //Adjust our x,y based upon the x/y diff from before
    var x = this.state.x - xDiff,       
        y = this.state.y - yDiff;

    //Re-render
    this.setState(this.state);  
  }

},
render: function() {
    return (
        &lt;div 
                onMouseDown={this.handleMouseDown}
                onMouseUp={this.handleMouseUp}
        &gt;
            &lt;Surface
                width={viewportWidth}
                height={viewportHeight}

            &gt;
                &lt;Group x={this.state.x} y={this.state.y}&gt;
                    &lt;Circle x={10} y={10} radius={5} fill="#000" /&gt;
                &lt;/Group&gt;
            &lt;/Surface&gt; 
        &lt;/div&gt;
    );
}
</code></pre>

<p>})</p>

<p>```</p>

<p>Now if you spin this up you&rsquo;ll see we can drag around the canvas and our <code>Circle</code> will stay the same place.
Lets do zoom now.</p>

<p>To understand what we&rsquo;re about to do the Art library will translate our <code>x,y</code> coords to a <code>matrix</code> that is set on the <code>transform</code> attribute of the svg <code>g</code> element or in the canvas case translated to the appropriate coordinates.</p>

<p>The <code>matrix</code> system can be read about here on <a href="https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix">MDN</a>. Ultimately it allows us to modify the coordinate system (<code>x,y</code>) and additionally the scale.</p>

<p>Think of scale as a default multiplier times the size of stuff.</p>

<p>So a scale of <code>1</code> means if something is a width of <code>10</code> then it would still be 10.
But If we set our scale to <code>2</code> and the same width of <code>10</code> then <code>10*2 = 20</code>. The item would appear larger at 20 pixels.</p>

<p>This is the rough idea behind scale, however we aren&rsquo;t adjusting widths the scale is actually effecting the <code>x,y</code> coordinates you are setting. You can define <code>scaleX</code> and <code>scaleY</code> to be different numbers causing your visual elements to appear blurred/skewed.</p>

<p>```
var ZoomDragCircle = React.createClass({</p>

<pre><code>getInitialState: function() {
    return {
        x: 0,
        y: 0,
        scale: 1
    }
},
componentDidMount: function() {
    document.addEventListener('mousemove', this.handleMouseMove, false);
},
componentWillUnmount: function() {
    //Don't forget to unlisten!
    document.removeEventListener('mousemove', this.handleMouseMove, false);
},
handleMouseDown: function(e) {
    this.dragging = true;
    //Set coords
      this.coords = {
        x: e.pageX,
        y: e.pageY
      }
},
handleMouseUp: function() {
    this.dragging = false;
    this.coords = {};
},
handleMouseMove: function(e) {
//If we are dragging
  if (!this.dragging) {
    return;
  }
      e.preventDefault();

    //Get mouse change differential
    var xDiff = this.coords.x - e.pageX,
        yDiff = this.coords.y - e.pageY;

    //Update to our new coordinates
        this.coords.x = e.pageX;
        this.coords.y = e.pageY;
    //Adjust our x,y based upon the x/y diff from before
    var x = this.state.x - xDiff,       
        y = this.state.y - yDiff;

    //Re-render
    this.setState(this.state);  

},
//So we can handle the mousewheel returning -0 or 0
isNegative: function (n) {
  return ((n = +n) || 1 / n) &lt; 0;
},
handleMouseWheel: function(e) {
  var ZOOM_STEP = .03;

    //require the shift key to be pressed to scroll
    if (!e.shiftKey) {
        return;
    }
  e.preventDefault();
  var direction = (this.isNegative(e.deltaX) &amp;&amp;  this.isNegative(e.deltaY) ) ? 'down' : 'up';

  if (direction == 'up') {
    this.state.scale += ZOOM_STEP;
  } else {
    this.state.scale -= ZOOM_STEP;
  }

  this.state.scale = this.state.scale &lt; 0 ? 0 : this.state.scale;

  this.setState(this.state);
},
render: function() {
    return (
        &lt;div 
            onMouseDown={this.handleMouseDown}
            onMouseUp={this.handleMouseUp}
            onWheel={this.handleMouseWheel}
        &gt;
            &lt;Surface
                width={viewportWidth}
                height={viewportHeight}

            &gt;
                &lt;Group 
                    x={this.state.x} 
                    y={this.state.y}
                    scaleX={this.state.scale}
                    scaleY={this.state.scale}
                &gt;
                    &lt;Circle x={10} y={10} radius={5} fill="#000" /&gt;
                &lt;/Group&gt;
            &lt;/Surface&gt; 
        &lt;/div&gt;
    );
}
</code></pre>

<p>})</p>

<p>```</p>

<p>Full working demo, hold shift and use your mouse wheel/track pad to zoom or just grab and drag around.</p>

<p data-height="624" data-theme-id="0" data-slug-hash="jPMMao" data-default-tab="result" data-user="browniefed" class='codepen'>See the Pen <a href='http://codepen.io/browniefed/pen/jPMMao/'>jPMMao</a> by Jason Brown (<a href='http://codepen.io/browniefed'>@browniefed</a>) on <a href='http://codepen.io'>CodePen</a>.</p>


<script async src="http://browniefed.com//assets.codepen.io/assets/embed/ei.js"></script>


<p>Now we should be able to zoom in/zoom out while holding shift key + using your scroll wheel.
If you want a predictable scale you can add some <code>+</code> and <code>-</code> buttons somwhere and just increment <code>this.state.scale</code></p>

<p>I&rsquo;m hoping to do more write ups and examples with react-art. The great thing is that you can render react-art with react-native. With appropriate abstractions you could possibly have the same visualizations on the web as you do on native.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting react-art running on react-native]]></title>
    <link href="http://browniefed.com/blog/2015/05/03/getting-react-art-running-on-react-native/"/>
    <updated>2015-05-03T20:33:00-07:00</updated>
    <id>http://browniefed.com/blog/2015/05/03/getting-react-art-running-on-react-native</id>
    <content type="html"><![CDATA[<p>I hadn&rsquo;t realized that the react-art native rendering stuff had landed in into the react-native core.
So I figured I&rsquo;d try and get in running. I am an XCode noob so I&rsquo;ll be sure and be descriptive.</p>

<p>First off lets set up a react-native project. (Assuming you have react-native cli installed);</p>

<p><code>react-native init react_art_demo</code></p>

<p>The current released version of <code>react-native</code> doesn&rsquo;t have the ART libs in it so in our <code>node_modules</code> folder we can delete the <code>react-native</code> in there and do a git clone of master <code>git clone https://github.com/facebook/react-native.git</code></p>

<p>We will also need the <code>art</code> lib itself installed. So <code>cd</code> to the root of <code>react_art_demo</code>.
Then run <code>npm install art</code></p>

<p>Once we have the master repo of <code>react-native</code>, and <code>art</code> installed we can open up our <code>react_art_demo</code> project in XCode.</p>

<p>We will need to do 2 things.</p>

<ul>
<li>Add the <code>ART.xcodeproj</code> to XCode</li>
<li>Link the binary</li>
</ul>


<p>To add ART.xcodeproj find the file located in <code>react-native/Libraries/ART/ART.xcodeproj</code> and just drag it over to the <code>Libraries</code> section in XCode.
That should look like so</p>

<p><img class="<a" src="href="http://i.imgur.com/TWeDUTa.png">http://i.imgur.com/TWeDUTa.png</a>" title="Add ART.xcodeproj to Libraries" ></p>

<p>Next we&rsquo;ll link the binary.</p>

<p>With the root <code>react_art_demo</code> project selected on the left, select <code>Build Phases</code> from the center view.
There will be a section called &ldquo;Link Binary With Libraries&rdquo;, expand it, press the + and select <code>libART.a</code></p>

<p>Like so</p>

<p><img class="<a" src="href="http://i.imgur.com/lIMZkfh.png">http://i.imgur.com/lIMZkfh.png</a>" title="Link binary" ></p>

<p>Just as a warning, I didn&rsquo;t link the binary and got a few &ldquo;No manager class found for view with module name&rdquo; errors.</p>

<p>Now go forth and write your <code>react-art</code>. I always like to get the <code>vector-widget</code> example running so to do that here is the code.</p>

<p><code>index.ios.js</code></p>

<p>```
/<em>*
 * Sample React Native App
 * <a href="https://github.com/facebook/react-native">https://github.com/facebook/react-native</a>
 </em>/
&lsquo;use strict&rsquo;;</p>

<p>var React = require(&lsquo;react-native&rsquo;);
var {
  AppRegistry,
  StyleSheet,
  Text,
  View,
} = React;</p>

<p>var VectorWidget = require(&lsquo;./VectorWidget&rsquo;);</p>

<p>var react_art_demo = React.createClass({</p>

<p>  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
    &lt;VectorWidget style={styles.vector}/&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
});</p>

<p>var styles = StyleSheet.create({
  container: {</p>

<pre><code>flex: 1,
alignItems: 'center',
backgroundColor: '#FFF',
</code></pre>

<p>  },
  vector: {</p>

<pre><code>width: 100,
height: 100
</code></pre>

<p>  },
  welcome: {</p>

<pre><code>fontSize: 20,
textAlign: 'center',
margin: 10,
</code></pre>

<p>  },
  instructions: {</p>

<pre><code>color: '#333333',
marginBottom: 5,
marginTop: 100
</code></pre>

<p>  },
});</p>

<p>AppRegistry.registerComponent(&lsquo;react_art_demo&rsquo;, () => react_art_demo);
```</p>

<p>And your <code>VectorWidget.js</code> file</p>

<p>```
/<em>*
 * Copyright 2013 Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 </em>/
&ldquo;use strict&rdquo;;</p>

<p>var React = require(&lsquo;react-native&rsquo;);
var ReactArt = require(&lsquo;./node_modules/react-native/Libraries/ART/ReactIOSART&rsquo;);
var {</p>

<pre><code>Art,
TouchableWithoutFeedback
</code></pre>

<p>} = React;</p>

<p>var {</p>

<pre><code>Group,
Shape,
Surface,
Transform
</code></pre>

<p>} = ReactArt;</p>

<p>var MOUSE_UP_DRAG = 0.978;
var MOUSE_DOWN_DRAG = 0.9;
var MAX_VEL = 11;
var CLICK_ACCEL = 3;
var BASE_VEL = 0.15;</p>

<p>/<strong>
 * An animated SVG component.
 */
var VectorWidget = React.createClass({
  /</strong>
   * Initialize state members.
   */
  getInitialState: function() {</p>

<pre><code>return {degrees: 0, velocity: 0, drag: MOUSE_UP_DRAG};
</code></pre>

<p>  },</p>

<p>  /<em>*
   * When the component is mounted into the document &ndash; this is similar to a
   * constructor, but invoked when the instance is actually mounted into the
   * document. Here&rsquo;s, we&rsquo;ll just set up an animation loop that invokes our
   * method. Binding of <code>this.onTick</code> is not needed because all React methods
   * are automatically bound before being mounted.
   </em>/
  componentDidMount: function() {</p>

<pre><code>this._interval = window.setInterval(this.onTick, 20);
</code></pre>

<p>  },</p>

<p>  componentWillUnmount: function() {</p>

<pre><code>window.clearInterval(this._interval);
</code></pre>

<p>  },</p>

<p>  onTick: function() {</p>

<pre><code>var nextDegrees = this.state.degrees + BASE_VEL + this.state.velocity;
var nextVelocity = this.state.velocity * this.state.drag;
this.setState({degrees: nextDegrees, velocity: nextVelocity});
</code></pre>

<p>  },</p>

<p>  /<em><em>
   * This is the &ldquo;main&rdquo; method for any component. The React API allows you to
   * describe the structure of your UI component at </em>any</em> point in time.
   */
  render: function() {</p>

<pre><code>return (
  &lt;Surface
    width={700}
    height={700}
    {this.renderGraphic(this.state.degrees)}
  &lt;/Surface&gt;
);
</code></pre>

<p>  },</p>

<p>  /<em>*
   * Better SVG support for React coming soon.
   </em>/
  renderGraphic: function(rotation) {</p>

<pre><code>return (
  &lt;Group
  &gt;
    &lt;Group x={210} y={135}&gt;
      &lt;Shape fill="rgba(0,0,0,0.1)" d={BORDER_PATH} /&gt;
      &lt;Shape fill="#7BC7BA" d={BG_PATH} /&gt;
      &lt;Shape fill="#DCDCDC" d={BAR_PATH} /&gt;
      &lt;Shape fill="#D97B76" d={RED_DOT_PATH} /&gt;
      &lt;Shape fill="#DBBB79" d={YELLOW_DOT_PATH} /&gt;
      &lt;Shape fill="#A6BD8A" d={GREEN_DOT_PATH} /&gt;
      &lt;Group x={55} y={29}&gt;
        &lt;Group rotation={rotation} originX={84} originY={89}&gt;
          &lt;Shape fill="#FFFFFF" d={CENTER_DOT_PATH} /&gt;
          &lt;Group&gt;
            &lt;Shape d={RING_ONE_PATH} stroke="#FFFFFF" strokeWidth={8} /&gt;
            &lt;Shape d={RING_TWO_PATH} transform={RING_TWO_ROTATE} stroke="#FFFFFF" strokeWidth={8} /&gt;
            &lt;Shape d={RING_THREE_PATH} transform={RING_THREE_ROTATE} stroke="#FFFFFF" strokeWidth={8} /&gt;
          &lt;/Group&gt;
        &lt;/Group&gt;
      &lt;/Group&gt;
    &lt;/Group&gt;
  &lt;/Group&gt;
);
</code></pre>

<p>  }
});</p>

<p>var BORDER_PATH = &ldquo;M3.00191459,4 C1.34400294,4 0,5.34785514 0,7.00550479 L0,220.994495 C0,222.65439 1.34239483,224 3.00191459,224 L276.998085,224 C278.655997,224 280,222.652145 280,220.994495 L280,7.00550479 C280,5.34561033 278.657605,4 276.998085,4 L3.00191459,4 Z M3.00191459,4&rdquo;;
var BG_PATH = &ldquo;M3.00191459,1 C1.34400294,1 0,2.34785514 0,4.00550479 L0,217.994495 C0,219.65439 1.34239483,221 3.00191459,221 L276.998085,221 C278.655997,221 280,219.652145 280,217.994495 L280,4.00550479 C280,2.34561033 278.657605,1 276.998085,1 L3.00191459,1 Z M3.00191459,1&rdquo;;
var BAR_PATH = &ldquo;M3.00191459,0 C1.34400294,0 0,1.34559019 0,3.00878799 L0,21 C0,21 0,21 0,21 L280,21 C280,21 280,21 280,21 L280,3.00878799 C280,1.34708027 278.657605,0 276.998085,0 L3.00191459,0 Z M3.00191459,0&rdquo;;
var RED_DOT_PATH = &ldquo;M12.5,17 C16.0898511,17 19,14.0898511 19,10.5 C19,6.91014895 16.0898511,4 12.5,4 C8.91014895,4 6,6.91014895 6,10.5 C6,14.0898511 8.91014895,17 12.5,17 Z M12.5,17&rdquo;;
var YELLOW_DOT_PATH = &ldquo;M31.5,17 C35.0898511,17 38,14.0898511 38,10.5 C38,6.91014895 35.0898511,4 31.5,4 C27.9101489,4 25,6.91014895 25,10.5 C25,14.0898511 27.9101489,17 31.5,17 Z M31.5,17&rdquo;;
var GREEN_DOT_PATH = &ldquo;M50.5,17 C54.0898511,17 57,14.0898511 57,10.5 C57,6.91014895 54.0898511,4 50.5,4 C46.9101489,4 44,6.91014895 44,10.5 C44,14.0898511 46.9101489,17 50.5,17 Z M50.5,17&rdquo;;
var CENTER_DOT_PATH = &ldquo;M84,105 C92.8365564,105 100,97.8365564 100,89 C100,80.1634436 92.8365564,73 84,73 C75.1634436,73 68,80.1634436 68,89 C68,97.8365564 75.1634436,105 84,105 Z M84,105&rdquo;;
var RING_ONE_PATH = &ldquo;M84,121 C130.391921,121 168,106.673113 168,89 C168,71.3268871 130.391921,57 84,57 C37.6080787,57 0,71.3268871 0,89 C0,106.673113 37.6080787,121 84,121 Z M84,121&rdquo;;
var RING_TWO_PATH = &ldquo;M84,121 C130.391921,121 168,106.673113 168,89 C168,71.3268871 130.391921,57 84,57 C37.6080787,57 0,71.3268871 0,89 C0,106.673113 37.6080787,121 84,121 Z M84,121&rdquo;;
var RING_THREE_PATH = &ldquo;M84,121 C130.391921,121 168,106.673113 168,89 C168,71.3268871 130.391921,57 84,57 C37.6080787,57 0,71.3268871 0,89 C0,106.673113 37.6080787,121 84,121 Z M84,121&rdquo;;
var RING_TWO_ROTATE = new Transform().translate(84.000000, 89.000000).rotate(-240.000000).translate(-84.000000, -89.000000);
var RING_THREE_ROTATE = new Transform().translate(84.000000, 89.000000).rotate(-300.000000).translate(-84.000000, -89.000000);</p>

<p>module.exports = VectorWidget;
```</p>

<p>You may notice that I removed the <code>mouseDown/mouseUp</code> stuff.
I tried getting it work very briefly with <code>onPress</code> and <code>TouchableWithoutFeedback</code> but I couldn&rsquo;t get it working.
If you get it figured out let me know.</p>

<h2>Conclusion</h2>

<p>That&rsquo;s it, you can now render your react-art code natively. Enjoy</p>

<p><img class="<a" src="href="http://i.imgur.com/AXbsaTB.png">http://i.imgur.com/AXbsaTB.png</a>" title="Final result" ></p>
]]></content>
  </entry>
  
</feed>
