<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: react-art | JavaScript Without Grammar]]></title>
  <link href="http://browniefed.com/blog/categories/react-art/atom.xml" rel="self"/>
  <link href="http://browniefed.com/"/>
  <updated>2015-09-04T15:18:32-07:00</updated>
  <id>http://browniefed.com/</id>
  <author>
    <name><![CDATA[Jason Brown]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[React-Native Animated with React-Art - Firework Tap To Shoot]]></title>
    <link href="http://browniefed.com/blog/2015/08/29/react-native-animated-with-react-art-firework-show/"/>
    <updated>2015-08-29T22:12:00-07:00</updated>
    <id>http://browniefed.com/blog/2015/08/29/react-native-animated-with-react-art-firework-show</id>
    <content type="html"><![CDATA[<h1>Introduction</h1>

<p>This actually could be built with out react-art, but we&rsquo;ll use react-art just for good measure.
What are we building? A firework show. Nothing fancy. Just tap on the screen and a firework will be shot to that point and explode.</p>

<h1>What?</h1>

<p>This is what we&rsquo;re building</p>

<p><img class="<a" src="href="http://i.imgur.com/Dj60a6e.gif">http://i.imgur.com/Dj60a6e.gif</a>" title="Firework Shooter" ></p>

<!-- more -->


<h1>Setup</h1>

<p>Just like normal, lets set the scene. A blank app with everything imported, etc.</p>

<p>```
var React = require(&lsquo;react-native&rsquo;);
var Dimensions = require(&lsquo;Dimensions&rsquo;);
var ReactNativeART = require(&lsquo;ReactNativeART&rsquo;);</p>

<p>var {
  width,
  height
} = Dimensions.get(&lsquo;window&rsquo;);</p>

<p>var {
  AppRegistry,
  StyleSheet,
  Animated,
  View,
  TouchableWithoutFeedback
} = React;</p>

<p>var {</p>

<pre><code>Surface,
Shape,
Path,
Group,
Transform
</code></pre>

<p>} = ReactNativeART;</p>

<p>var AnimatedShape = Animated.createAnimatedComponent(Shape);
var AnimatedGroup = Animated.createAnimatedComponent(Group);
```</p>

<p>We bring in the <code>Animated</code> API, <code>ReactNativeART</code>, some components from <code>ART</code>.
The thing that we have done before is creating <code>AnimatedShape</code>, and <code>AnimatedGroup</code>. What these do is allow us to set props like <code>fill</code>, <code>opacity</code>, <code>x</code>, <code>y</code>, that are Animated values. This will cause updates in our native world correctly and efficiently.</p>

<p>Now our styles</p>

<p>```
var styles = StyleSheet.create({
  container: {</p>

<pre><code>flex: 1,
flexDirection: 'column'
</code></pre>

<p>  }
});
<code>``
Yep that is it. Most of our stuff will take place in the</code>react-art` world.</p>

<p>Now our basic class</p>

<p>```
var FireworkShooter = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
  fireworks: []
};
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
    &lt;TouchableWithoutFeedback&gt;
      &lt;View&gt;
        &lt;Surface width={width} height={height}&gt;
        &lt;/Surface&gt;
      &lt;/View&gt;
    &lt;/TouchableWithoutFeedback&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
});
```</p>

<p>So we have a simple setup. A full container view, with a <code>TouchableWithoutFeedback</code> so we can get the press coordinates. Then a wrapping <code>View</code> since <code>Touchable</code> stuff needs a native view below it. Then finally our <code>react-art</code> <code>Surface</code>. This takes a <code>width</code> and <code>height</code> prop. In our case we want the full screen, so we get the dimensions of the phone that we extracted up above and set it.</p>

<h1>Shoot a mortar</h1>

<p>Lets think about this.
We want a mortar (a small glowing ball) to shoot from the bottom center of the screen to where we&rsquo;ve tapped.</p>

<p>That means with <code>react-art</code> we&rsquo;ll have to create a closed <code>Path</code> that is a circle. It just so happens that <code>react-art</code> ships with a <code>Circle</code> shape for us to use.</p>

<p>Okay so our list of needs</p>

<ul>
<li>A press handler to get where we tapped</li>
<li>A <code>Circle</code> that can take Animated API props</li>
<li>A way to animate that <code>Circle</code> aka mortar to the tap</li>
<li>Render a mortar on the <code>Surface</code></li>
</ul>


<p><code>
&lt;TouchableWithoutFeedback onPress={this._handleAddFirework}&gt;
</code>
We&rsquo;ll use the <code>TouchableWithoutFeedback</code> to call out to a function to queue up adding a firework.
Check that off the list.</p>

<p>```
//React-Art ships with this component however not react-native-art implementation we&rsquo;ll just grab it and
//modify this to use the AnimatedShape we create up above. Thanks Facebook :)</p>

<p>/<em>*
 * Copyright 2013-2014 Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Circle.art
 * @typechecks
 *
 * Example usage:
 * <Circle
 *   radius={10}
 *   stroke="green"
 *   strokeWidth={3}
 *   fill="blue"
 * />
 *
 </em>/
var AnimatedCircle = React.createClass({displayName: &ldquo;Circle&rdquo;,
  render: function() {</p>

<pre><code>var radius = this.props.radius;

var path = Path().moveTo(0, -radius)
    .arc(0, radius * 2, radius)
    .arc(0, radius * -2, radius)
    .close();
return React.createElement(AnimatedShape, React.__spread({},  this.props, {d: path}));
</code></pre>

<p>  }
});
```</p>

<p>Hey look we just grabbed it and changed <code>Shape</code> to <code>AnimatedShape</code>. Yaye for React and reusable code.</p>

<p>```
var MORTAR_RADIUS = 5;
///&hellip;
_handleAddFirework: function(e) {</p>

<pre><code>var _shootingPosition = new Animated.ValueXY({x: width/2, y: height - MORTAR_RADIUS});

this.state.fireworks.push({
  shootingPosition: _shootingPosition,
});

Animated.timing(_shootingPosition, {
    duration: 300,
    toValue: {
      y: e.nativeEvent.locationY,
      x: e.nativeEvent.locationX
    }
}).start()

this.setState(this.state);
</code></pre>

<p>}
```
Alright. Pause and lets analyze this code.</p>

<p>First line <code>_shootingPosition</code>, we create a new <code>Animated.ValueXY</code> and set our defaults. These defaults are the starting position of the animation. Usually these would default to <code>x: 0, y:0</code> but we have other plans.</p>

<p>We set our <code>x</code> to <code>width/2</code> which is the middle of the phone. Then our <code>y</code> is going to the <code>height</code> of the device minus a <code>MORTAR_RADIUS</code>. We put a constant at the top of the code to say our mortar radius is going to be 5.</p>

<p>Next we add it to an array of fireworks we&rsquo;ll shoot later.</p>

<p>Then we create the animation.
We want the mortar to take <code>300</code> milliseconds to reach the spot the user pressed. We set the <code>toValue</code> to where our users pressed.
Then we start the animation. Yeah we haven&rsquo;t even rendered anything yet but it&rsquo;ll all be okay trust me.</p>

<p>Finally we set our state and thus it&rsquo;ll cause a re-render and we can render our firework.</p>

<p>```
<Surface width={width} height={height}>
{</p>

<pre><code>this.state.fireworks.map((firework) =&gt; {
    return &lt;AnimatedCircle 
                radius={MORTAR_RADIUS} 
                x={firework.shootingPosition.x} 
                y={firework.shootingPosition.y}
                fill="#000"
            /&gt;
})
</code></pre>

<p>}
</Surface>
<code>``
So we map over each firework, return the</code>AnimatedCircle<code>and set the appropriate properties, which 2 of those</code>x<code>, and</code>y` are animated properties. In our case we&rsquo;re going to fill the cirlcle with black to start.</p>

<p>So what does that all look like? Something like this</p>

<p><img class="<a" src="href="http://i.imgur.com/arIjyoz.gif">http://i.imgur.com/arIjyoz.gif</a>" title="Black Shooting Circles" ></p>

<h1>Shoot multiple mortars that disappear</h1>

<p>Well mortars don&rsquo;t stick like that. So lets make them disappear.
The <code>start()</code> function takes a callback that is called when the animation completes.</p>

<p>To identify the firework in the array we&rsquo;ll just use the <code>shootingPosition</code> animation to identify it and filter it out.</p>

<p>Something like this.</p>

<p>```
  removeSelf: function(_shootingPosition) {</p>

<pre><code>this.state.fireworks = this.state.fireworks.filter((firework) =&gt; firework.shootingPosition !== _shootingPosition);
this.setState(this.state);
</code></pre>

<p>  },</p>

<p>  ///</p>

<pre><code>Animated.timing(_shootingPosition, {
    duration: 300,
    toValue: {
      y: e.nativeEvent.locationY,
      x: e.nativeEvent.locationX
    }
]).start(this.removeSelf.bind(this, _shootingPosition));
</code></pre>

<p>```</p>

<p>Not the most elegant of solutions but hey it works. It runs through each firework, removes our _shootingPosition, and then refreshes the UI.</p>

<h1>Animate the color</h1>

<p>Lets make the mortar more than just a black dot. Lets pretend it&rsquo;s a fire ball, and we want it to alternate between yellow and orange.</p>

<p>We&rsquo;ll use these 2 colors and pop them at the top</p>

<p><code>
var SHOOTING_COLORS = [
  'rgb(234,238,112)', //Yellow
  'rgb(245,137,12)' //Orange
];
</code></p>

<p>The <code>interpolate</code> function we&rsquo;re going to call only works with <code>rgb</code> hence the use of <code>rgb</code> instead of hex.</p>

<p>Next we&rsquo;ll need to create another Animated value.</p>

<p>Our code will look like so</p>

<p>```</p>

<pre><code>var _shootingPosition = new Animated.ValueXY({x: width/2, y: height - MORTAR_RADIUS});
var _shootingColor = new Animated.Value(0);

this.state.fireworks.push({
  shootingPosition: _shootingPosition,
  shootingColor: _shootingColor,
});

//

_shootingPosition.addListener(this.adjustShootingFill.bind(null, _shootingColor));

adjustShootingFill: function(_shootingColor, value) {
    Animated.timing(_shootingColor, {
      duration: 16,
      toValue: _shootingColor.getAnimatedValue() == 0 ? 1 : 0
    }).start()
},
</code></pre>

<p><code>``
We start off by adding a new</code>Animated.Value`, and set it to 0. We add it to our firework object.</p>

<p>Then we add a listener to it. What <code>addListener</code> does is provides a callback that will be called each time the mortar position is updated.
The bind is just so it&rsquo;ll pass in our <code>_shootingColor</code> Animated value as the first argument.</p>

<p>We&rsquo;ll use the <code>Animated.timing</code> function again to transition it between colors over 16ms. We call <code>getAnimatedValue()</code> and do the inverse of it.</p>

<p>So every <code>16ms</code> the mortar will transition from yellow => orange => yellow => orange, etc.</p>

<p>Now what does that look like in our render?</p>

<p>```
<Surface width={width} height={height}>
{</p>

<pre><code>this.state.fireworks.map((firework) =&gt; {

    var _shootingFill = firework.shootingColor.interpolate({
      inputRange: [0,1],
      outputRange: SHOOTING_COLORS
    });


    return &lt;AnimatedCircle 
                radius={MORTAR_RADIUS} 
                x={firework.shootingPosition.x} 
                y={firework.shootingPosition.y}
                fill={_shootingFill}
            /&gt;
})
</code></pre>

<p>}
</Surface>
<code>``
We need to create an interpolator. This interpolate will encapsulate the logic that picks the color when we change the value of</code>shootingColor<code>up above in our</code>adjustShootingFill` function.</p>

<p>It maps to</p>

<p><code>
0 =&gt; yellow
1 =&gt; orange
</code>
Then we pass that into our fill property and we&rsquo;re done.</p>

<p><img class="<a" src="href="http://i.imgur.com/r69Ba6r.gif">http://i.imgur.com/r69Ba6r.gif</a>" title="Orange Yellow Moratrs" ></p>

<h1>Make those mortars explode</h1>

<p>Now for the fun part. Lets make our mortars explode.</p>

<p>Our mortar concept will be pretty simplistic, we&rsquo;ll create 20 circles that explode outwards and expand.
We could create all sorts of tails that fly around and do cool things but that is a tutorial for another time.</p>

<p>First lets setup some variables</p>

<p>```
var PARTICLE_RADIUS = 30; // How big should the explosions be
var PARTICLE_COUNT = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]; // How many particles per explosion, this is the lazy persons range call</p>

<p>var PARTICLE_COLORS = [</p>

<pre><code>'rgba(54, 17, 52, 100)',
'rgba(176, 34, 140, 100)',
'rgba(234, 55, 136, 100)',
'rgba(229, 107, 112, 100)',
'rgba(243, 145, 160, 100)'
</code></pre>

<p>]
```</p>

<p>We the <code>PARTICLE_RADIUS</code> which will determine how large each explosion is. We setup <code>PARTICLE_COUNT</code> which is the amount of particles we&rsquo;ll use.
Finally we want our firework show to be 5 different colors. So each explosion will change between each of these colors.</p>

<p>For the sake of simplicity we&rsquo;ll make each particle the same exact color meaning we only need 1 <code>Animated.Value</code> for it.</p>

<p>```</p>

<pre><code>var _particleColor = new Animated.Value(0);
var _particleRadius = new Animated.Value(0);
var _coreOpacity = new Animated.Value(1);
</code></pre>

<p><code>``
We also need an</code>Animated.Value<code>for our radius, we put it at 0 so it starts hidden. The other</code>Animated.Value` is our core opacity animation.
That is the value for hiding our core mortar once it explodes.</p>

<p>```</p>

<pre><code>var _particlePositions = PARTICLE_COUNT.map(() =&gt; new Animated.ValueXY({x: 0, y: 0}));
</code></pre>

<p><code>``
Each particle will have to go to a different position so in this case we'll need 20</code>Animated.ValueXY`.</p>

<p>```
this.state.fireworks.push({</p>

<pre><code>  shootingPosition: _shootingPosition,
  shootingColor: _shootingColor,
  particleColor: _particleColor,
  particleRadius: _particleRadius,
  coreOpacity: _coreOpacity,
  particlePositions: _particlePositions
});
</code></pre>

<p>```</p>

<p>Add them to our firework so we can access them later in our render.</p>

<p>```</p>

<pre><code>var _animatedParticles = [
    Animated.timing(_particleRadius, {
      duration: 700,
      toValue: 1
    }),
    Animated.timing(_coreOpacity, {
      duration: 200,
      toValue: 0
    })
]

_movingParticles = _particlePositions.map((particle, i) =&gt; {
  var _xy = getXYParticle(PARTICLE_COUNT.length, i, PARTICLE_RADIUS);
  return Animated.timing(particle, {
    duration: 250,
    toValue: _xy
  })
})

//At the bottom of the file
function getXYParticle(total, i, radius) {
  var angle = 360/total*i;

  var x = Math.round((radius*2) * Math.cos(angle - (Math.PI/2)));
  var y = Math.round((radius*2) * Math.sin(angle - (Math.PI/2)));

  return {
    x: x,
    y: y
  }
}

_animatedParticles = _animatedParticles.concat(_movingParticles);
</code></pre>

<p>```</p>

<p>This whole animation mapping is setting us up for what we are going to do next. Which is queue up our animations.</p>

<p>We create an array of animations that need to happen. The first is expanding each <code>_particleRadius</code>. We have determine that it will take 700 milliseconds to fully expand the explosion. The <code>_particleRadius</code> will actually be the particle scale. We&rsquo;ll just scale up the circle so it looks like it&rsquo;s exploding outwards, but that will be shown off in our render function.</p>

<p>We set our <code>_coreOpacity</code> aka our mortar ball to fade out and disappear over 200 milliseconds.</p>

<p>We need to create the animations for each particle. It needs to shoot out from our current mortar location to different points on the circle.
After googling around I found a function below, and deleted a bunch of stuff to basically get down to a rough position algorithim to return <code>x,y</code> positions.</p>

<p>We once again use <code>Animated.timing</code> to say that the particle should take 250 milliseconds to get into it&rsquo;s position.</p>

<p>```</p>

<pre><code>Animated.sequence([
  Animated.timing(_shootingPosition, {
    duration: 300,
    toValue: {
      y: e.nativeEvent.locationY,
      x: e.nativeEvent.locationX
    }
  }),
  Animated.parallel(_animatedParticles)
]).start(this.removeSelf.bind(this, _shootingPosition));
</code></pre>

<p>```</p>

<p>Now to queue up our animations. We want our mortar shooting to happen first, then the explosion.
We do that using <code>Animated.sequence</code>.</p>

<p>We first have our mortar go up to the location of the users touch.
The next piece is wrapping all of our explosion animations in an <code>Animated.parallel</code>. This is the opposite of sequence, which it says execute all of these animations at the same time.</p>

<p>So our mortar fading out and disappearing, our particles expanding, changing color, and exploding outward will all happen at the same time.</p>

<p>```</p>

<pre><code>_shootingPosition.addListener(this.adjustShootingFill.bind(null, _shootingColor));
_particleRadius.addListener(this.adjustParticleFill.bind(null, _particleColor));

///
  adjustParticleFill: function(_particleColor, value) {
    var _currentFill = _particleColor.getAnimatedValue(),
        _particleFill = _currentFill === 5 ? 0 : _currentFill + 1;

    Animated.timing(_particleColor, {
      duration: 16,
      toValue: _particleFill
    }).start()
  },
</code></pre>

<p>```</p>

<p>Finally we need to change our color of our particle. So like before we&rsquo;ll attach to the expanding of our particle and make it call a function to change the fill color.
In our new case we have five colors to choose from so the logic is a little different but mostly the same.</p>

<p>Now for our rendering of this all. We&rsquo;ll move it out to a different function to deal with.</p>

<p>```
  <Surface width={width} height={height}></p>

<pre><code>{this.getFireworks()}
</code></pre>

<p>  </Surface>
```</p>

<p>```
getFireworks: function() {</p>

<pre><code>return this.state.fireworks.map((firework, i) =&gt; {

  var _shootingFill = firework.shootingColor.interpolate({
    inputRange: [0,1],
    outputRange: SHOOTING_COLORS
  });

  var _particleFill = firework.particleColor.interpolate({
    inputRange: [0,1,2,3,4],
    outputRange: PARTICLE_COLORS
  });

  return (
      &lt;AnimatedGroup 
        x={firework.shootingPosition.x}
        y={firework.shootingPosition.y}
      &gt;
            &lt;AnimatedCircle
              opacity={firework.coreOpacity}
              radius={MORTAR_RADIUS}
              fill={_shootingFill}
            /&gt;
            &lt;Group&gt;
            {
              PARTICLE_COUNT.map((v, j) =&gt; {
                return &lt;AnimatedCircle
                  x={firework.particlePositions[j].x}
                  y={firework.particlePositions[j].y}
                  scaleX={firework.particleRadius}
                  scaleY={firework.particleRadius}
                  radius={PARTICLE_RADIUS}
                  fill={_particleFill}
                /&gt;
              })
            }
            &lt;/Group&gt;
      &lt;/AnimatedGroup&gt;
  );
})
</code></pre>

<p>  },
<code>``
There is a lot going on here. We have our same</code><em>shootingFill<code>like we did before, that causes the yellow =&gt; orange interpolation.
We add another interpolation for the particleFill. Same concept as the</code></em>shootingFill` just with 5 colors now.</p>

<p>What is much different here is the <code>AnimatedGroup</code>. We have moved our <code>x,y</code> from the <code>AnimatedCircle</code> to the <code>AnimatedGroup</code>.</p>

<p>This will bundle our mortar, and our particles all in the same coordinate area. That way we can have our particles start at <code>0,0</code> and move outwards and the <code>AnimatedGroup</code> will make sure all the coordinates are handled correctly.</p>

<p><code>
&lt;AnimatedCircle
  opacity={firework.coreOpacity}
  radius={MORTAR_RADIUS}
  fill={_shootingFill}
/&gt;
</code>
You can see here we put out <code>coreOpacity</code> animation in there. So it&rsquo;ll fade from <code>1</code> opacity down to <code>0</code> over that 200 milliseconds we setup.</p>

<p>```
  <Group></p>

<pre><code>{
  PARTICLE_COUNT.map((v, j) =&gt; {
    return &lt;AnimatedCircle
      x={firework.particlePositions[j].x}
      y={firework.particlePositions[j].y}
      scaleX={firework.particleRadius}
      scaleY={firework.particleRadius}
      radius={PARTICLE_RADIUS}
      fill={_particleFill}
    /&gt;
  })
}
</code></pre>

<p>  </Group>
<code>``
We group the Particles with a</code>Group` component but that&rsquo;s just arbitrary.</p>

<p>We map over our 20 particles, and set the <code>x</code> and <code>y</code> to the points we had determined with our <code>getXYParticle</code> function.</p>

<p>You&rsquo;ll notice we are passing in <code>particleRadius</code> to the <code>scaleX</code> and <code>scaleY</code> properties.
This is because while writing this I realized that the <code>AnimatedCircle</code> takes the radius property and creates a path out of it. That is not animateable in this particular way, so the solution I came up was to scale each particle to 0. Basically making it completely hidden.</p>

<p>That then allows us to expand it out to it&rsquo;s full scale and make it look like an explosion. It actually works better.</p>

<p>Finally we add in our <code>PARTICLE_RADIUS</code> we defined at the top, aka size of each explosion, and put in our <code>_particleFill</code> which is the color interpolation between those 5 colors.</p>

<h1>Play with it</h1>

<p>That is all! We have a firework shooter!</p>

<p>Check it out on RNPlay as per usual <a href="https://rnplay.org/apps/ysm12A">https://rnplay.org/apps/ysm12A</a>.</p>

<p>Tap to your hearts content and watch all the explosive animation goodness appear on screen.</p>

<p><img class="<a" src="href="http://i.imgur.com/Dj60a6e.gif">http://i.imgur.com/Dj60a6e.gif</a>" title="Firework Shooter" ></p>

<h1>Final Code</h1>

<p>```
var React = require(&lsquo;react-native&rsquo;);
var Dimensions = require(&lsquo;Dimensions&rsquo;);
var ReactNativeART = require(&lsquo;ReactNativeART&rsquo;);</p>

<p>var {
  width,
  height
} = Dimensions.get(&lsquo;window&rsquo;);</p>

<p>var MORTAR_RADIUS = 5;
var PARTICLE_RADIUS = 30;
var PARTICLE_COUNT = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20];</p>

<p>var {
  AppRegistry,
  StyleSheet,
  Animated,
  View,
  TouchableWithoutFeedback
} = React;</p>

<p>var {</p>

<pre><code>Surface,
Shape,
Path,
Group,
Transform
</code></pre>

<p>} = ReactNativeART;</p>

<p>var SHOOTING_COLORS = [
  &lsquo;rgb(234,238,112)&rsquo;,
  &lsquo;rgb(245,137,12)&rsquo;
];</p>

<p>var PARTICLE_COLORS = [</p>

<pre><code>'rgba(54, 17, 52, 100)',
'rgba(176, 34, 140, 100)',
'rgba(234, 55, 136, 100)',
'rgba(229, 107, 112, 100)',
'rgba(243, 145, 160, 100)'
</code></pre>

<p>]</p>

<p>var AnimatedShape = Animated.createAnimatedComponent(Shape);
var AnimatedGroup = Animated.createAnimatedComponent(Group);</p>

<p>var FireworkShooter = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
  fireworks: []
};
</code></pre>

<p>  },
  adjustShootingFill: function(_shootingColor, value) {</p>

<pre><code>Animated.timing(_shootingColor, {
  duration: 16,
  toValue: _shootingColor.getAnimatedValue() == 0 ? 1 : 0
}).start()
</code></pre>

<p>  },
  adjustParticleFill: function(_particleColor, value) {</p>

<pre><code>var _currentFill = _particleColor.getAnimatedValue(),
    _particleFill = _currentFill === 5 ? 0 : _currentFill + 1;

Animated.timing(_particleColor, {
  duration: 16,
  toValue: _particleFill
}).start()
</code></pre>

<p>  },
  removeSelf: function(_shootingPosition) {</p>

<pre><code>this.state.fireworks = this.state.fireworks.filter((firework) =&gt; firework.shootingPosition !== _shootingPosition);
this.setState(this.state);
</code></pre>

<p>  },
  _handleAddFirework: function(e) {</p>

<pre><code>var _shootingPosition = new Animated.ValueXY({x: width/2, y: height - MORTAR_RADIUS});
var _shootingColor = new Animated.Value(0);

var _particleColor = new Animated.Value(0);
var _particleRadius = new Animated.Value(0);
var _coreOpacity = new Animated.Value(1);

var _particlePositions = PARTICLE_COUNT.map(() =&gt; new Animated.ValueXY({x: 0, y: 0}));

this.state.fireworks.push({
  shootingPosition: _shootingPosition,
  shootingColor: _shootingColor,
  particleColor: _particleColor,
  particleRadius: _particleRadius,
  coreOpacity: _coreOpacity,
  particlePositions: _particlePositions
});

var _animatedParticles = [
    Animated.timing(_particleRadius, {
      duration: 700,
      toValue: 1
    }),
    Animated.timing(_coreOpacity, {
      duration: 200,
      toValue: 0
    })
]

_movingParticles = _particlePositions.map((particle, i) =&gt; {
  var _xy = getXYParticle(PARTICLE_COUNT.length, i, PARTICLE_RADIUS);
  return Animated.timing(particle, {
    duration: 250,
    toValue: _xy
  })
})

_animatedParticles = _animatedParticles.concat(_movingParticles);

Animated.sequence([
  Animated.timing(_shootingPosition, {
    duration: 300,
    toValue: {
      y: e.nativeEvent.locationY,
      x: e.nativeEvent.locationX
    }
  }),
  Animated.parallel(_animatedParticles)
]).start(this.removeSelf.bind(this, _shootingPosition));

_shootingPosition.addListener(this.adjustShootingFill.bind(null, _shootingColor));
_particleRadius.addListener(this.adjustParticleFill.bind(null, _particleColor));

this.setState(this.state);
</code></pre>

<p>  },</p>

<p>  getFireworks: function() {</p>

<pre><code>return this.state.fireworks.map((firework, i) =&gt; {

  var _shootingFill = firework.shootingColor.interpolate({
    inputRange: [0,1],
    outputRange: SHOOTING_COLORS
  });

  var _particleFill = firework.particleColor.interpolate({
    inputRange: [0,1,2,3,4],
    outputRange: PARTICLE_COLORS
  });

  return (
      &lt;AnimatedGroup 
        x={firework.shootingPosition.x}
        y={firework.shootingPosition.y}
      &gt;
            &lt;AnimatedCircle
              key={i}
              opacity={firework.coreOpacity}
              radius={MORTAR_RADIUS}
              fill={_shootingFill}
            /&gt;
            &lt;Group&gt;
            {
              PARTICLE_COUNT.map((v, j) =&gt; {
                return &lt;AnimatedCircle
                  x={firework.particlePositions[j].x}
                  y={firework.particlePositions[j].y}
                  scaleX={firework.particleRadius}
                  scaleY={firework.particleRadius}
                  radius={PARTICLE_RADIUS}
                  fill={_particleFill}
                /&gt;
              })
            }
            &lt;/Group&gt;
      &lt;/AnimatedGroup&gt;
  );
})
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return (
  &lt;View style={styles.container}&gt;
    &lt;TouchableWithoutFeedback onPress={this._handleAddFirework}&gt;
      &lt;View&gt;
        &lt;Surface width={width} height={height}&gt;
          {this.getFireworks()}
        &lt;/Surface&gt;
      &lt;/View&gt;
    &lt;/TouchableWithoutFeedback&gt;
  &lt;/View&gt;
);
</code></pre>

<p>  }
});</p>

<p>var styles = StyleSheet.create({
  container: {</p>

<pre><code>flex: 1,
flexDirection: 'column'
</code></pre>

<p>  }
});</p>

<p>function getXYParticle(total, i, radius) {
  var angle = 360/total*i;</p>

<p>  var x = Math.round((radius<em>2) * Math.cos(angle &ndash; (Math.PI/2)));
  var y = Math.round((radius</em>2) * Math.sin(angle &ndash; (Math.PI/2)));</p>

<p>  return {</p>

<pre><code>x: x,
y: y
</code></pre>

<p>  }
}</p>

<p>//Modified this to use the AnimatedShape we create up above. Thanks Facebook :)</p>

<p>/<em>*
 * Copyright 2013-2014 Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Circle.art
 * @typechecks
 *
 * Example usage:
 * <Circle
 *   radius={10}
 *   stroke="green"
 *   strokeWidth={3}
 *   fill="blue"
 * />
 *
 </em>/
var AnimatedCircle = React.createClass({displayName: &ldquo;Circle&rdquo;,
  render: function() {</p>

<pre><code>var radius = this.props.radius;

var path = Path().moveTo(0, -radius)
    .arc(0, radius * 2, radius)
    .arc(0, radius * -2, radius)
    .close();
return React.createElement(AnimatedShape, React.__spread({},  this.props, {d: path}));
</code></pre>

<p>  }
});</p>

<p>AppRegistry.registerComponent(&lsquo;FireworkShooter&rsquo;, () => FireworkShooter);
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CSS-Layout and React-Art]]></title>
    <link href="http://browniefed.com/blog/2015/06/01/css-layout-and-react-art/"/>
    <updated>2015-06-01T10:29:00-07:00</updated>
    <id>http://browniefed.com/blog/2015/06/01/css-layout-and-react-art</id>
    <content type="html"><![CDATA[<h3>Intro</h3>

<p>If you&rsquo;ve used <code>react-native</code> before then you may know that &ldquo;css&rdquo; you&rsquo;re writing isn&rsquo;t actually CSS. It&rsquo;s a descriptor for a layout engine. That layout engine is <a href="https://github.com/facebook/css-layout">css-layout</a> which was created by <a href="https://twitter.com/Vjeux">@vjeux</a> and compiled to Java/Objective-C.</p>

<p>Layout is difficult. There have been attempts at various constraint based layouts in JavaScript, <a href="http://gridstylesheets.org/">GSS</a> is one of those. Which is a port of Apples <code>Cassowary</code> constraint solver which was also ported to JavaScript <a href="https://github.com/slightlyoff/cassowary.js">https://github.com/slightlyoff/cassowary.js</a>.</p>

<p>Now this is all fine and well but from the bit I&rsquo;ve read constraints fall down sometimes. This usually happens when you don&rsquo;t specify enough constraints based on the current layout.</p>

<h3>Layout is hard!</h3>

<p>Parent layouts get effected by their child layouts. CSS is weird in that you can remove items from layout with <code>position: absolute</code> but ultimately the top parent <code>width/height</code> is directly effected by it&rsquo;s children.</p>

<p>This is an over simplification but many times in <code>React</code> you have to hook into <code>componentDidMount</code> get the child width and take action.</p>

<p>An example would be even width labels in a form. We could measure the text but depending on <code>font</code>, <code>font-size</code> it could measure each value differently. So we hide the form on initial render, get the max label width and set it on state.</p>

<!-- more -->


<h3>CSS-Layout Basics</h3>

<p>It takes a subset of flexbox and some other styling parameters and returns <code>width</code>, and the <code>left/top</code> offsets for each item and it&rsquo;s children.</p>

<p>This example is taken directly from the <code>css-layout</code> git repo.</p>

<p>```
computeLayout(
  {style: {padding: 50}, children: [</p>

<pre><code>{style: {padding: 10, alignSelf: 'stretch'}}
</code></pre>

<p>  ]}
);
// =>
{</p>

<pre><code>width: 120,
height: 120,
top: 0,
left: 0,
children: [{
    width: 20,
    height: 20,
    top: 50,
    left: 50
}]
</code></pre>

<p>}
```</p>

<p>So explaining this. We have an item with a padding of <code>50</code>, so <code>50px</code> around the entire item.</p>

<p>It&rsquo;s child item has a padding of <code>10</code>, so <code>10px</code> all the way around.</p>

<p>Therefore the parent has <code>50*2 = 100</code> initial width/height. Now we take into account the children.</p>

<p>Width/Height:</p>

<p><code>
Parent: `50*2 = 100` +  `10*2 = 20` = `100 + 120`
Child: `10*2 = 20`
</code></p>

<p>Position:</p>

<p><code>
Parent: `x = 0, y = 0` since we are starting there.
Child: Parent padding `50` so our child is inset at `x = 50, y = 50`
</code></p>

<p>Lets change the child width and see what happens
```
computeLayout(</p>

<pre><code>{
    style: {
        padding: 50
    },
    children: [{
        style: {
            padding: 10,
            width: 1000,
            alignSelf: 'stretch'
        }
    }]
}
</code></pre>

<p>);
// =>
{</p>

<pre><code>"width": 1100,
"height": 120,
"top": 0,
"left": 0,
"children": [{
    "width": 1000,
    "height": 20,
    "top": 50,
    "left": 50
}]
</code></pre>

<p>}
<code>``
Because our child defined a width of</code>1000<code>we then add on our</code>50*2<code>of padding on both sides and now the parent has a width of</code>1100`.</p>

<p>There are some other nuances that you can read about in the <code>css-layout</code> repo.</p>

<h3>Basic Example</h3>

<p>First off we&rsquo;ll need a component tree. Now in React they transpile JSX, and build the component tree for us. However in our case we can just create a JSON tree.</p>

<p>```
var componentTree = {</p>

<pre><code>style: {
    padding: 10
},
component: Rectangle,
children: [{
    style: {
        padding: 10,
        flexDirection: 'column',
        alignItems: 'center'
    },
    component: Rectangle,
    children: [
        {
            style: {
                width: 30,
                height: 30
            },
            component: Rectangle
        },
        {
            style: {
                margin: 10,
                width: 50,
                height: 50,
                alignItems: 'center',
                justifyContent: 'center'
            },
            component: Circle,
            children: [
                {
                    style: {
                        width: 10,
                        height: 10
                    },
                    component: Circle
                }
            ]
        }
    ]
}]
</code></pre>

<p>};</p>

<p>```</p>

<p>We add a <code>component</code> parameter to the tree. This is the thing that will be rendered.
We could add additional properties here, maybe create custom renderers but we&rsquo;ll keep it simple.</p>

<p>The break down is like so</p>

<ul>
<li>A surrounding rectangle w/ <code>10px</code> of padding all around</li>
<li>1 child that is a rectangle with another <code>10px</code> of padding, and it&rsquo;s children in a <code>column</code> based layout.</li>
<li>We align each of the items in the <code>center</code></li>
<li>2 children one a Rectangle, one a Cirlce.</li>
<li>Rectangle = <code>width = 30, height = 30</code></li>
<li>Circle = <code>width = 50, height = 50</code> and a surrounding <code>10px</code> margin and it&rsquo;s children centered vertically and horizontally</li>
<li>That cirlce has a circle inside that is <code>width = 10</code> and `height = 10
We&rsquo;ll have to do some basic math on the Circle to compute the radius, and center it correctly.</li>
</ul>


<p>Now we&rsquo;ll need to traverse the layout.
We&rsquo;ll do that with a function that calls itself</p>

<p>```
function traverseLayout(componentTree, layout) {</p>

<pre><code>var Component = componentTree.component;
return (
    &lt;Group x={layout.left} y={layout.top}&gt;
        &lt;Component
            {...getProps(Component, layout)}
         /&gt;
         &lt;Group x={0} y={0}&gt;
            {
                !componentTree.children ? null : componentTree.children.map(function(child, index) {
                    return traverseLayout(child, layout.children[index]);
                })

            }
         &lt;/Group&gt;
    &lt;/Group&gt;
)
</code></pre>

<p>}
```
This is a super crude layout renderer but it works for our purposes.</p>

<p>It creates a group and we pass in our <code>top/left</code> to <code>x/y</code> of the group. This is necessary to make our children <code>top/left</code> work correctly.
Then renders the component with selected props. We&rsquo;ll just render <code>stroke="#000"</code> and a stroke={1}.</p>

<p>Then if we have children we will call ourself with the child component and layout.</p>

<p>To process the props we need to render different props for specific components.</p>

<p><code>Rectangle</code> needs <code>width/height</code> which we have.
<code>Circle</code> needs the radius computed, and to then be ofset by the radius. So we just divide the <code>width/2</code> and for positioning <code>y</code> we divide the <code>height/2</code>.</p>

<p>```
function getProps(component, layout) {</p>

<pre><code>var props = {
    x: 0,
    y: 0
};

if (Rectangle === component) {
    props.width = layout.width;
    props.height = layout.height;

} else if (Circle === component) {
    props.radius = layout.width/2;
    props.x += (layout.width/2)
    props.y += (layout.height/2);
}

props.stroke = "#000"; // Just to visualize
props.strokeWidth = 1; // Just to visualize
return props;
</code></pre>

<p>}
```</p>

<p>That is it, now we can render a tree of <code>Rectangles</code> and <code>Circles</code>. The complete code is below.</p>

<p>```
var React = require(&lsquo;react&rsquo;);
var ReactArt = require(&lsquo;react-art&rsquo;),</p>

<pre><code>Surface = ReactArt.Surface,
Group = ReactArt.Group,
computeLayout = require('css-layout'),
Circle = require('react-art/shapes/circle'),
Rectangle = require('react-art/shapes/rectangle');
</code></pre>

<p>var Surface = ReactArt.Surface;</p>

<p>var viewportWidth = function() {</p>

<pre><code>return  window.innerWidth - 100;
</code></pre>

<p>}
var viewportHeight = function() {</p>

<pre><code>return window.innerHeight - 100;
</code></pre>

<p>}</p>

<p>var componentTree = {</p>

<pre><code>style: {
    padding: 10
},
component: Rectangle,
children: [{
    style: {
        padding: 10,
        flexDirection: 'column',
        alignItems: 'center'
    },
    component: Rectangle,
    children: [
        {
            style: {
                width: 30,
                height: 30
            },
            component: Rectangle
        },
        {
            style: {
                margin: 10,
                width: 50,
                height: 50,
                alignItems: 'center',
                justifyContent: 'center'
            },
            component: Circle,
            children: [
                {
                    style: {
                        width: 10,
                        height: 10
                    },
                    component: Circle
                }
            ]
        }
    ]
}]
</code></pre>

<p>};</p>

<p>var layout = computeLayout(componentTree);</p>

<p>function traverseLayout(componentTree, layout) {</p>

<pre><code>var Component = componentTree.component;
return (
    &lt;Group x={layout.left} y={layout.top}&gt;
        &lt;Component
            {...getProps(Component, layout)}
         /&gt;
         &lt;Group x={0} y={0}&gt;
            {
                !componentTree.children ? null : componentTree.children.map(function(child, index) {
                    return traverseLayout(child, layout.children[index]);
                })

            }
         &lt;/Group&gt;
    &lt;/Group&gt;
)
</code></pre>

<p>}</p>

<p>function getProps(component, layout) {</p>

<pre><code>var props = {
    x: 0,
    y: 0
};

if (Rectangle === component) {
    props.width = layout.width;
    props.height = layout.height;

} else if (Circle === component) {
    props.radius = layout.width/2;
    props.x += (layout.width/2)
    props.y += (layout.height/2);
}

props.stroke = "#000";
props.strokeWidth = 1;
return props;
</code></pre>

<p>}</p>

<p>var Demo = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {

}
</code></pre>

<p>  },
  getRenderLayout: function() {</p>

<pre><code>return traverseLayout(componentTree, layout);
</code></pre>

<p>  },
  render: function () {</p>

<pre><code>return (
  &lt;div&gt;
    &lt;Surface
        width={viewportWidth()}
        height={viewportHeight()}
    &gt;
        {this.getRenderLayout()}
    &lt;/Surface&gt;
  &lt;/div&gt;
);
</code></pre>

<p>  }
});</p>

<p>module.exports = Demo;
```</p>

<h3>Possibilities</h3>

<p>Tic-tac-toe? Heh.</p>

<p>This could be made to layout components arbitrarily much like we do with <code>react-native</code>. It&rsquo;s not perfect and could only be used in specific scenarios but it&rsquo;s still a fun prototype.</p>

<h3>Demo</h3>

<p data-height="624" data-theme-id="0" data-slug-hash="zGZOMN" data-default-tab="result" data-user="browniefed" class='codepen'>See the Pen <a href='http://codepen.io/browniefed/pen/zGZOMN/'>zGZOMN</a> by Jason Brown (<a href='http://codepen.io/browniefed'>@browniefed</a>) on <a href='http://codepen.io'>CodePen</a>.</p>


<script async src="http://browniefed.com//assets.codepen.io/assets/embed/ei.js"></script>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Create a map with React-Art]]></title>
    <link href="http://browniefed.com/blog/2015/05/30/create-a-map-with-react-art/"/>
    <updated>2015-05-30T10:15:00-07:00</updated>
    <id>http://browniefed.com/blog/2015/05/30/create-a-map-with-react-art</id>
    <content type="html"><![CDATA[<h3>Intro</h3>

<p>Just Like the title states, we&rsquo;re going to make a map with <code>react-art</code>. When you think of maps many people jump straight to <code>leaflet</code>, <code>google maps</code>, or <code>mapbox</code>. Well one of the key things they are doing is just plotting map tiles.</p>

<p>Map tiles are just images that can be stitched together and form a map. That is why whenever you drag on a map portions of it pop in in squares.</p>

<p>Don&rsquo;t worry, I won&rsquo;t get deep into mapping terminology because I don&rsquo;t know it. If you want to learn checkout this post <a href="http://www.macwright.org/2012/05/15/how-web-maps-work.html">http://www.macwright.org/2012/05/15/how-web-maps-work.html</a></p>

<p>All you&rsquo;ll need to know is <code>Latitude</code>, <code>Longitude</code>, and <code>Tile</code> aka (an image of a piece of a map).</p>

<p>Our tilemap source will be the fabulous <a href="https://www.openstreetmap.org/">OpenStreetMap</a>. It&rsquo;s a community driven mapping solution. Check it out and contribute if you can!</p>

<p>This was going to be a blog post about creating a map but I ended up turning it into a library.</p>

<!-- more -->


<h3>What I Built</h3>

<p>I ended up writing up a library to show it off.</p>

<p>Checkout <a href="https://github.com/browniefed/react-art-map">https://github.com/browniefed/react-art-map</a> for the library and examples.</p>

<p>We use <a href="https://github.com/zacbarton/node-googlemaps-utils">https://github.com/zacbarton/node-googlemaps-utils</a> and
<a href="https://github.com/gagan-bansal/map-the-tiles">https://github.com/gagan-bansal/map-the-tiles</a>.</p>

<p>These 2 libraries are helper libraries.</p>

<p><code>googlemaps-utils</code> takes a <code>width/height</code> and a central <code>lat/long</code> and gives us a bounding box which is just the <code>top/left</code> coordinate and the <code>bottom/right</code> coordinate.</p>

<p>We then take that bounding box and convert it to meter points so we can generate a <a href="http://en.wikipedia.org/wiki/Mercator_projection">mercator projection</a>.</p>

<p>The <code>map-the-tiles</code> takes those meter points and returns <code>x,y,z</code> points;</p>

<p>Those <code>x,y,z</code> points get fed into the OSM url <code>http://{s}.tile.osm.org/{z}/{x}/{y}.png</code> and we get our tile images.</p>

<p>We can then render them at their given <code>top/left</code> points w/ <code>react-art</code>.</p>

<p>Ultimately this library was built with A LOT of googling and assembling some tools people already constructed.</p>

<h3>Some Internals</h3>

<p>Most of the logic is just in the <code>TileUtil</code>. There are likely much more efficient ways to do this however this is my first stab at it with my limited geo knowledge.</p>

<p>Converts <code>lat/long</code> to meter points
```</p>

<pre><code>degrees2meters(lon,lat) {
    var x = lon * 20037508.34 / 180;
    var y = Math.log(Math.tan((90 + lat) * Math.PI / 360)) / (Math.PI / 180);
    y = y * 20037508.34 / 180;
    return [x, y]
}
</code></pre>

<p>```</p>

<p>Converts meters to coordinates
```</p>

<pre><code>meters2degress(x,y) {
    var lon = x *  180 / 20037508.34 ;
    var lat = Number(180 / Math.PI * (2 * Math.atan(Math.exp(y * Math.PI / 180)) - Math.PI / 2));
    return [lon, lat]
}
</code></pre>

<p>```</p>

<p>The main layout generator.</p>

<p>```</p>

<pre><code>getTileLayout(options) {
    var layout = [];
    var bounds = gmu.calcBounds(options.center[1], options.center[0], options.zoom, options.width, options.height); // GET COORDINATE BOUNDS

    var topLeftMeters = TileUtil.degrees2meters(bounds.left, bounds.top),
        bottomRightMeters = TileUtil.degrees2meters(bounds.right, bounds.bottom);

    //Conver the coordinates each to meters

    var tiler = new MapTheTiles(null, options.tileWidth); // Create a generic tiler based on our tile width

    var layoutForBounds = {
        top: topLeftMeters[1],
        left: topLeftMeters[0],
        right: bottomRightMeters[0],
        bottom: bottomRightMeters[1]
    };
    //Pass in the meters for each point

    var tiles = tiler.getTiles(layoutForBounds, options.zoom) // Get the x,y,z points for our zoom level

    tiles.forEach(function(tile) {
        var coordPoint = {
            x: tile.X,
            y: tile.Y,
            z: tile.Z
        },
        coord = {
            x: tile.left,
            y: tile.top,
            img: TileUtil.getTileUrl(options.tileSource, coordPoint, options.subdomains) //Just format the OSM tile resource
        };

        layout.push(coord);
    }, this);

    return layout;
}
</code></pre>

<p>```</p>

<p>This is how we render each tile.
We have the <code>x/y</code> coordinates thanks to our tiler.</p>

<p>We use <code>Paths.js</code> to create a generic rectangular path.
This is so we can support <code>react-native</code> in the future since the shapes have yet to be created.</p>

<p>Then we create a new fill with the tile image and set it to the width/height of the generic tile at <code>0,0</code> of the shape.</p>

<p>This technically is a pattern for the background but because we set it to the exact <code>width/height</code> of the image it just renders the image once.</p>

<p>```
var rectanglePath = Rectangle({
  top: 0,
  left: 0,
  right: 256,
  bottom: 256
}).path.print();
///UP ABOVE</p>

<pre><code>    return layout.map(function(tile) {
        return (
            &lt;Shape
                d={rectanglePath}
                x={tile.x}
                y={tile.y}
                fill={new Pattern(tile.img, this.props.tileWidth , this.props.tileWidth, 0, 0)}
            /&gt;
        )
    }, this);
</code></pre>

<p>```</p>

<h3>The Code</h3>

<p>```
var React = require(&lsquo;react&rsquo;);
var ReactMap = require(&lsquo;react-art-map&rsquo;);
var ReactArt = require(&lsquo;react-art&rsquo;),</p>

<pre><code>Circle = require('react-art/shapes/circle');
</code></pre>

<p>var Map = ReactMap.Map;</p>

<p>var viewportWidth = function() {</p>

<pre><code>return  window.innerWidth - 100;
</code></pre>

<p>}
var viewportHeight = function() {</p>

<pre><code>return window.innerHeight - 100;
</code></pre>

<p>}</p>

<p>var center = [</p>

<pre><code>-122.668197,45.525292
</code></pre>

<p>],
offset = 3;</p>

<p>var Demo = React.createClass({
  getInitialState: function() {</p>

<pre><code>return {
  center: center,
  zoom: 15,
  x: 100
}
</code></pre>

<p>  },
  componentDidMount: function() {</p>

<pre><code>requestAnimationFrame(this.updateCircle);
</code></pre>

<p>  },
  updateCircle: function() {</p>

<pre><code>if (this.state.x &gt;= viewportWidth()) {
    offset = -3;
} else if ( this.state.x &lt;= 99) {
    offset = 3;
}

this.state.x += offset;
this.setState(this.state, function() {
    requestAnimationFrame(this.updateCircle);
});
</code></pre>

<p>  },
  handleDrag: function(newCenter) {</p>

<pre><code>this.setState({
  center: newCenter
});
</code></pre>

<p>  },
  render: function () {</p>

<pre><code>return (
  &lt;div&gt;
    &lt;Map
        width={viewportWidth()}
        height={viewportHeight()}
        center={this.state.center}
        zoom={this.state.zoom}
        tileSource="http://{s}.tile.osm.org/{z}/{x}/{y}.png"
        onDrag={this.handleDrag}
    &gt;
        &lt;Circle 
            x={this.state.x}
            y={100}
            radius={30}
            stroke="#000"
            strokeWidth={5}
        /&gt;
    &lt;/Map&gt;
  &lt;/div&gt;
);
</code></pre>

<p>  }
});</p>

<p>module.exports = Demo;
```</p>

<h3>React Native?!?!?!</h3>

<p>React Native has a map implementation but it doesn&rsquo;t allow for much flexibility. You can render pins but that is about it.</p>

<p>With this library once the Pattern fill gets implemented you can render any map tile based service + any cool visualiztions on the map that you want.</p>

<p>I&rsquo;ve logged an issue here <a href="https://github.com/facebook/react-native/issues/1462">https://github.com/facebook/react-native/issues/1462</a> so follow along for when it gets implemented.</p>

<h3>Results</h3>

<p data-height="624" data-theme-id="0" data-slug-hash="PqWRvz" data-default-tab="result" data-user="browniefed" class='codepen'>See the Pen <a href='http://codepen.io/browniefed/pen/PqWRvz/'>PqWRvz</a> by Jason Brown (<a href='http://codepen.io/browniefed'>@browniefed</a>) on <a href='http://codepen.io'>CodePen</a>.</p>


<script async src="http://browniefed.com//assets.codepen.io/assets/embed/ei.js"></script>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React-Art and Bar Charts]]></title>
    <link href="http://browniefed.com/blog/2015/05/29/react-art-and-bar-charts/"/>
    <updated>2015-05-29T08:53:00-07:00</updated>
    <id>http://browniefed.com/blog/2015/05/29/react-art-and-bar-charts</id>
    <content type="html"><![CDATA[<h3>Introduction</h3>

<p>I&rsquo;ve shown in the past how to utilize <code>react-art</code> and other libraries to do animations, and render arbitrary things. So now lets bring it all together, lets render a simple bar chart.</p>

<p>I&rsquo;m going to leverage <a href="https://github.com/andreaferretti/paths-js">Paths.js</a> because it was made for this exact reason. Given data, generate an immutable set of paths. Ultimately that is what visualizations are, a data set converted to a set of paths.</p>

<p>The end result will look something
<img class="<a" src="href="http://i.imgur.com/DpChFtO.png">http://i.imgur.com/DpChFtO.png</a>" title="Bar Chart Result w/ Hover" ></p>

<!-- more -->


<h3>Boilerplate</h3>

<p>I like to setup a boilerplate templat that just renders an arbitrary surface that is the full width of the viewport. Also to make things response we&rsquo;ll hook up some event listeners to the window resize and trigger a re-render.</p>

<p>We will bring in each side <code>100px</code> and add a <code>margin</code> of <code>50px</code> to each side to give us some padding on each side. Also note we should totally debounce the resize event on the window if this was production!</p>

<p>```
var React = require(&lsquo;react&rsquo;),</p>

<pre><code>ReactArt = require('react-art'),
Surface = ReactArt.Surface;
</code></pre>

<p>var viewportWidth = function() {</p>

<pre><code>return  window.innerWidth - 100;
</code></pre>

<p>}
var viewportHeight = function() {</p>

<pre><code>return window.innerHeight - 100;
</code></pre>

<p>}</p>

<p>var Demo = React.createClass({</p>

<pre><code>getInitialState: function() {
    return {
        width: viewportWidth(),
        height: viewportHeight()
    }
},
componentDidMount: function() {
    window.addEventListener('resize', this.refresh, false); //This should be debounced
},
componentWillUnmount: function() {
    window.removeEventListener('resize', this.refresh, false);
},
refresh: function() {
    this.setState({
        width: viewportWidth(),
        height: viewportHeight()
    });
},

render: function() {
    var bar = this.getBar();

    return (
        &lt;div style= style=&gt;
            &lt;Surface
                width={this.state.width}
                height={this.state.height}
            &gt;

            &lt;/Surface&gt;
        &lt;/div&gt;
    );
}
</code></pre>

<p>});</p>

<p>module.exports = Demo;
```</p>

<h3>Data and the Chart</h3>

<p>We need some data, so I&rsquo;ll steal some from the <code>Paths.js</code> wiki, and also steal the colors.</p>

<p>We&rsquo;ll add a method that returns a Bar Chart generated by <code>Paths.js</code> that is dervied from width/height we set on state.
A new Bar Chart will get called every time we call <code>setState</code>.</p>

<p>```
var data = [</p>

<pre><code>[
  { name: 'Italy', population: 59859996 },
  { name: 'Spain', population: 46704314 },
  { name: 'France', population: 65806000 },
  { name: 'Romania', population: 20121641 },
  { name: 'Greece', population: 10815197 }
],
[
  { name: 'Zambia', population: 14580290 },
  { name: 'Cameroon', population: 20386799 },
  { name: 'Nigeria', population: 173615000 },
  { name: 'Ethiopia', population: 86613986 },
  { name: 'Ghana', population: 24658823 }
]
</code></pre>

<p>  ];</p>

<p>var colorPallete = [&ldquo;#FEE871&rdquo;, &ldquo;#E5FAAF&rdquo;];</p>

<p>getBar: function() {</p>

<pre><code>var bar = Bar({
  data: data,
  accessor: function(x) { return x.population; }, // Value to use
  compute: {
    color: function(i) { return colorPallete[i]; } //Color of the bar
  },
  width: this.state.width, //Set it to our surface width so it is responsive when our surface width changes
  height: this.state.height, //Set it to our surface height so it's repsponsive
  gutter: 10
});

return bar;
</code></pre>

<p>}</p>

<p>```</p>

<h3>Lets create the X/Y axis bars</h3>

<p>The X axis and Y axis can be generated with straight lines by once again <code>Paths.js</code> <code>Path</code> method.</p>

<p>The <code>X</code> axis starts at the bottom left corner, so <code>0,height</code>, and runs to the far right, so <code>width,height</code>.</p>

<p>The <code>Y</code> axis starts at the top right corner, so <code>0,0</code>, and runs along the left side to the bottom so <code>0,height</code></p>

<p>We merely stroke a 1px black line.</p>

<p>```
getXAxis: function() {</p>

<pre><code>var path = Path().moveto(0, this.state.height).lineto(this.state.width, this.state.height);
return (
    &lt;Shape d={path.print()} strokeWidth={1} stroke="#000" /&gt;
);   
</code></pre>

<p>},
getYAxis: function() {</p>

<pre><code>var path = Path().moveto(0,0).lineto(0, this.state.height);
return (
    &lt;Shape d={path.print()} strokeWidth={1} stroke="#000" /&gt;
); 
</code></pre>

<p>},
render: function() {</p>

<pre><code>    return (
        &lt;div style= style=&gt;
            &lt;Surface
                width={this.state.width}
                height={this.state.height}
            &gt;
                &lt;Group&gt;
                    {this.getXAxis()}
                    {this.getYAxis()}
                &lt;/Group&gt;
            &lt;/Surface&gt;
        &lt;/div&gt;
    );
}
</code></pre>

<p>```</p>

<h3>Render the Bar Graph</h3>

<p>We&rsquo;ll call <code>this.getBar()</code> to just generate one bar graph and then pipe it into each function that needs it.
To make this more testable we&rsquo;d probably just want to provide each function with absolutely necessary info but just keep that in mind if you implement this for real.</p>

<p>All we do is map over each <code>curve</code> that we have, in our case we have <code>10</code> data points so therefore we have <code>10</code> curves.
The color comes from the way we grouped our data and the pallette we provided in the first step.</p>

<p>```</p>

<pre><code>getBarChart: function(bar) {
    return bar.curves.map(function(bar) {
        return (
            &lt;Group&gt;
              &lt;Shape d={bar.line.path.print()} fill={bar.color}/&gt;
            &lt;/Group&gt;
        )
    }, this)
},
render: function() {
    var bar = this.getBar();

    return (
        &lt;div style= style=&gt;
            &lt;Surface
                width={this.state.width}
                height={this.state.height}
            &gt;
                &lt;Group&gt;
                    {this.getBarChart(bar)} 
                &lt;/Group&gt;
                &lt;Group&gt;
                    {this.getXAxis(bar)}
                    {this.getYAxis(bar)}
                &lt;/Group&gt;
            &lt;/Surface&gt;
        &lt;/div&gt;
    );
}
</code></pre>

<p>```</p>

<h3>Render the Bar Information</h3>

<p>Lets also display some text about the bars. We&rsquo;ll use <code>Text</code> from <code>react-art</code> to do that.
We need to calculate a few points, which <code>Paths.js</code> will help us with.</p>

<p>Since each bar is a rectangle it just has 4 points, we can get the <code>points</code> from the path.
The path will gives us 4 arrays, each with <code>x,y</code> coordinates of each corner point.</p>

<p>We need to do a little subtraction of the <code>x,y</code> coordinates to figure out the width of each bar, and height of each bar so we can place our text.</p>

<p>We&rsquo;ll use the <code>Group</code> element from <code>react-art</code> to adjust our coordinate system to start at the top left of each bar.
The name and population will be aligned to the center, and at the bottom of the bar. We can use <code>x,y</code> coordinates to derive our width/height.</p>

<p>```</p>

<pre><code>getBarChart: function(bar) {
    return bar.curves.map(function(bar) {

        var points = bar.line.path.points(),
            right = points[0][0],
            top = points[0][1],
            left = points[2][0],
            bottom = points[2][1],
            width = right - left,
            height = bottom - top;

        return (
            &lt;Group&gt;
              &lt;Shape d={bar.line.path.print()} fill={bar.color}/&gt;

              &lt;Group x={left} y={top}&gt;
                &lt;Text x={width/2} y={height - 24} alignment="middle" fill="#000" font='bold 10px "Arial"'&gt;{bar.item.name}&lt;/Text&gt;
                &lt;Text x={width/2} y={height - 12} alignment="middle" fill="#000" font='bold 10px "Arial"'&gt;{bar.item.population +''}&lt;/Text&gt;
              &lt;/Group&gt;
            &lt;/Group&gt;
        )
    }, this)
},
</code></pre>

<p>```</p>

<h3>Hover data for fun</h3>

<p>Just to show how to handle mouse events we can have a <code>mouseMove</code> on each bar.
We&rsquo;ll bind each hover event with the <code>item</code> object which has the name and population.</p>

<p>When a new bar is hovered or the mouse is moved it will set the <code>hoveredItem</code> object and coordinates on our state which will cause a re-render.
Each movement of the mouse will cause a re-render so be sure and debounce this as well.</p>

<p>The hovered data displayed will actually use HTML not <code>react-art</code> since we wrap the <code>Surface</code> in a <code>div</code> and give it <code>position:relative</code>. This will mean it has the same coordinates as our <code>Surface</code> mouse events which is why we can just use <code>x,y</code> on the event.</p>

<p>```</p>

<pre><code>handleMouseMove: function(item, e) {
    this.setState({
        hoveredItem: item,
        hoveredY: e.y,
        hoveredX: e.x
    });
},
getBarChart: function(bar) {
    return bar.curves.map(function(bar) {

        var points = bar.line.path.points(),
            right = points[0][0],
            top = points[0][1],
            left = points[2][0],
            bottom = points[2][1],
            width = right - left,
            height = bottom - top;

        return (
            &lt;Group 
              onMouseMove={this.handleMouseMove.bind(this, bar.item)}
            &gt;
              &lt;Shape d={bar.line.path.print()} fill={bar.color}/&gt;

              &lt;Group x={left} y={top}&gt;
                &lt;Text x={width/2} y={height - 24} alignment="middle" fill="#000" font='bold 10px "Arial"'&gt;{bar.item.name}&lt;/Text&gt;
                &lt;Text x={width/2} y={height - 12} alignment="middle" fill="#000" font='bold 10px "Arial"'&gt;{bar.item.population +''}&lt;/Text&gt;
              &lt;/Group&gt;
            &lt;/Group&gt;
        )
    }, this)
},
getHoveredData: function() {
    if (!this.state.hoveredItem) {
        return null;
    }
    return (
            &lt;div style=&gt;
                &lt;h2&gt;{this.state.hoveredItem.name}&lt;/h2&gt;
                &lt;h5&gt;{this.state.hoveredItem.population}&lt;/h5&gt;
            &lt;/div&gt;
        )
},
render: function() {
    var bar = this.getBar();

    return (
        &lt;div style= style=&gt;
            &lt;Surface
                width={this.state.width}
                height={this.state.height}
            &gt;
                &lt;Group&gt;
                    {this.getBarChart(bar)} 
                &lt;/Group&gt;
                &lt;Group&gt;
                    {this.getXAxis(bar)}
                    {this.getYAxis(bar)}
                &lt;/Group&gt;
            &lt;/Surface&gt;
            {this.getHoveredData()}

        &lt;/div&gt;
    );
}
</code></pre>

<p>```</p>

<h3>Final Code</h3>

<p>Finally all the code combined.</p>

<p>```
var React = require(&lsquo;react&rsquo;),</p>

<pre><code>ReactArt = require('react-art'),
Surface = ReactArt.Surface,
Group = ReactArt.Group,
Text = ReactArt.Text,
Shape = ReactArt.Shape,
Bar = require('paths-js/bar'),
Path = require('paths-js/path');
</code></pre>

<p>var viewportWidth = function() {</p>

<pre><code>return  window.innerWidth - 100;
</code></pre>

<p>}
var viewportHeight = function() {</p>

<pre><code>return window.innerHeight - 100;
</code></pre>

<p>}</p>

<p>var data = [</p>

<pre><code>[
  { name: 'Italy', population: 59859996 },
  { name: 'Spain', population: 46704314 },
  { name: 'France', population: 65806000 },
  { name: 'Romania', population: 20121641 },
  { name: 'Greece', population: 10815197 }
],
[
  { name: 'Zambia', population: 14580290 },
  { name: 'Cameroon', population: 20386799 },
  { name: 'Nigeria', population: 173615000 },
  { name: 'Ethiopia', population: 86613986 },
  { name: 'Ghana', population: 24658823 }
]
</code></pre>

<p>  ];</p>

<p>var colorPallete = [&ldquo;#FEE871&rdquo;, &ldquo;#E5FAAF&rdquo;, &ldquo;#B7E5F5&rdquo;];</p>

<p>var Demo = React.createClass({</p>

<pre><code>getInitialState: function() {
    return {
        width: viewportWidth(),
        height: viewportHeight()
    }
},
componentDidMount: function() {
    window.addEventListener('resize', this.refresh, false); //This should be debounced
},
componentWillUnmount: function() {
    window.removeEventListener('resize', this.refresh, false);
},
refresh: function() {
    this.setState({
        width: viewportWidth(),
        height: viewportHeight()
    });
},
getBar: function() {

    var bar = Bar({
      data: data,
      accessor: function(x) { return x.population; }, // Value to use
      compute: {
        color: function(i) { return colorPallete[i]; } //Color of the bar
      },
      width: this.state.width, //Set it to our surface width so it is responsive when our surface width changes
      height: this.state.height, //Set it to our surface height so it's repsponsive
      gutter: 10
    });

    return bar;
},
handleMouseMove: function(item, e) {
    this.setState({
        hoveredItem: item,
        hoveredY: e.y,
        hoveredX: e.x
    });
},
getBarChart: function(bar) {
    return bar.curves.map(function(bar) {

        var points = bar.line.path.points(),
            right = points[0][0],
            top = points[0][1],
            left = points[2][0],
            bottom = points[2][1],
            width = right - left,
            height = bottom - top;

        return (
            &lt;Group 
              onMouseMove={this.handleMouseMove.bind(this, bar.item)}
            &gt;
              &lt;Shape d={bar.line.path.print()} fill={bar.color}/&gt;

              &lt;Group x={left} y={top}&gt;
                &lt;Text x={width/2} y={height - 24} alignment="middle" fill="#000" font='bold 10px "Arial"'&gt;{bar.item.name}&lt;/Text&gt;
                &lt;Text x={width/2} y={height - 12} alignment="middle" fill="#000" font='bold 10px "Arial"'&gt;{bar.item.population +''}&lt;/Text&gt;
              &lt;/Group&gt;
            &lt;/Group&gt;
        )
    }, this)
},
getXAxis: function(bar) {
    var path = Path().moveto(0, this.state.height).lineto(this.state.width, this.state.height);
    return (
        &lt;Shape d={path.print()} strokeWidth={1} stroke="#000" /&gt;
    );   
},
getYAxis: function(bar) {
    var path = Path().moveto(0,0).lineto(0, this.state.height);
    return (
        &lt;Shape d={path.print()} strokeWidth={1} stroke="#000" /&gt;
    ); 
},
getHoveredData: function() {
    if (!this.state.hoveredItem) {
        return null;
    }
    return (
            &lt;div style=&gt;
                &lt;h2&gt;{this.state.hoveredItem.name}&lt;/h2&gt;
                &lt;h5&gt;{this.state.hoveredItem.population}&lt;/h5&gt;
            &lt;/div&gt;
        )
},
render: function() {
    var bar = this.getBar();

    return (
        &lt;div style= style=&gt;
            &lt;Surface
                width={this.state.width}
                height={this.state.height}
            &gt;
                &lt;Group&gt;
                    {this.getBarChart(bar)} 
                &lt;/Group&gt;
                &lt;Group&gt;
                    {this.getXAxis(bar)}
                    {this.getYAxis(bar)}
                &lt;/Group&gt;
            &lt;/Surface&gt;
            {this.getHoveredData()}

        &lt;/div&gt;
    );
}
</code></pre>

<p>});</p>

<p>module.exports = Demo;
```</p>

<h3>Results</h3>

<p data-height="624" data-theme-id="0" data-slug-hash="LVxjPw" data-default-tab="result" data-user="browniefed" class='codepen'>See the Pen <a href='http://codepen.io/browniefed/pen/LVxjPw/'>LVxjPw</a> by Jason Brown (<a href='http://codepen.io/browniefed'>@browniefed</a>) on <a href='http://codepen.io'>CodePen</a>.</p>


<script async src="http://browniefed.com//assets.codepen.io/assets/embed/ei.js"></script>


<h3>Conclusion</h3>

<p>Once again <a href="https://github.com/andreaferretti/paths-js">Paths.js</a> comes in handy for generating arbitrary path information, and providing access to a lot of valuable data to making laying out your graphs with <code>react-art</code> a breeze.</p>

<p>Some homework for you is to add some vertical labels at each particular step.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Art and Paths.js]]></title>
    <link href="http://browniefed.com/blog/2015/05/27/react-art-and-paths-dot-js/"/>
    <updated>2015-05-27T19:32:00-07:00</updated>
    <id>http://browniefed.com/blog/2015/05/27/react-art-and-paths-dot-js</id>
    <content type="html"><![CDATA[<h3>Intro</h3>

<p><a href="https://github.com/andreaferretti/paths-js">Paths.js</a> is a cool library. It comes with 3 levels of generating paths.</p>

<ul>
<li>Low level which helps you generate paths/lines.</li>
<li>Mid level which generates paths for shapes</li>
<li>High level which takes a set of data and generates graphs</li>
</ul>


<p>All of these are great when working with <code>react-art</code> because it&rsquo;s just returning data. I&rsquo;ll say it once, and a million more but libraries that just generate data make it easy to traverse and render with <code>react-art</code>.</p>

<!-- more -->


<h3>Paths</h3>

<h4>UPDATE:</h4>

<p>Sebastian Markbage (the creator of ReactART and ART), informed me that <code>ReactART</code> itself has a <code>Path</code> implementation. I realized this but didn&rsquo;t think much of it.
However per the discussion here <a href="https://discuss.reactjs.org/t/react-art-with-paths-js/492">https://discuss.reactjs.org/t/react-art-with-paths-js/492</a> the <code>ART</code> path is faster as it takes advantage of the current <code>mode</code> to create the most efficient path instead of taking a string and converting it back into native for instructions for canvas rendering.</p>

<p>The <code>ReactART.Path</code> has similar methods. Check out the discuss thread for a link to the implementation to find out the supported methods. I&rsquo;m currently working on <code>ReactART</code> documentation so expect that soon.</p>

<p>Example:</p>

<p><code>
var path = Path()
  .moveto(10, 20)
  .lineto(30, 50)
  .lineto(25, 28)
  .qcurveto(27, 30, 32, 27)
  .closepath();
</code></p>

<p>This is can just be plugged right into <code>react-art</code> <code>Shape</code> element.</p>

<p>Like so</p>

<p>```
var React = require(&lsquo;react&rsquo;),</p>

<pre><code>ReactArt = require('react-art'),
Surface = ReactArt.Surface,
Shape = ReactArt.Shape,
Path = require('paths-js/path');
</code></pre>

<p>var Demo = React.createClass({</p>

<pre><code>getInitialState: function() {
    return {
        to: {
            x: 30,
            y: 50
        }
    }
},
getPath: function() {
    var path = Path()
                  .moveto(10, 20)
                  .lineto(this.state.to.x, this.state.to.y)
                  .lineto(25, 28)
                  .qcurveto(27, 30, 32, 27)
                  .closepath();

    return path.print();
},
startAnimating: function() {

    if (this.state.to.x === 100) {
        this.addToPosition = -1;
    } else if (this.state.to.x === 29) {
        this.addToPosition = 1;
    }

    this.state.to.x += this.addToPosition;
    this.state.to.y += this.addToPosition;

    this.setState(this.state);
},
componentDidMount: function() {
    this.addToPosition = 1;
    setInterval(this.startAnimating, 17)
},
render: function() {
    return (
        &lt;div&gt;
            &lt;Surface
                width={500}
                height={500}
            &gt;
                &lt;Shape d={this.getPath()} stroke="#000" strokeWidth={1} /&gt;
            &lt;/Surface&gt;
        &lt;/div&gt;
    )
}
</code></pre>

<p>});</p>

<p>module.exports = Demo;
```</p>

<p data-height="624" data-theme-id="0" data-slug-hash="VLmOOE" data-default-tab="result" data-user="browniefed" class='codepen'>See the Pen <a href='http://codepen.io/browniefed/pen/VLmOOE/'>VLmOOE</a> by Jason Brown (<a href='http://codepen.io/browniefed'>@browniefed</a>) on <a href='http://codepen.io'>CodePen</a>.</p>


<script async src="http://browniefed.com//assets.codepen.io/assets/embed/ei.js"></script>


<h3>Simple Shapes</h3>

<p>Now <code>react-art</code> already comes with a few different shapes but <code>paths.js</code> have a few built in as well, like <code>Rectangle</code> and <code>Bezier</code> curve.</p>

<p><code>
var rectangle = Rectangle({
  top: 10,
  bottom: 3,
  left: -2,
  right: 5
});
</code></p>

<p>And how that looks is very similar to the previous example</p>

<p>```
var React = require(&lsquo;react&rsquo;),</p>

<pre><code>ReactArt = require('react-art'),
Surface = ReactArt.Surface,
Group = ReactArt.Group,
Shape = ReactArt.Shape,
Rectangle = require('paths-js/rectangle'),
Bezier = require('paths-js/bezier');
</code></pre>

<p>var Demo = React.createClass({</p>

<pre><code>getPath: function() {
    var rectangle = Rectangle({
                  top: 10,
                  bottom: 3,
                  left: -2,
                  right: 5
                });

    return rectangle.path.print();
},
getBez: function() {
    var points = [[1, 50], [50, 100], [100, 3], [4, 0]];
    var curve = Bezier({
      points: points,
      tension: 0.2
    });

    return curve.path.print();
},
render: function() {
    return (
        &lt;div&gt;
            &lt;Surface
                width={500}
                height={500}
            &gt;
                &lt;Group x={100} y={100}&gt;
                    &lt;Shape d={this.getPath()} stroke="#000" strokeWidth={1} /&gt;
                &lt;/Group&gt;
                &lt;Group x={200} y={200}&gt;
                    &lt;Shape d={this.getBez()} stroke="#000" strokeWidth={1} /&gt;
                &lt;/Group&gt;
            &lt;/Surface&gt;
        &lt;/div&gt;
    )
}
</code></pre>

<p>});</p>

<p>module.exports = Demo;
```</p>

<p data-height="624" data-theme-id="0" data-slug-hash="xGRNvW" data-default-tab="result" data-user="browniefed" class='codepen'>See the Pen <a href='http://codepen.io/browniefed/pen/xGRNvW/'>xGRNvW</a> by Jason Brown (<a href='http://codepen.io/browniefed'>@browniefed</a>) on <a href='http://codepen.io'>CodePen</a>.</p>


<script async src="http://browniefed.com//assets.codepen.io/assets/embed/ei.js"></script>


<h3>Graphs</h3>

<p>```
var pie = Pie({
  data: [</p>

<pre><code>{ name: 'Italy', population: 59859996 },
{ name: 'Mexico', population: 118395054 },
{ name: 'France', population: 65806000 },
{ name: 'Argentina', population: 40117096 },
{ name: 'Japan', population: 127290000 }
</code></pre>

<p>  ],
  accessor: function(x) { return x.population; },
  compute: {</p>

<pre><code>color: function(i) { return somePalette[i]; }
</code></pre>

<p>  },
  center: [20, 15],
  r: 30,
  R: 50
});
```</p>

<p>Some code of it in action</p>

<p>```
var React = require(&lsquo;react&rsquo;),</p>

<pre><code>ReactArt = require('react-art'),
Surface = ReactArt.Surface,
Group = ReactArt.Group,
Shape = ReactArt.Shape,
Pie = require('paths-js/Pie');
</code></pre>

<p>var pie = Pie({
  data: [</p>

<pre><code>{ name: 'Italy', population: 59859996 },
{ name: 'Mexico', population: 118395054 },
{ name: 'France', population: 65806000 },
{ name: 'Argentina', population: 40117096 },
{ name: 'Japan', population: 127290000 }
</code></pre>

<p>  ],
  accessor: function(x) { return x.population; },
  compute: {</p>

<pre><code>color: function(i) { return '#000'; }
</code></pre>

<p>  },
  center: [20, 15],
  r: 30,
  R: 50
});</p>

<p>var Demo = React.createClass({</p>

<pre><code>getPie: function() {
    return pie.curves.map(function(shape) {
        return (
            &lt;Group&gt;
                &lt;Text fill="#A6BD8A" font='bold 12px "Arial"' x={shape.sector.centroid[0] - 12} y={shape.sector.centroid[1]}&gt;{shape.item.name}&lt;/Text&gt;
                &lt;Shape d={shape.sector.path.print()} stroke={shape.color} strokeWidth={1} /&gt;
            &lt;/Group&gt;
        )
    })
},
render: function() {
    return (
        &lt;div&gt;
            &lt;Surface
                width={500}
                height={500}
            &gt;
                &lt;Group x={50} y={45}&gt;
                    {this.getPie()}
                &lt;/Group&gt;
            &lt;/Surface&gt;
        &lt;/div&gt;
    )
}
</code></pre>

<p>});</p>

<p>module.exports = Demo;
```</p>

<p data-height="624" data-theme-id="0" data-slug-hash="waoLvB" data-default-tab="result" data-user="browniefed" class='codepen'>See the Pen <a href='http://codepen.io/browniefed/pen/waoLvB/'>waoLvB</a> by Jason Brown (<a href='http://codepen.io/browniefed'>@browniefed</a>) on <a href='http://codepen.io'>CodePen</a>.</p>


<script async src="http://browniefed.com//assets.codepen.io/assets/embed/ei.js"></script>


<h3>Conclusion</h3>

<p>These examples may look boring but they just show off a bit of the control you can have with <code>react-art</code> and a simple path generator.
Not only that but because we aren&rsquo;t depending on the DOM in any case these examples should also work on <code>react-native</code>.
Combined with some tweening you could make some very effective graphs that animate. That is a topic for another time.</p>
]]></content>
  </entry>
  
</feed>
